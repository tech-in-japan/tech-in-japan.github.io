<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛈️ 😣 🍢 2次元のパッケージ化について：オフラインアルゴリズム 💂 🏇🏼 🌹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今日、Habr様、コンビナトリアルオプティマイゼーションについてお話します。 
  
 古代（少なくとも前世紀の初めから）から、数学者は、必要で有用な物のある量のビールをバックパックに最適に入れる方法を知りました。 ナップザックとそのサブタスクの問題が定式化されました-何千もの！ -コンピュータ科学...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>2次元のパッケージ化について：オフラインアルゴリズム</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> 今日、Habr様、コンビナトリアルオプティマイゼーションについてお話します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     古代（少なくとも前世紀の初めから）から、数学者<s>は、</s>必要で有用な物のある量の<s>ビールを</s>バックパックに最適に入れる方法を知りました。  <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D1%2580%25D0%25B0%25D0%25BD%25D1%2586%25D0%25B5">ナップザック</a>とそのサブタスクの<a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D1%2580%25D0%25B0%25D0%25BD%25D1%2586%25D0%25B5">問題</a>が定式化されました-何千もの！  -コンピュータ科学者、暗号作成者、さらには言語学者に興味を持っている。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2次元のパッケージング（2次元のビンパッキング）の問題の1つである<a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE%25D0%25B1_%25D1%2583%25D0%25BF%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B5_%25D0%25B2_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B5%25D1%2580%25D1%258B">コンテナーの</a> <a href="http://en.wikipedia.org/wiki/Bin_packing_problem">パッキング</a> （ <a href="http://en.wikipedia.org/wiki/Bin_packing_problem">ビンパッキング問題</a> ）は、ナップザックの問題から生じました。 いくつかのバリエーションを再び破棄したので、ようやく半制限されたストリップの2次元パッキング（2次元ストリップパッキング、2DSP）に行きました。 すでに舞台裏にどれだけ面白いものが残っているのか感じてください。 しかし、私たちは分類を歩き終えていません。  2DSPには2つの入力オプションがあります。パックされたオブジェクトのセットが事前にわかっている場合（オフラインの問題）と、データがバッチで到着する場合（オンラインの問題）です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事では、オフラインバリアント2DSPを解決するためのアルゴリズムについて説明します。 カットの下には、少しの素材と色の付いた正方形の写真がたくさんあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 実際、問題は何ですか？ </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>  2次元のパッキング問題の特殊なケースとして、2DSPは、特定の形状のオブジェクトを特定の形状の有限数のコンテナーにパッキングすることにあり、使用されるコンテナーの数が最小になるか、オブジェクトの数または体積（パックされる）が最大になります。  2次元パッケージとの違いは、コンテナが1つしかないことです。コンテナの数を最小化する代わりに、1つの高さを最小化します。 必要に応じて最大の梱包密度を提供します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     問題はNP困難であるため、研究は主に近似解法アルゴリズムの開発に焦点を当てています。  （ <a href="http://habrahabr.ru/post/139646/">遺伝的アルゴリズム</a>はHabréで言及されました）。 近似アルゴリズムは、一定の精度で最適なソリューションを見つけますが、データセットの最適なパッケージ化を保証するものではありません。 この場合、最適性の基準は、最適化しようとしたものによって異なります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私は、最も単純な戦略と、これが人生でどのように適用されるかについて説明します（ビールの入ったバックパックを除く）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、n個の長方形のセットと、幅Wが固定され、高さが無限の半制限のコンテナーガラスがあります。 幅の各長方形はWを超えません。タスクは、グラスをできるだけ小さくするために、オーバーレイや交差なしで長方形をグラスに入れることです。 すべての長方形を直交してパックする必要があり、回転できないことに同意しましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td><img src="https://habrastorage.org/storage2/fea/fdf/16b/feafdf16b024ba25aae34c8687e9aa75.png"></td><td><img src="https://habrastorage.org/storage2/3f4/bc1/1c5/3f4bc11c512a925b6e9542b9a1d62c78.png"></td><td><img src="https://habrastorage.org/storage2/16b/a5e/948/16ba5e948e37da88efae9c2109f5ead8.png"></td><td><img src="https://habrastorage.org/storage2/63b/f1a/993/63bf1a993011193e2d831f88e8119b39.png"></td></tr><tr><td> ソースデータ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      （20世紀の初め、キュービズム） </td><td> 半制限車線 </td><td> 包装オプション（悪い） </td><td> パッケージングオプション（より良い） </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題には、パックされた長方形の高さがストリップの幅で割った合計面積に等しいという理想的なソリューションがあることがわかります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 動物園アルゴリズム </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2DSPのオフラインバージョンでは、すべてのパックされた長方形のサイズがすぐにわかるため、特定の基準に従ってソート、選択、グループ化、または適切な場所への単純なバンプが可能です。 ほとんどのアルゴリズムはこれに基づいています： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> レベル（レベル） </li><li> 棚（棚） </li><li> フラット（平面） </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フラットアルゴリズムは長方形を互いに厳密に近づけて配置しますが、これは一見すると思われるかもしれませんが、これは最も成功した戦略ではありません。 レベル1は、ストリップを選択された長方形の1つと同じ高さのレベルに分割し、他のすべてを特定の基準に従って特定のレベルに配置します。 シェルフシェルフは、一度に複数のシェルフ（シェルフ）を事前に決定し、それらに沿って長方形をプッシュします。この動作はオンラインアルゴリズムの典型であり、これはまったく別の話です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一般的な単語に拡張するよりも、すべてを順番に処理する方が適切です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 次のフィット減少高 </h2><img src="https://habrastorage.org/storage2/6a6/e22/926/6a6e22926f919f9e104f3d8e5062e107.png" align="right"><img src="https://habrastorage.org/storage2/8fd/d9d/dff/8fdd9ddff0a9fcc3b46b16bd2e562eea.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     彼らが言うように、アルゴリズムは「額に」。 長方形は高さの増加なし（高さの減少のヒント）で並べ替えられ、最高はストリップの左下隅にあり、それにより高さが等しい最初のレベルを初期化します。 残りの長方形は左から右に配置されますが、現在のレベルにはスペースがあります。 レベルに収まらない長方形は上に配置され、次のレベルを形成します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次の2つの例について、各アルゴリズムの図を作成します。明確にするために、左側では長方形の形状が長くなり、右側ではより正方形になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>NFDHアルゴリズム</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法 
        {w（Li）;  h（Li）}およびストリップ幅W
出力：ストリップで得られたパッキングの高さ。
  1：レベル= 0;  h（レベル）= 0;  w（レベル）= 0;  i = 1
  2：h（L1）≥h（L2）≥...≥h（Ln）のように、高さが増加しない順に長方形をソートします
  3：ストリップの下部で左揃えの長方形Liをパック
  4：h（レベル）= h（Li）;  w（レベル）= w（Li）
  5：i = 2..nの場合
  6：W-w（レベル）≥w（Li）の場合
  7：長方形Li-1の右側に長方形Liを詰める
  8：w（レベル）+ = w（Li）
  9：else [W-w（レベル）&lt;w（Li）]
 10：前のレベルの上に新しいレベルを作成し、新しいレベルに長方形Liをパックします
 11：レベル++;  w（レベル）= w（Li）;  h（レベル）= h（レベル-1）+ h（Li）
 12：終了する場合
 13：終了
 14：H = h（レベル）を印刷 </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> ファーストフィットの減少 </h2><img src="https://habrastorage.org/storage2/930/2c5/691/9302c5691e5e6d7dcc55bee16d030457.png" align="right"><img src="https://habrastorage.org/storage2/0f2/e66/e5b/0f2e66e5b651ef5b4381e70bd6d9fd92.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     前のアルゴリズムと同様に、次の長方形ごとに、場所が最後のレベルだけでなく、最低レベルから検索されるという違いがあります。 したがって、「最初の適合」-長方形は下から最初の適切なレベルに配置されます。 直観的には、パッケージングの方が優れています。 別の重要な違いはパフォーマンスです。最悪の場合、すべてのレベルをボトムアップですべてのステップで考慮する必要があるためです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>FFDHアルゴリズム</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法
        {w（Li）;  h（Li）}およびストリップ幅W
出力：ストリップで得られたパッキングの高さ。
  1：レベル= 0;  h（レベル）= 0;  i = 1;  LevelNum = 1
  2：h（L1）≥h（L2）≥...≥h（Ln）のように、高さが増加しない順に長方形をソートします
  3：ストリップの下部で左揃えの長方形Liをパックします。  h（レベル+ 1）= h（Li）
  4：for i = 2..n do
  5：すべてのレベルを（下から）十分なスペースのある最低レベルで検索します
  6：そのようなレベルが存在する場合
  7：長方形Liをそのレベルで左揃えでパック
  8：その他[既存のすべてのレベルに十分なスペースがない]
  9：LevelNum ++;  level = LevelNum;  h（レベル）= h（レベル-1）+ h（Li）
 10：新しいレベルで長方形Liをパックする
 11：終了する場合
 12：終了
 13：H = h（レベル）を印刷 </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> ベストフィットが高くなる </h2><img src="https://habrastorage.org/storage2/3ec/d9c/473/3ecd9c4731670c2e32065b4bfa807217.png" align="right"><img src="https://habrastorage.org/storage2/e9c/298/889/e9c2988891ca6b7c7625a6f01cbd1012.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     前のアルゴリズムの修正。 その本質は、最初の長方形ではなく、次の長方形のパッキングに適したレベルのものであり、最適なものが選択されます。 最適なレベルは、現在の四角形をパックした後にスペースが最小限になるレベルです。 簡単に言えば、最小の適切なスペースが選択され、レベルのより良い充填に貢献します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>BFDHアルゴリズム</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法
        {w（Li）;  h（Li）}およびストリップ幅W
出力：ストリップで得られたパッキングの高さ。
  1：レベル= 0;  h（レベル）= 0;  i = 1;  LevelNum = 1
  2：h（L1）≥h（L2）≥...≥h（Ln）のように、高さが増加しない順に長方形をソートします
  3：ストリップの下部で左揃えの長方形Liをパックします。  h（レベル+ 1）= h（Li）
  4：for i = 2..n do
  5：すべてのレベルを検索して、十分なスペースがあり、残りのスペースが最小のレベルを探します
  6：そのようなレベルが存在する場合
  7：長方形Liをそのレベルで左揃えでパック
  8：その他[既存のすべてのレベルに十分なスペースがない]
  9：最上位レベルの上に新しいレベルを作成し、長方形Liをパックします
 10：LevelNum ++;  level = LevelNum;  h（レベル）= h（レベル-1）+ h（Li）
 11：終了する場合
 12：終了
 13：H = h（レベル）を印刷 </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> ナップザック0-1 </h2><img src="https://habrastorage.org/storage2/420/e76/9c0/420e769c021330be93683e010627842d.png" align="right"><img src="https://habrastorage.org/storage2/895/7b5/c43/8957b5c4378163e190394b90dd85fdb7.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここに詳しく滞在する価値があります。  <a href="http://en.wikipedia.org/wiki/Knapsack_problem">ナップザック0-1</a>は、ナップザック問題の特殊なケースです。 主な質問（いいえ、42ではなく、結果のパッケージングボリューム）に<i>答える</i>だけでなく、 <i>ソリューション（</i>パッケージ化する必要があるアイテムのリスト）を提供することも注目に値します。 手順は次のとおりです。長方形は高さの増加しない順にソートされます。 最初の長方形は新しいレベルにパックされます。 このレベルでは、ナップザック0-1問題の解決策があります。これは、面積が最大化された長方形のリストを提供します。 選択された長方形がパックされ、アンパックされたリストから抽出され、レベルが閉じられ、新しい長方形が開きます-通常どおり、残りの最初の（最高）が初期化されます。 長方形ができるまで繰り返します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>アルゴリズムKP01</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法
        {w（Li）;  h（Li）}およびストリップ幅W
出力：ストリップで得られたパッキングの高さ。
  1：h（L1）≥h（L2）≥...≥h（Ln）のように、高さが増加しない順に長方形をソートします
  2：レベル= 0
  3：展開された長方形がある間に
  4：最初にアンパックされた長方形をパック、Liが言う
  5：h（レベル）+ = h（Li）
  6：KP01インスタンスを解決する
  7：選択した長方形をパック
  8：レベル=レベル+ 1
  9：しばらくの間
 10：印刷H = h（レベル） </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> スプリットフィット </h2><img src="https://habrastorage.org/storage2/130/e32/271/130e3227185b14c5e79a69771e421042.png" align="right"><img src="https://habrastorage.org/storage2/de3/b6f/b3d/de3b6fb3db4fe66394830d124fb570ed.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「分割統治」の原則に基づいてFFDNを改善するために設計されたアルゴリズム。 まず、ストリップの半分よりも広い長方形が選択されます。 最初に梱包されます。 これらのうち、さらに広いものが選択されます。ストリップの2/3よりも広いです。  FFDHアルゴリズムが詰め込まれています。 それらの上に、 <i>次のレベルから始め</i>ましょう（レベルRと呼びましょう）、残りの1つはパックされています。それらはまだ1/2より広いですが、すでに2/3です。 また、FFDHを使用してパッケージ化されます。 この分割は、レベルRで始まり、パッケージの現在の上部境界で終わる、ちょうどパックされたものの右側に1/3の幅の空き領域を作成します（つまり、長方形1/2 &lt;幅&lt;= 2/3の上に拡張しません）。  1/2ストライプよりも狭い残りのすべての長方形は、最初に同じFFDHを使用して、形成された領域に詰め込まれ、収まらない場合は上から詰められます。 言葉では面倒に聞こえますが、画像はより鮮明になります。 そして、私の文学的なエクササイズにすでに疲れている人のために-擬似コード： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>SFアルゴリズム</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法
        {w（Li）;  h（Li）}およびストリップ幅W
出力：ストリップで得られたパッキングの高さ。
 1：m≥1をL内のすべての長方形の最大整数とします
   最大で幅1 = m
 2：長方形のリストLを2つのサブリストL1とL2に分割します
    L1は、幅よりも大きい長方形のリストです
    1 /（m + 1）、L2は最大1 /（m + 1）の幅の長方形のリスト
 3：FFDHアルゴリズムを使用して、L1長方形をストリップに詰めます
 4：このパッキングのブロックを再配置して、幅のブロックを
    （m + 1）/（m + 2）よりも大きい場合、幅よりも小さい
   最大（m + 1）/（m + 2）
 5：幅が最大で1 /（m + 2）の長方形を領域Rに詰める
   長方形が上部に重ならないようにFFDHアルゴリズムを使用する
    RのRとRに収まらないものは、L1のパッキングの上にパッキングされます。
 6：各レベルの高さを追加することにより、ストリップの高さを出力します </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 参加する </h2><img src="https://habrastorage.org/storage2/2b2/623/44e/2b262344e6bbc840d63c49ba8dd9a9b0.png" align="right"><img src="https://habrastorage.org/storage2/b10/061/14d/b1006114dc8a9af98e3f84f01337abf7.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     どうやら、このアルゴリズムは入力データの特定の性質のために投獄されました。まあ、実際の状況には存在する権利があります。 これで、すべてを自分で理解できるようになります。 通常のように、増加しない高さでソートされた長方形はペアで結合され、ペアの高さの差が指定された分数（通常0〜10％）を超えないようにします。 別の条件は、それらの合計幅がストリップに収まることです。 結果の「スーパー長方形」は、NFDHとFFDHを使用してペアなしで残りと一緒にパックされ、最適なソリューションが選択されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     長方形が幅で並べ替えられ、垂直方向に結合される場合、このアルゴリズムにはバリエーションがあります。これは、ペアの幅の最大偏差が所定のパーセント数だけ同じ条件で行われます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>結合アルゴリズム</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法
        {w（Li）;  h（Li）}、aとしての定数ガンマ
       割合とストリップ幅W
出力：ストリップで得られたパッキングの高さ。
  1：h（L1）≥h（L2）≥...≥h（Ln）のように、高さが増加しない順に長方形をソートします
  2：j = 1
  3：一方、j + 1≤n do
  4：if（h（Lj）-h（Lj + 1））/ h（Lj）* 100 &lt;ガンマ
         そしてw（Lj）+ w（Lj + 1）≤W
  5：w（Lj）+ = w（Lj + 1）
  6：j + = 2
  7：その他
  8：j ++
  9：終了する場合
 10：終了
 11：NFDHおよびFFDHアルゴリズムを実行して、長方形をパックします
 12：最適なソリューションから、元のインスタンスの実行可能なパッキングを構築します
 13：各レベルの高さを追加することにより、ストリップの高さを出力します </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 回転しない床の天井 </h2><img src="https://habrastorage.org/storage2/1da/5ce/4ea/1da5ce4eac61c42fc73927cf5de7e58f.png" align="right"><img src="https://habrastorage.org/storage2/e13/d47/8d2/e13d478d227c9c04a153fb7bf43f57bf.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まだスペースレベルにとどまることに困惑している場合は、このアルゴリズムが最適です。 長方形は高さの増加によってソートされます（予想外に、そうですか？）そして、いくつかの修正を加えたBFDHアルゴリズムが適用されます。 各レベルには「床」と「天井」があります。 可能な限り、長方形は「床」に左から右に詰め込まれます。 場所が終わると、「天井」を右から左に詰め込もうとします。 天井にスペースがない場合は、新しいレベルのみが始まります。  BFDHの最高の伝統では、あらゆる段階で、最初に「床」、次に「天井」のすべてのレベルが最適な場所で表示されます。 ご覧のとおり、パッケージングは​​悪くありません。 このメソッドは、「天井」に最小の長方形を正常にパックします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>FCNRアルゴリズム</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法
        {w（Li）;  h（Li）}およびストリップ幅W
出力：ストリップで得られたパッキングの高さ。
  1：h（L1）≥h（L2）≥...≥h（Ln）のように、高さが増加しない順に長方形をソートします
  2：for i = 1..n do
  3：Liが上限に達した場合
  4：天井にLiを最小限の残余スペースで詰める
  5：その他[Liは上限に達していない]
  6：Liがフロア実現可能であれば
  7：最小の残余スペースで床にリチウムを詰める
  8：その他[Liはフロア実行不可能]
  9：レベル++;
 10：終了する場合
 11：終了する場合
 12：終了
 13：ストリップの高さHを出力します。これは、各レベルの高さを追加することにより求められます </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> スレイター </h2><img src="https://habrastorage.org/storage2/7f0/eec/e90/7f0eece90ebe62fb82699056a47ad1f8.png" align="right"><img src="https://habrastorage.org/storage2/8cc/1c5/909/8cc1c5909af8ea1a945d52e22689ecf3.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     レベルに分割することなく、「フラットな」アルゴリズムの時代が来ました。  Sleatorアルゴリズムは、バックパックをパックするという直感的な原則を使用します。最大のアイテムを下に折り、小さなアイテムで埋めます。 外観は次のとおりです。 長方形から、ストリップの半分よりも幅が広い、幅の広いものが選択され、推測し、左に揃えてランダムに積み重ねられます。 残りのものは、増加しない高さでソートされ、既に配置されているものに向かって左から右に<i>次々</i>に積み重ねられ始めます。 それらの合計幅がストリップの幅の半分を超えるとすぐに、残りのストリップは、「現時点では少ない」という原則に従って、左（ストリップの左端から開始）または右（中央から）に散らばります。 図からわかるように、ボックスよりもこの方法で本を積み重ねる方が便利です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Sleatorアルゴリズム</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法
        {w（Li）;  h（Li）}およびストリップ幅W
出力：ストリップで得られたパッキングの高さ。
  1：Lを長方形で構成される2つのサブリストL1およびL2に分割する
    それぞれ幅が1/2より大きく、最大で1/2の幅。
  2：L1のすべての長方形を左上に揃えて積み重ねます
    ストリップの下部から開始します。  hstackを計算する
  3：パッキングはHstackより上に続きます
  4：増加しない高さに従ってL2の長方形をソートします
     i（n）に対してh（Li）≥h（Li + 1）
  5：HtallをリストL2の最も高い長方形の高さとします。
  6：左から右に左揃えで長方形を詰める
    詰めるスペースが不十分になるまでストリップの端
    長方形またはすべての長方形がパックされている
  7：ストリップを垂直線で2つの等しいセグメントに分割します。
    内部が傍受される可能性のある長方形が1つある可能性があります
    縦線で。
  8：HrightとHleftを右側の長方形の高さとする
     （それぞれ左）左（または右）のエッジを持つストリップの半分
    垂直線に隣接しているか、その内部が遮断されている
    縦線で
  9：展開された長方形がある間に
 10：長さ半分の水平線を描く
      高さがHleftとHrightである長方形
 11：後続の梱包はすべて左側になります
      またはストリップの右セグメント
 12：最小の高さとパックのセグメントを選択します
      ストリップの端から
      すべての長方形が完成するまでの縦線
      パックされているか、収まらない長方形がある
 13：終了
 14：印刷H =最大{Hleft;  Hright} </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> バーク </h2><img src="https://habrastorage.org/storage2/ce4/b90/44c/ce4b9044ca0073eb56a2138b49c6ad34.png" align="right"><img src="https://habrastorage.org/storage2/dfb/19f/0dd/dfb19f0ddb0df35c2d9758197d5811c8.png" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここでも、追加の「高さマップ」が導入されるレベルレスアルゴリズム： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> |  |  |  _ _ ___ |
 |  |  |  |  | _ | _ |  |  |
 |  |  | _ |  |  |  |  |
 | _ _ _ _ _ _ _ _ _ | |  .. | _ | _ | _ | _ _ | _ | _ _ |
  0 0 0 0 0 0 0 0 0 1 0 3 2 3 0 3 3 </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これは、ストリップが塗りつぶされると、最も塗りつぶされていない領域とその幅を追跡できる配列です。 最初はゼロで埋められます。 長方形は、増加しない、突然の幅でソートされます。 次に、アルゴリズムの各ステップで： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1.最低領域の位置が計算されます-配列の最小値のインデックス。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2.最も適切な長方形が選択されます-最初に、この領域に収まり、次に、できるだけ広く塗りつぶされます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3.適切な長方形が見つかった場合、次のいずれかの方法でこの領域に配置されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3.1。エリアの左端。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3.2近隣の1つがストリップのエッジである場合、より高い近隣に近い場合、エッジに近い。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3.3近隣の1つがストリップの端である場合、より低い隣に近く、その後端から遠い。 長方形の幅に対応する配列の値に、その高さが追加されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      4.適切な長方形がない場合、エリアは、その高さを最も近いエッジの高さに揃えることによって「塗りつぶされ」ます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムを使用してテトリスをプレイするボットをすでに作成したいとお考えですか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>バークアルゴリズム</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> 入力：パックする長方形の数n、
       長方形の寸法
        {w（Li）;  h（Li）}およびストリップ幅W
出力：ストリップで得られたパッキングの高さ。
  1：w（Li）≥w（Li + 1）≥..≥W（Ln）のように、増加しない幅に従って長方形をソートします
  2：各配置ポリシーについて
     （左端、最も高い隣人、最も小さい隣人）do
  3：長方形がパックされていない間
  4：最も低いギャップを見つける
  5：w（Li）≤GapWidthの場合
  6：配置ポリシーを使用して最適な四角形を配置する
  7：配列の要素を適切な高さに上げる
  8：その他
  9：最下位の高さまでギャップを上げる
 10：終了する場合
 11：終了
 12：終了
 13：最大のエントリを持つ配列の要素は、パッキングの全体の高さを示します
 14：各配置ポリシーによって取得された総梱包高さを比較し、最適なソリューションを返します </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 誰が良い </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各アルゴリズムの結果は帯域幅のレベルであり、少ないほど良いです。 それに対する最適の比率によって推定できます： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/424/575/303/424575303fa1ddebccc1bd727c74be72.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2セットのソースデータの結果を比較します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><th></th><th> 最適 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     決定 </th><th>  Nfdh </th><th>  Ffdh </th><th>  Bfdh </th><th>  Kp01 </th><th>  SF </th><th> 参加する </th><th>  FCNR </th><th> スレイター </th><th> ブルーク </th></tr><tr><td> セット1 </td><td>  149 </td><td>  0.65 </td><td>  0.71 </td><td>  0.71 </td><td>  0.71 </td><td>  0.75 </td><td>  0.61 </td><td>  <b>0.83</b> </td><td>  0.68 </td><td>  0.72 </td></tr><tr><td> セット2 </td><td>  140 </td><td>  0.66 </td><td>  0.77 </td><td>  0.77 </td><td>  0.78 </td><td>  0.77 </td><td>  0.70 </td><td>  <b>0.84</b> </td><td>  0.51 </td><td>  0.71 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Floor Ceilingアルゴリズムが両方のデータセットで勝ったことがわかります。  Sleatorは最初のセットでより良い結果を示し、反対にJoinは2番目のセットにより適していることに注意してください。 しかし、これはすべて統計に過ぎません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> エピローグ </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     簡単な定式化により、バイナリパッケージングのタスクは、オブジェクトの直接的な梱包や材料の切断、資金の割り当て、クラスターでのタスクの計画など、膨大な数の実用的なアプリケーションに適用できます。 人生には洗練された問題はほとんどありませんが、いくつかの条件が限られているため、状況を多項式時間で達成できる優れたソリューションを備えた美しい数学モデルに減らすことができます。 そして、一度、バタフライ効果の結果として、破棄された条件はかなりの重量を要し、決定はすべての無名の人に渡ります。 世界が不完全であるのはそのような仮定のためです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     気が散ったもの。 次の部分では、タスクのオンラインバージョンとオフショアアルゴリズムについてお話したいと思います。 頑張って！ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <hr>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     インスピレーションの源： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Nthabiseng Ntene <a href="http%253A%252F%252Fdip.sun.ac.za%252F~vuuren%252FTheses%252FNtene.pdf%26ei%3DeSGvUJ7cGMPm4QTo44CQCw%26usg%3DAFQjCNGNiUY9a_tGxmJ0C5Xha58Brn2gaw">2D指向ストリップパッキング問題へのアルゴリズム的アプローチ</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     デビッド・ピシンガー<a href="http://www.diku.dk/users/pisinger/95-1.pdf">ナップザックの問題</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://cgi.csc.liv.ac.uk/~epa/surveyhtml.html">二次元パッキングに関する調査</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://users.cs.cf.ac.uk/C.L.Mumford/heidi/Approaches.html">レベルアルゴリズムとシェルフアルゴリズム</a> （注意、涙目設計） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     コード（Qt）： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズム<a href="http://pastebin.com/XtdEHAR6">packager.h</a> <a href="http://pastebin.com/eGXRZ65c">packager.cpp</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Gui <a href="http://pastebin.com/iqFU7Qg2">window.h</a> <a href="http://pastebin.com/qWk7q7EX">window.cpp</a> <a href="http://pastebin.com/4m2DW4S0">renderarea.h</a> <a href="http://pastebin.com/s0QkUeq5">renderarea.cpp</a> <a href="http://pastebin.com/LMpUBUEj">main.cpp</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      UPD： <a href="http://habrahabr.ru/post/160869/">オンラインアルゴリズム</a> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J13622/index.html">Gmailの最終的なバイラルコマーシャルの準備ができました</a></li>
<li><a href="../J136220/index.html">25ドルのRaspberry Piコンピューターの最初のバッチが実稼働に入りました</a></li>
<li><a href="../J136221/index.html">プレイステーション4は6月には発表されません</a></li>
<li><a href="../J136222/index.html">ガイド：人々のためのピラミッド-パート2</a></li>
<li><a href="../J136224/index.html">カメラ付きのキャタピラーBluetoothロボットを構築しています。 パート3</a></li>
<li><a href="../J136227/index.html">ファジー推論ルールを使用した選択肢の多基準選択。 Java実装。 パート3/3：例</a></li>
<li><a href="../J136228/index.html">テーブルをソートするためのJQueryプラグイン：TableSorter.js。 ページナビゲーションを実現する方法</a></li>
<li><a href="../J13623/index.html">さあ始めましょう！</a></li>
<li><a href="../J136232/index.html">アンチウイルスの機能について。 パート1</a></li>
<li><a href="../J136234/index.html">内観：私たちの周りの世界</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>