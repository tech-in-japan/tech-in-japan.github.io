<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏻 🔐 👩🏿‍🍳 単体テストの定義 🛑 🏰 👩🏿‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近、インターネットでTDDが現在生きているかどうか、それが必要かどうか、どのような形であるかについて深刻な騒動があります。 それはすべて、David Hanson の記事「TDDは死んでいます。 その後、多くの著者による記事と、David、Kent Beck、Martin Fowlerとのハングア...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>単体テストの定義</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> 最近、インターネットでTDDが現在生きているかどうか、それが必要かどうか、どのような形であるかについて深刻な騒動があります。 それはすべて、David Hanson <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">の</a>記事<a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">「TDDは死んでいます。</a> その後、多くの著者による記事と、David、Kent Beck、Martin Fowlerとの<a href="http://martinfowler.com/snips/201405071053.html">ハングアウト</a>など、この問題に関する活発な議論が行われました（ところで、次のハングアウトは明日、5月16日です）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、同じMartin Fowlerがユニットテスト（ <a href="http://martinfowler.com/bliki/UnitTest.html">bliki：UnitTest</a> ）の定義を試みた数日前に、その翻訳を以下に示します。 そして翻訳後、この主題についての私の考えがいくつかあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ソフトウェア開発の世界では、彼らはユニットテストについてよく話します。私はプログラマーとしてのキャリアを通してこの概念に精通しています。 しかし、ソフトウェア開発の世界の他の多くの用語と同様に、この用語は非常に不十分に定義されており、開発者が実際よりも厳密な定義を持っていると考えると混乱することがよくあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/808/32f/129/80832f129728dcca7a6c8909a70e44e4.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ユニットテストを頻繁に使用していましたが、最終的なコミットメントは、Kent Beckとテストツールの<a href="http://martinfowler.com/bliki/Xunit.html">xUnit</a>ファミリの使用を開始したときに始まりました。  （時々、「xunitテスト」という用語がこのタイプのテストにより適しているようにさえ思えます。）ユニットテストは、 <a href="http://martinfowler.com/bliki/ExtremeProgramming.html">エクストリームプログラミング</a> （XP）でも重要なアクティビティになり、 <a href="http://martinfowler.com/bliki/TestDrivenDevelopment.html">テストを通じて</a>迅速に開発され<a href="http://martinfowler.com/bliki/TestDrivenDevelopment.html">ました</a> （TDD-テスト駆動開発）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      XPでの最初からの単体テストの役割は、いくつかの懸念を引き起こしました。  usenetグループでのテストの専門家が、「ユニットテスト」という用語の誤用でXPの支持者をscった議論をはっきりと覚えています。 私たちは彼の定義を求めましたが、彼は次のように答えました。「私のテストコースの最初に、ユニットテストの24の異なる定義を検討します。」 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     意見の相違にもかかわらず、いくつかの側面で私たちの視点は収束しました。 第一に、単体テストは低レベルであり、ソフトウェアシステムのごく一部のみに焦点を合わせるという考え方があります。 第二に、今日の単体テストは通常​​、開発者が通常のツールを使用して作成され、それにテストフレームワーク（*）が追加されます。 第三に、単体テストは他のタイプのテストよりも大幅に高速になると予想されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、見解には違いがありました。  <i>モジュール</i>と考えられるものには異なる視点があり<i>ます</i> 。 オブジェクト指向設計では、モジュールはクラスと見なされます;手続き的および機能的なアプローチでは、関数はモジュールと見なされます。 実際、これは状況に応じた概念です。チームは、システムを理解したりテストしたりするためのモジュールとして考慮すべきものを決定します。 また、クラスはモジュールであるという考えから始めますが、よく密接に関連するクラスのセットを単一のモジュールと見なし始めます。 あまり一般的ではありませんが、クラスメソッドのサブセットをモジュールと見なすことができます。 実際、この概念をどのように定義するかは重要ではありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 分離 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アプローチのより重要な違いは、テスト中のモジュールを相互作用するオブジェクトから分離する必要があるという質問です。 注文クラスの価格計算方法をテストしているとします。 価格設定メソッドは、製品および顧客クラスのいくつかのメソッドを呼び出します。 相互作用するオブジェクトの分離の原則に従う場合、顧客のクラスのエラーは注文のクラスのテストの低下につながるため、ここでは実際の製品と顧客のクラスを使用したくないでしょう。 代わりに、相互作用するすべてのオブジェクトに<a href="http://martinfowler.com/bliki/TestDouble.html">テストダブルを</a>使用します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e93/885/30a/e9388530a4f4ff988a3e65bb563286b5.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、すべての開発者が分離を使用するわけではありません。 実際、90年代にxunitテストが開始されたとき、他のオブジェクトとの通信が非常に不便でない限り（リモートクレジットカード検証システムとのやり取りなど）、テストされたクラスを分離しようとしませんでした。 隣接するテストが失敗した場合でも、失敗の本当の原因を理解するのに困難はありませんでした。 したがって、実用的な観点から、孤立の欠如を問題とは考えませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     彼の批判の理由は、まさに「ユニットテスト」の定義における孤立性の欠如でしたが。 単一モジュールの動作をテストするため、「ユニットテスト」の定義が適切だと思います。 このモジュール以外のすべてが正常に動作することを前提に、テストを作成しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2000年代にhunitテストが人気を博し始めたとき、少なくとも一部の人々にとって、孤立の概念は再び活気を取り戻しました。 モックをサポートするモックオブジェクトとフレームワークの出現を見てきました。 その結果、xunitテスターの学校が2つあり、それら<a href="http://martinfowler.com/articles/mocksArentStubs.html">を古典派と模擬学派と呼びます</a> 。  Moqistsのように、古典派の信奉者は孤立を気にしません。 私は両方の学校のhunitテスターを知っており、尊敬しています（ただし、私は自分で古典派に所属しています）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     複雑な相互作用の存在下で、古典派の代表者（私を含む）でさえ、偽物を使用します（テストダブル）。 偽物は<a href="http://martinfowler.com/articles/nonDeterminism.html">、リモートサービスを操作するときの動作</a>の<a href="http://martinfowler.com/articles/nonDeterminism.html">不確実性</a>を排除するために非常に貴重です。 古典派の一部の代表者は、データベースやファイルシステムなどの外部リソースとのやり取りには偽物を使用する必要があると考えています。 一部はこの意見は不確実な行動のリスク、一部は速度の問題に基づいています。 これは有用な推奨事項だと思いますが、絶対的なルールとは思いません。 リソースへのアクセスが安定しており、十分に高速であれば、単体テストから使用できない理由はありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> スピード </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     単体テストには、いくつかの共通のプロパティがあります。小さなスコープ、開発者によって作成され、迅速に実行されます。これにより、開発中に頻繁に実行できます。 実際、これは<a href="http://martinfowler.com/bliki/SelfTestingCode.html">セルフテストコードの</a>重要な機能の1つです。 この場合、プログラマーはコードの変更後にユニットテストを実行できます。 コードをコンパイルする必要があるたびに、ユニットテストを1分間に数回実行できます。 これは、誤って何かを壊してしまった場合、すぐに知りたいので便利です。 最新の変更で何かを壊した場合、このエラーをすぐに見つける方がはるかに簡単です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>翻訳者の</b> <b>メモ</b> <b>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </b>  Kent Beckは、コンパイル中に（場合によってはテストなしで）テストを実行するというアイデアを開発し、連続テスト（Continuous Testing）のアイデアを提案しました。 そのようなツールの例： <a href="http://www.continuoustests.com/">Mighty-Moose</a>および<a href="http://www.ncrunch.net/">NCrunch</a> for .NET、 <a href="http://www.junitmax.com/">JUnit Max</a> for Java。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     テストを頻繁に実行する場合、すべてを実行することはできません。 通常、現在作業中のコードで動作するテストのみを実行する必要があります。 この場合、テストの実行期間のために、テストの深さを犠牲にします。 このテストスイートを「コンパイルスイート」と呼びます。これは、Rubyのようなインタープリタ言語でも、コンパイルするたびに実行するためです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     継続的インテグレーションを使用する場合、ステップの1つとしてテストを実行する必要があります。 私がコミットスイートと呼ぶこのテストスイートには、すべての単体テストが含まれている必要があります。 また、いくつかの受け入れテスト（ <a href="http://martinfowler.com/bliki/BroadStackTest.html">Broad-StackテストまたはEnd-to-Endテスト</a> ）が含まれることもあります。 開発者として、このテストスイートを1日に数回実行する必要があります。もちろん、バージョン管理システムへの変更をコミットする前に、またそのような機会があれば、休憩中または集会中に実行する必要があります。 一連のコミットテストが速く実行されるほど、実行できる頻度が高くなります（**）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ユニットテストとそのセットの実行速度については、人によって基準が異なります。 したがって、 <a href="http://david.heinemeierhansson.com/2014/slow-database-test-fallacy.html">David Heinemeier Hansson</a>にとっては、コンパイルスイートを数秒間<a href="http://david.heinemeierhansson.com/2014/slow-database-test-fallacy.html">実行し</a> 、コミットスイートを数分間<a href="http://david.heinemeierhansson.com/2014/slow-database-test-fallacy.html">実行</a>するだけで十分です。  <a href="https://www.destroyallsoftware.com/blog/2014/tdd-straw-men-and-rhetoric">Gary Bernhardt</a>はこれが遅すぎると見なし、コンパイルセットが約300ミリ秒実行されると主張し、 <a href="http://dan.bodar.com/2012/02/28/crazy-fast-build-times-or-when-10-seconds-starts-to-make-you-nervous/">Dan Bodart</a>はコミットセットが数秒以上完了するのを待ちたくありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この質問に対する唯一の正しい答えがあるとは思いません。 個人的には、コンパイルセットが1秒または2、3秒で実行されたときに違いは見られませんでした。 私は、コミットセットを10分以上実行しないというKent Beckの規則が気に入っています。 ここでの主なアイデアは、テストスイートを十分な頻度で実行することを妨げないように、テストスイートを十分に高速で実行することです。 また、「十分な」とは、テストでバグが見つかったときに、少量のコードを掘り当てて、かなり迅速に見つける必要があることを意味します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 注釈 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      （*）私は「今日」と言います。これはXPのおかげで正確に変わったからです。 新世紀の始まりをめぐる議論の中で、XPの支持者は、一般的に受け入れられている観点はプログラマが自分のコードをテストするべきではないということであるため、非常に批判されてきました。 一部の企業では、開発者コードの単体テストを作成することが唯一のタスクである専門の単体テスターがいました。 この観点の理由は次のとおりです。人々はコードをテストするときに「概念的な盲目」を持っています。 プログラマーは貧弱なテスターなので、プログラマーとテスターの間に何らかの形で対立することは有用です。  XPサポーターの観点は、プログラマーが少なくとも個別の「モジュール」のレベルで優秀なテスターに​​なることを学ぶことができ、テストを作成するために追加のグループを関与させると、テストによって提供されるフィードバックが非常に遅くなるということでした。  XUnitツールは、テスト作成のオーバーヘッドを最小限に抑えるために特別に開発されたため、この点で非常に重要な役割を果たしました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      （**）実行時間がコミットテストの期間よりも長い有用なテストがある場合、 <a href="http://martinfowler.com/bliki/DeploymentPipeline.html">展開パイプライン</a>を構築し、これらのテストをパイプラインの後半のステージに<a href="http://martinfowler.com/bliki/DeploymentPipeline.html">配置</a>する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事では、マーティンはコードとテストの作成の問題に意図的に対処せず、代わりに単体テストの定義を提供し、モジュールの概念に関するさまざまな視点の存在を、分離と実行の速度の必要性について示しようとします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私自身は、ユニットテストが他の世界から完全に隔離されたクラスをテストするべきだという意見に出くわしました。 たとえば、ロバート・マーティンが著書<a href="http://sergeyteplyakov.blogspot.co.uk/2013/04/blog-post.html">「Principles、Patterns、and Agile Development Techniques」で</a>説明しているのはこのアプローチ<a href="http://sergeyteplyakov.blogspot.co.uk/2013/04/blog-post.html">であり、「依存関係逆転の原理に関する批判的な見方」</a>という記事でそれを批判しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私の理解では、動作が決定論的で高速であれば、単体テストで特定のクラスを使用してもまったく問題はありません。 不要な依存関係を強調すると、クラスのカプセル化が損なわれ、その結果、システムの理解と保守が容易になりません。 安定した依存関係はすべて直接使用でき、使用する必要があります。また、動作が決定的ではない<a href="http://sergeyteplyakov.blogspot.co.uk/2012/11/blog-post.html">「可変」依存関係</a>のみを区別する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私はユニットテストの古典派のサポーターであり、非決定的な外部リソースにアクセスしない場合、実際のクラスを使用する必要があると思います。  <b>私の理解におけるmokaの豊富さの問題は、受け取ったテストがテスト環境に依存しすぎてテスト環境が脆弱になり、インターフェースと間接性の豊富さがシステムの「理解しやすさ」を悪化させ、99％のケースでは必要ない柔軟性を追加すること</b>です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     もちろん、mokaの使用に関する他の観点もあります。 したがって、スティーブ・フリーマンとナット・プライスの著書<a href="http://sergeyteplyakov.blogspot.co.uk/2014/04/about-development-testing.html">「Growing Object-Oriented Software Guided by Tests」では</a> 、別の視点が取られています。 ただし、同時に、テストのダウンタイムを注意深く監視し、テストの各行にmoqの5行の初期化が来る状況を許可しません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2つのキャンプのいずれかに固執することは絶対に普通です：クラシックまたはモッキスト。 主なものは、あなたの選択が意識的であり、あなたのテストが開発と保守を簡素化し、これを妨げないことです。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J222945/index.html">市民記者向けの超カスタムモバイルアプリケーションであるSpetskorの開発方法</a></li>
<li><a href="../J222951/index.html">Yandex.MailチームとNginxチームの共同実験：SPDYは本当にインターネットを高速化するのでしょうか？</a></li>
<li><a href="../J222953/index.html">エンジニアリング調査の経験</a></li>
<li><a href="../J222957/index.html">Goでプログラムを高速化する方法</a></li>
<li><a href="../J222959/index.html">宇宙の進化の正確なビデオモデル：Illustris（+銀河の誕生と宇宙の終わりのモデル）</a></li>
<li><a href="../J222975/index.html">他の誰かのXENホスティングからKVMに仮想マシンを転送した経験</a></li>
<li><a href="../J222977/index.html">SpoonとEmmaを使用したAndroidアプリケーションのテストに関するレポートの作成</a></li>
<li><a href="../J222979/index.html">C＃での別のパターンマッチング</a></li>
<li><a href="../J222983/index.html">フラスコメガチュートリアル、パート5：ユーザーログイン</a></li>
<li><a href="../J222985/index.html">IBM System / 360-フェールオーバーストーリー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>