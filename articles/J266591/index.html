<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏔️ 🧑🏿‍🤝‍🧑🏽 🖐️ セキュリティホールの仕組み：バッファオーバーフロー 🕵🏽 🤽 😝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ご注意 トランスレータ： これは、Peter Brightの記事「セキュリティの欠陥の仕組み：バッファオーバーフロー」の翻訳です。バッファオーバーフローの仕組みと、脆弱性と保護方法の開発方法についてです 。 
  
  
  
 1988年のMorris Wormから、この問題はLinuxとWind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>セキュリティホールの仕組み：バッファオーバーフロー</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/266591/"><blockquote> ご注意 トランスレータ： <i>これは、Peter Brightの記事「セキュリティの欠陥の仕組み：バッファオーバーフロー」の翻訳です。バッファオーバーフローの仕組みと、脆弱性と保護方法の開発方法についてです</i> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>1988年のMorris Wormから、この問題はLinuxとWindowsの両方に影響を与えました。</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img height="360" width="700" src="https://habrastorage.org/files/dcc/15c/1ae/dcc15c1ae6ab4ee59267a2eec8fc10c7.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     バッファオーバーフローは、コンピュータセキュリティの分野で長い間知られています。 最初の自己増殖インターネットワームである1988 Morris Wormでさえ、フィンガーUnixデーモンのバッファオーバーフローを使用してマシン間で拡散しました。  27年後、バッファオーバーフローは依然として問題の原因です。  Windows開発者は、2000年代の初めに2つのエクスプロイトベースのバッファオーバーフローが発生した後、セキュリティへのアプローチを変更しました。 また、 <a href="http://arstechnica.com/security/2015/05/90s-style-security-flaw-puts-millions-of-routers-at-risk/">今年5月に</a> （潜在的に）発見されたLinuxドライバーのバッファーオーバーフローにより、数百万のホームルーターおよびSMBルーターが攻撃にさらされています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     本質的に、バッファオーバーフローは、一般的な慣行に起因する非常に単純なバグです。 コンピュータプログラムは、多くの場合、ディスク、ネットワーク、またはキーボードから読み取られたデータのブロックで動作します。 このデータを割り当てるために、プログラムは有限サイズのメモリブロック-バッファを割り当てます。 バッファのオーバーフローは、バッファが保持できるよりも大きいデータボリュームを読み書きするときに発生します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     表面的には、それは非常に愚かな間違いのように見えます。 最終的に、プログラムはバッファのサイズを認識します。つまり、プログラムがバッファに既知のサイズを超えて配置しようとしないことを簡単に確認できるはずです。 そして、あなたはこのように推論するのが正しいでしょう。 ただし、バッファオーバーフローは引き続き発生し、その結果は多くの場合、セキュリティ上の障害となります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     バッファオーバーフローが発生する理由と、結果が非​​常に悲惨な理由を理解するには、プログラムがメモリを使用する方法とプログラマがコードを記述する方法を考慮する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      （著者のメモ：スタックバッファオーバーフローを主に考慮します。これは、オーバーフローの唯一のタイプではありませんが、古典的で最も研究されているタイプです） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> スタック </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     バッファオーバーフローは、ネイティブコードでのみ問題を引き起こします。  JavaやPythonなどの仲介なしで、一連のプロセッサ命令を直接使用するプログラムで。 オーバーフローは、ネイティブコードのプロセッサとプログラムがメモリを管理する方法に関連しています。 異なるオペレーティングシステムには独自の特性がありますが、最新の一般的なプラットフォームはすべて一般的な規則に従います。 攻撃がどのように機能し、どのように対抗するかを理解するために、最初にメモリ使用量を少し見てみましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最も重要な概念は、メモリ内のアドレスです。 メモリの各バイトには、対応する数値アドレスがあります。 プロセッサは、メインメモリ（RAM、RAM）に対してデータの読み取りまたは書き込みを行うとき、読み取りが行われた場所または書き込みが行われた場所のメモリアドレスを使用します。 システムメモリはデータに使用されるだけではありません。 また、プログラムを構成する実行可能コードをホストするためにも使用されます。 つまり、実行中のプログラムの各機能にもアドレスがあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     当初、プロセッサとオペレーティングシステムは物理メモリアドレスを使用していました。各メモリアドレスは、特定のRAMのアドレスに直接関連付けられていました。 最新のオペレーティングシステムの一部ではまだ物理アドレスが使用されていますが、最新のオペレーティングシステムはすべて仮想メモリと呼ばれるスキームを使用しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     仮想メモリを使用する場合、メモリアドレスと物理RAM部分の直接的な対応はありません。 代わりに、プログラムとプロセッサは仮想アドレス空間で動作します。 オペレーティングシステムとプロセッサは、仮想メモリアドレスと物理メモリアドレス間のマッピングを共同でサポートします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この仮想化により、いくつかの重要な機能を使用できます。 最初で最も重要なのは、 <i>保護されたメモリ</i>です。 個々のプロセスはそれぞれ<i>独自</i>のアドレス<i>の</i>セットを受け取ります。  32ビットプロセスの場合、アドレスはゼロ（最初のバイト）から始まり、4,294,967,295（16進数では0xffff'ffff; 2 ^ 32-1）までになります。  64ビットプロセスの場合、アドレスは18,446,744,073,709,551,615（0xffff'ffff'ffff'ffff、2 ^ 64-1）まで続きます。 したがって、各プロセスには独自のアドレス0があり、その後にアドレス1、アドレス2などが続きます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      （著者のメモ：この記事の残りの部分では、特に明記しない限り、32ビットシステムについて説明します。この側面では、32ビットと64ビットの違いは重要ではありません。明確にするために、1ビットを厳守します） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各プロセスは独自のアドレスセットを受け取るので、このスキームは、あるプロセスから別のプロセスへのメモリ破損を防ぐ簡単な方法です。プロセスがアクセスできるすべてのアドレスは、そのプロセスのみに属します。 これは、プロセス自体にとってはるかに簡単です。 物理メモリアドレスは、広い意味では機能しますが（これらはゼロから始まる数字です）、使用するのに多少不便な機能があります。 たとえば、通常は非連続です。 たとえば、アドレス0x1ff8'0000は<a href="https://ru.wikipedia.org/wiki/System_Management_Mode">、</a>プロセッサの<a href="https://ru.wikipedia.org/wiki/System_Management_Mode">システム制御モードの</a>メモリに使用され<a href="https://ru.wikipedia.org/wiki/System_Management_Mode">ます。これは、</a>通常のプログラムではアクセスできない小さなメモリです。  PCIeカードのメモリもこのスペースにあります。 仮想メモリアドレスでは、このような不便はありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プロセスのアドレス空間には何がありますか？ 一般的に、4つの共通オブジェクトがあり、そのうちの3つが興味を持っています。 ほとんどのオペレーティングシステムで私たちにとって興味のないブロックは、「オペレーティングシステムの中核」です。 パフォーマンスのために、アドレス空間は通常2つの半分に分割され、その下半分はプログラムによって使用され、上半分はカーネルのアドレス空間によって占有されます。 カーネルに与えられた半分は、プログラムが占有している半分からは利用できませんが、カーネル自体はプログラムメモリを読み取ることができます。 これは、カーネル関数にデータを渡す1つの方法です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、実行可能部分とプログラムを構成するライブラリを扱います。 メインの実行可能ファイルとそのすべてのライブラリはプロセスのアドレス空間にロードされ、それらを構成するすべての関数はメモリ内にアドレスを持ちます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プログラムが使用するメモリの2番目の部分は、処理されたデータを格納するために使用され、通常<a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_%2528%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C%2529">はヒープ</a>と呼ばれ<a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_%2528%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C%2529">ます</a> 。 たとえば、この領域は、編集されたドキュメント、表示されたWebページ（すべてのJavaScritオブジェクト、CSSなどを含む）、またはプレイされているゲームのマップを格納するために使用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3番目の最も重要な部分は呼び出しスタックであり、通常は単にスタックと呼ばれます。 これが最も難しい側面です。 プロセス内の各スレッドには独自のスタックがあります。 これは、ストリームで実行可能な現在の関数と以前のすべての関数（現在の関数に入るために呼び出された関数）の両方を同時に追跡するために使用されるメモリ領域です。 たとえば、関数<i>a</i>が関数<i>bを</i>呼び出し、関数<i>b</i>が関数<i>cを</i>呼び出す場合、スタックには<i>a</i> 、 <i>b、</i>および<i>c</i>に関する情報がこの順序で含まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     呼び出しスタックは、「スタック」と呼ばれるデータ構造の特殊バージョンです。 スタックは、オブジェクトを格納するための可変長構造です。 新しいオブジェクトをスタックの最後（通常、スタックの「トップ」と呼ばれる）にプッシュし、スタックからオブジェクトをポップできます。 スタックの最上部のみがプッシュとポップを使用して変更されるため、スタックは厳密なソート順を確立します。スタックに最後に配置されたオブジェクトが次にスタックから削除されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     呼び出しスタックに保存される最も重要なオブジェクトは、リターンアドレスです。 ほとんどの場合、プログラムが関数を呼び出すと、この関数は必要な処理（他の関数の呼び出しを含む）を実行し、呼び出した関数に制御を返します。 呼び出し関数に戻るには、その関数に関するレコードを保存する必要があります。呼び出し命令に続く命令で実行を継続する必要があります。 この命令のアドレスは、リターンアドレスと呼ばれます。 スタックは、これらのリターンアドレスを格納するために使用されます。関数が呼び出されるたびに、リターンアドレスがスタックに配置されます。 各リターンで、アドレスはスタックから削除され、プロセッサはこのアドレスで命令の実行を開始します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタック機能は非常に基本的で必要なため、すべてではないにしても、ほとんどのプロセッサにこれらの概念のサポートが組み込まれています。 例としてx86プロセッサを取り上げます。  x86仕様で定義されているレジスタ（命令にアクセス可能なプロセッサのメモリの小さな領域）のうち、最も重要な2つは<i>eip</i> （命令ポインタ）と<i>esp</i> （スタックポインタ）です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ESPには常にスタックの最上位のアドレスが含まれます。 何かがスタックにプッシュされるたびに、esp値は減少します。 スタックから何かが削除されるたびに、esp値が増加します。 これは、スタックが「ダウン」していることを意味します。 オブジェクトがスタックに追加されると、espに保存されるアドレスはますます小さくなります。 それにもかかわらず、espが指すメモリ領域は「スタックのトップ」と呼ばれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><table><tbody><tr><td> <a href=""><img src="https://habrastorage.org/files/293/bf7/d92/293bf7d927b640108c58d69b6ed007a0.png" width="300"></a> </td><td> ここでは、 <i>name</i>という<i>名前の</i> 64文字のバッファーを使用したスタックの単純なスキャンに続いて、フレームポインター、リターンアドレスが表示されています。  <i>esp</i>レジスタには頂点のアドレスが含まれ、 <i>ebp</i>にはフレームポインターのアドレスが含まれます。 </td></tr></tbody></table></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      EIPには、現在の命令のアドレスが含まれます。 プロセッサは、独自にeip値をサポートします。 メモリから命令ストリームを読み取り、それに応じてeip値を変更するため、常に命令のアドレスが含まれます。  x86内には、関数<i>call</i>を呼び出すための命令<i>と</i> 、 <i>-ret</i>を返すための命令があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      CALLは、呼び出される関数のアドレスという1つのオペランドを受け入れます（ただし、渡す方法はいくつかあります）。 呼び出しが行われると、espスタックポインターが4バイト（32ビット）減り、呼び出しに続く命令アドレス（戻りアドレス）がespが指すメモリ領域に配置されます。 つまり、リターンアドレスがスタックにプッシュされます。 次に、eip値が呼び出しオペランドとして渡されたアドレスと等しく設定され、この時点から実行が継続されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      RETは逆の操作を実行します。  Simple retはオペランドを受け入れません。 プロセッサは最初にespに格納されているメモリアドレスの値を読み取り、次にespを4バイト増やします-スタックから戻りアドレスを削除します。 値はeipに配置され、実行はこのアドレスから継続されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  （翻訳者注：著者のテキストのこの時点で、 <a href="https://thescene.com/watch/arstechnica/how-the-stack-works-part-1">呼び出しと再試行を示すビデオ</a>があります<a href="https://thescene.com/watch/arstechnica/how-the-stack-works-part-1">。</a> ） </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>呼び出しスタックが戻りアドレスのセット<i>のみを</i>保持している場合、問題はありません</b> 。 本当の問題は、スタックにプッシュされる他のすべてのものにあります。 スタックは、データを保存するための高速で効率的な場所であることがわかりました。 ヒープにデータを保存することは比較的困難です。プログラムは、ヒープで使用可能なスペース、各オブジェクトが占める量などを追跡する必要があります。 同時に、スタックの操作は簡単です。小さなデータを配置するには、ポインターの値を単純に減らすだけで十分です。 そして、自分でクリーンアップするには、ポインタの値を増やすだけです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この利便性により、スタックは、関数で使用される変数を配置する論理的な場所になります。 関数はユーザー入力を受け入れるために256バイトのバッファーを必要としますか？ 簡単です。スタックポインタから256を引くだけで、バッファの準備が整います。 関数の最後で、ポインタに256を追加するだけで、バッファは破棄されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ただし、このアプローチには制限があります。 スタックは、非常に大きなオブジェクトの保存には適していません。使用可能なメモリの総量は、通常、ストリームの作成時に固定され、多くの場合、ボリュームが約1MBです。 したがって、大きなオブジェクト<i>は</i>ヒープに配置する<i>必要</i>があります。 スタックは、呼び出された関数が実行されるよりも長く存在する必要があるオブジェクトにも適用できません。 関数が終了するとスタック上のすべての割り当てが削除されるため、スタック上のオブジェクトの寿命は対応する関数の実行時間を超えません。 ヒープ上のオブジェクトの場合、この制限は適用されず、永久に存在する可能性があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><table><tbody><tr><td> <a href=""><img src="https://habrastorage.org/files/a71/2c9/6ba/a712c96ba696486fb390aba2325d1362.png" width="300"></a> </td><td> プログラムを正しく使用すると、キーボード入力は<i>名前</i>バッファに格納され、nullのゼロバイトで閉じられます。 フレームポインターと戻りアドレスは変更されません。 </td></tr></tbody></table></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタックストレージは、プログラマが明示的に定義した変数だけでなく、使用されます。 スタックは、プログラムで必要な値を格納するためにも使用されます。 これは、x86で特に深刻です。  X86ベースのプロセッサは、多数のレジスタで違いはありません（合計8個の整数レジスタがあり、既に言及したeipやespのように、それらの一部は既に使用されています）。 レジスターのスペースを解放するために、後で使用するために値を保持しながら、コンパイラーはレジスターの値をスタックにプッシュします。 後でレジスタから値を削除して、レジスタに戻すことができます。 コンパイラーの専門用語では、レジスターを保管して、後で使用する可能性のあるプロセスを<i>スピル</i>と呼びます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後に、スタックは関数に引数を渡すためによく使用されます。 呼び出し側の関数は、各引数をスタックにプッシュします。 呼び出された関数はそれらをスタックから削除できます。 これは引数を渡す唯一の方法ではありません-たとえば、レジ​​スタを使用できます-しかし、最も柔軟な方法の1つです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタック上の関数によって格納されるオブジェクトのセット—独自の変数、格納されたレジスタ、他の関数への送信のために準備された引数—は、「ネストされたフレーム」と呼ばれます。 接続されたフレームのデータは積極的に使用されるため、単純にアドレス指定する方法があると便利です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタックポインターを使用して<i>これ</i>を<i>実装する</i>ことは<i>可能</i>ですが、多少不便です。スタックポインターは常に最上部を指し、オブジェクトの配置と削除に応じて値が変化します。 たとえば、変数は最初に位置esp + 4に配置されます。 さらに2つの値がスタックに配置された後、変数はesp + 12に配置され始めました。 スタックから値の1つを削除すると、変数はesp + 8になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     説明されていることは不可能な作業ではなく、コンパイラーはそれに対処することができます。 ただし、これにより、特にアセンブラーを手動で記述する場合に、スタックポインターを使用して頂点の「ダム」以外にアクセスできます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     タスクを簡素化するために、各フレームの「ボトム」アドレス（つまり、先頭）を格納する2番目のポインター（フレームポインターと呼ばれる値）を保持するのが一般的です。 また、x86には、通常<i>ebpに</i>使用されるレジスタもあります。 その値は常に関数内にあるため、関数変数を明確にアドレスする方法があります。ebp-4の値は、関数の存続期間を通してebp-4で利用可能なままです。 そして、これは人々だけでなく、デバッガーが何が起こっているかを把握するのが簡単です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote> <a href=""><img src="https://habrastorage.org/files/ff1/6b1/89b/ff16b189beaf44f590923bf6f0fc0f57.png"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Visual Studioのスクリーンショットは、例として単純なx86プログラムを使用して、これらすべての動作を示しています。  x86プロセッサでは、 <i>esp</i>レジスタにはスタックの最上部のアドレスが含まれ、この場合は<u>0x0019fee0</u> （青で強調表示）です。  （ <i>著者の注記：x86プラットフォームでは、スタックはメモリアドレス0の方向に成長しますが、このポイントは「スタックのトップ」という名前を保持します</i> ）。 表示される関数は、スタック上でピンク色で強調表示された変数<i>名</i>のみを保存します。 これは、長さが64バイトの固定バッファーです。 これは唯一の変数であるため、そのアドレスも<u>0x0019fee0</u>であり、スタックの最上部と同じです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      X86には、赤で強調表示された<i>ebp</i>レジスタもあり、これは（通常）フレームポインタを格納するために割り当てられます。 フレームポインターは、スタック変数の直後にあります。 フレームポインターのすぐ後ろに、緑色で強調表示された戻りアドレスがあります。 リターンアドレスは、 <u>0x00401048</u>のコードを<u>参照し</u>ます。 この命令は呼び出しの直後に続き、プログラムが呼び出し関数を離れた場所で実行を継続するために戻りアドレスがどのように使用されるかを示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     上の図のNAMEは、定期的にオーバーフローするバッファの種類を具体的に示しています。 サイズは64バイトに固定されています。 この場合、数字のセットで埋められ、ゼロで終わります。 この図は、ネームバッファに64バイト以上が書き込まれると、スタック内の他の値が破損することを示しています。 さらに4バイトを書き込むと、フレームポインターは破棄されます。 さらに8バイトを書き込むと、フレームポインターと戻りアドレスが上書きされます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     明らかに、これはデータの破損につながりますが、バッファオーバーフローの問題はより深刻です。[任意の]コードの実行につながります。 これは、バッファオーバーフローがデータを上書きするだけではないためです。 スタックに格納されているより重要なもの（返信先アドレス）も上書きされる場合があります。 リターンアドレスは、現在の関数が終了したときにプロセッサが実行する命令を制御します。 これは呼び出し関数内のある種のアドレスであると想定されていますが、この値がバッファオーバーフローによって上書きされた場合、どこでも指すことができます。 攻撃者がバッファオーバーフローを制御できる場合、リターンアドレスを制御できます。 戻りアドレスを制御する場合、次に何をすべきかをプロセッサに伝えることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ほとんどの場合、プロセッサには、攻撃者が起動する「マシンを妥協する」美しい便利な機能はありませんが、これはそれほど重要ではありません。 リターンアドレスを変更するために使用されるのと同じバッファーを使用して、実行可能なコード（シェルコード、シェルコード）の小さな断片を保存し、悪意のある実行可能ファイルをダウンロードするか、ネットワーク接続を開くか、攻撃者の他の希望を満たすことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     従来、これを行うのは簡単でした。多くの人が驚いた理由からです。通常、マシンを再起動しても、すべてのプログラムは起動するたびにメモリ内の同じアドレスを使用します。 これは、スタック上のバ​​ッファの位置が毎回同じになるため、戻りアドレスを歪めるために使用される値が毎回同じになることを意味します。 攻撃者はこのアドレスを1回見つけるだけでよく、攻撃は脆弱なコードを実行する<i>すべての</i>コンピューターで機能します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 攻撃者ツールキット </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     理想的な世界では-攻撃者の観点から-書き換えられたリターンアドレスは、単にバッファアドレスである可能性があります。 また、プログラムがファイルまたはネットワークからデータを読み取る場合、これは非常に可能です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それ以外の場合、攻撃者はトリックを行う必要があります。 人間が読めるテキストを処理する関数では、多くの場合、nullバイトには特別な意味があります。 このようなバイトは行の終わりを示し、行を操作するために使用される関数（コピー、比較、結合）が停止します。 彼らがこのシンボルに出会ったとき。 これは、シェルコードにゼロが含まれている場合、これらのプロシージャがそれを壊すことを意味します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  （翻訳者のメモ：著者のテキストのこの時点で、 <a href="https://thescene.com/watch/arstechnica/how-the-stack-works-part-1">オーバーフローを示すビデオ</a>があります<a href="https://thescene.com/watch/arstechnica/how-the-stack-works-part-1">。</a>その中に、シェルコードがバッファーに入れられ、リターンアドレスが書き換えられます。シェルコードは標準のWindows計算機を起動します。） </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これを回避するために、攻撃者はさまざまなトリックを使用できます。 ゼロを含むシェルコードを問題のあるバイトを回避する同等のシーケンスに変換する小さなコード。 したがって、非常に厳しい制限をクロールすることもできます。 たとえば、脆弱な機能は、標準キーボードから入力できるデータのみを受け入れます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、スタックアドレスには多くの場合ゼロが含まれ、同様の問題があります。これは、スタックバッファからリターンアドレスに書き込むことができないことを意味します。バッファ自体を埋める（およびオーバーフローする可能性がある）ために使用される関数の一部がゼロを書き込むため、これは怖くない場合があります。いくつかの注意を払って、リターンアドレスにスタックアドレスを設定することにより、ヌルバイトを正しい場所に正確に配置するために使用できます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、これが不可能な場合でも、状況は迂回（迂回）で回避されます。実際、すべてのライブラリを備えたプログラムは、メモリ内に大量の実行可能コードを保持しています。このコードのほとんどには、「安全な」アドレスがあります。アドレスにゼロは含まれません。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、攻撃者は</font><i><font style="vertical-align: inherit;">call esp</font></i><font style="vertical-align: inherit;">などの命令を含む適切なアドレスを見つける必要があります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x86）、関数のアドレスとしてスタックポインターの値を使用し、その実行を開始します。これは、スタックバッファーに隠されたシェルコードに最適です。</font><font style="vertical-align: inherit;">攻撃者は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">call esp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令のアドレスを使用し</font><font style="vertical-align: inherit;">て、リターンアドレスとして書き込みます。</font><font style="vertical-align: inherit;">プロセッサはこのアドレスをさらにジャンプしますが、それでもシェルコードに到達します。</font><font style="vertical-align: inherit;">別のアドレスをジャンプするこの手法は、「スプリングボード」と呼ばれます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><table><tbody><tr><td> <a href=""><img src="https://habrastorage.org/files/7c1/a30/1e3/7c1a301e341a44bda94bf8ebc7eb3294.png" width="300"></a> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーバーフローを悪用するために、攻撃者は特定の文字ですべてを詰まらせるのではなく、バッファシェルコードに書き込みます。これは、攻撃者が選択したアクションを実行する実行可能コードの短いセクションです。</font><font style="vertical-align: inherit;">戻りアドレスは、バッファからの対応するアドレスで書き換えられ、プロシージャから戻るときにプロセッサにシェルコードの実行を強制します。</font></font></td></tr></tbody></table></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繰り返しますが、これはプログラムとそのライブラリーが各起動時に同じメモリー領域に配置されるためです-リブート間でも、異なるマシン上でも。この問題で興味深い点の1つは、スプリングボードを実行するライブラリが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">call esp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子を使用する必要さえないことです</font><font style="vertical-align: inherit;">。 2つの適切なバイトが含まれていれば十分です（この場合、値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xd4</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）次々に行きます。それらは、他の機能の一部である場合も、単なる数字の一部である場合もあります。 x86はそのようなことを気にしません。 X86命令は非常に長く（最大15バイト！）、任意のアドレスに配置できます。プロセッサが、たとえば4バイト命令の2番目のバイトなど、中央から命令の読み取りを開始すると、結果は完全に異なるがまだ有効な命令として解釈されます。この状況により、便利なジャンプを簡単に見つけることができます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、場合によっては、攻撃がリターンアドレスを</font><i><font style="vertical-align: inherit;">正確に</font></i><font style="vertical-align: inherit;">設定できないことがあります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要な場所。メモリ内のオブジェクトの場所は非常に似ていますが、マシンごとに、または開始ごとにわずかに異なる場合があります。たとえば、攻撃されたバッファの正確な場所は、システムの名前またはIPアドレスに応じて、またはマイナーなプログラムの更新によりマイナーな変更が行われたために、数バイト上下に変化する場合があります。これに対処するには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほぼ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しい</font><font style="vertical-align: inherit;">返送先アドレスを指定できると便利です</font><font style="vertical-align: inherit;">が、高い</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">精度は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要</font><i><font style="vertical-align: inherit;">あり</font></i><font style="vertical-align: inherit;">ません。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、「ランディングストリップ」（NOPスレッド、点灯。「NOPスレッド」（</font><a href="https://habrahabr.ru/users/halt/" class="user_link"><font style="vertical-align: inherit;">Haltに</font></a><font style="vertical-align: inherit;">感謝）</font></font><a href="https://habrahabr.ru/users/halt/" class="user_link"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正確なロシア語の用語-約）。</font><font style="vertical-align: inherit;">攻撃者は、シェルコードをバッファに直接書き込む代わりに、実際のシェルコードの前に、時には何百ものNOP命令（「no-op」、つまり操作の不在-プロセッサに何もしないように指示する）を書き込みます。</font><font style="vertical-align: inherit;">シェルコードを起動するには、攻撃者</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのNOPの</font><i><font style="vertical-align: inherit;">中央のどこかに</font></i><font style="vertical-align: inherit;">リターンアドレスを設定する必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、NOPの分野に入ると、プロセッサはそれらを迅速に処理し、実際のシェルコードに進みます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><table><tbody><tr><td> <a href=""><img src="https://habrastorage.org/files/c8f/ce1/59f/c8fce159f7dc4283a1ba2d4a897cc745.png" width="300"></a> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻りアドレスをバッファのアドレスで書き換えることは難しい場合があります。</font><font style="vertical-align: inherit;">解決策として、被害先プログラム（またはそのライブラリ）の実行可能コードの一部のアドレスでリターンアドレスを書き換えることができます。</font><font style="vertical-align: inherit;">そして、このフラグメントはすでに制御をバッファに転送します。</font></font></td></tr></tbody></table></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C Blame Everything </font></font></h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これをすべて可能にする主なバグ-使用可能なスペースよりも多くのバッファに書き込む-は、簡単に回避できるもののように見えます。 Cプログラミング言語、または多かれ少なかれ互換性のある子孫、特にC ++とObjective Cを非難するのは誇張です（小さいながらも）。C言語は古く、広く使用されており、オペレーティングシステムとプログラムに必要です。その設計は嫌で、これらのバグはすべて回避できますが、Cは不注意をキャッチするためにすべてを行います。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全な開発に対するCの敵意の例として、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を見てください</font><font style="vertical-align: inherit;">。この関数は1つのパラメーター-バッファー-を取り、標準入力（通常は「キーボード」を意味します）からデータの行を読み取り、それをバッファーに入れます。注意深く見ると、関数が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets（）に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はバッファサイズパラメータが含まれておらず、C設計の楽しい事実として、gets（）関数がそれ自体でバッファサイズを決定する方法はありません。これは、gets（）の場合、単に問題ではないためです。キーボードの人がEnterキーを押すまで、関数は標準入力から読み取ります。次に、この人がバッファに収まらないほど多く入力した場合でも、関数はこのすべてをバッファにプッシュしようとします。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、文字通り安全に使用できない関数です。キーボードから入力されるテキストの量を制限する方法がないため、gets（）関数でバッファオーバーフローを防ぐ方法はありません。 C言語標準の作成者はすぐに問題を認識しました。 C仕様putの1999バージョンでは（）が流通しなくなり、2011アップデートでは完全に削除されます。しかし、その存在（および定期的な使用）は、Cがユーザーに対してどのようなトラップを持っているかを示しています。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Morrisのワームは、1988年に数日で初期のインターネットをクロールした最初の自己拡散型マルウェアであり、この機能を悪用しました。</font><font style="vertical-align: inherit;">BSD 4.3 </font><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fingerd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラム</font><font style="vertical-align: inherit;">は、ネットワークポート79、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finger</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポートでリッスンします</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix用の古代のプログラムであり、リモートシステムにログオンしているユーザーを見つけるために使用される対応するネットワークプロトコルです。</font><font style="vertical-align: inherit;">2つの使用例があります。リモートシステムに問い合わせて、ログインしているすべてのユーザーを見つけるか、特定のユーザー名を要求すると、プログラムはユーザーに関する情報を返します。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><table><tbody><tr><td> <a href=""><img src="https://habrastorage.org/files/c82/13e/372/c8213e372605410d89bc709f7d686663.png" width="300"></a> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残念ながら、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets（）は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に愚かな関数です。</font><font style="vertical-align: inherit;">キーボードのAキーを押し続けるだけで十分で、名前バッファーを埋めた後も停止しません。</font><font style="vertical-align: inherit;">彼女は引き続きメモリにデータを書き込み、フレームポインター、リターンアドレス、および到達可能な他のすべてを上書きします。</font></font></td></tr></tbody></table></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fingerデーモンネットワークに接続するたびに、gets（）を使用してネットワークから512バイトのスタックバッファーへの読み取りを開始しました。通常の操作中、fingerdはfingerプログラムを実行し、ユーザー名（存在する場合）を渡します。 fingerプログラムは、ユーザーを列挙したり、特定のユーザーに関する情報を提供したりする実際の仕事をしました。 Fingerdは、単にネットワーク接続とfingerの起動を担当していました。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一の「実際の」パラメーターがオプションのユーザー名である場合、512バイトはかなり大きなバッファーです。おそらく、誰もユーザー名を持たず、この長さに近いでしょう。ただし、システム内のどこにも、ひどいgets（）関数があるためにこの制限が厳しくありませんでした。ネットワーク経由で512バイト以上を送信すると、fingerdはバッファーをオーバーフローさせます。そして、これはまさにロバート・モリスがやったことです：彼のエクスプロイトは537バイトをfingerdに送信し（536バイトのデータとラインフィードにより読み取りを停止しました）、バッファーをオーバーフローさせ、リターンアドレスを書き換えました。戻りアドレスは、単にスタックバッファ領域に設定されました。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Morrisワームの実行可能なロードは簡単でした。スタックレイアウトがわずかに異なる場合に備えて、400個のNOP命令で始まり、次に短いコードが続きます。このコードは、シェル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ bin / sh</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。これは典型的な攻撃負荷です。 fingerdプログラムはルートの下で起動したため、攻撃中にシェルを起動すると、シェルもルートの下で起動しました。 Fingerdはネットワークに接続され、「キーボード入力」を受け入れ、同様に出力をネットワークに送り返しました。これらの両方は、エクスプロイトによって引き起こされたシェルを継承しました。これは、ルートシェルが攻撃者がリモートで利用できるようになったことを意味します。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets（）を使用することは簡単に回避できるという事実にもかかわらず-Morrisワームの配布中であっても、gets（）を使用しないフィンガードバージョンは利用できませんでした-他のCコンポーネントは無視するのがより難しく、エラーも少なくありません。問題の典型的な原因は、Cでの文字列処理です。前述の動作（ゼロバイトで停止）は、Cの文字列の動作に戻ります。Cでは、文字列はゼロバイトで終了する文字シーケンスです。 Cには、文字列を操作するための一連の関数があります。おそらく最良の例は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcpy（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ある場所から別の場所に文字列をコピーすること、そして</font><i><font style="vertical-align: inherit;">strcat（）</font></i><font style="vertical-align: inherit;">でしょう</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ソース行を宛先の後に挿入します。これらの関数には、宛先バッファサイズパラメータはありません。両方がNULLに遭遇するまでソースから無限に楽しく読み、宛先バッファを満たし、それを気楽にいっぱいにします。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cの文字列関数に</font><font style="vertical-align: inherit;">バッファサイズパラメータ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がある</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合でも、</font><font style="vertical-align: inherit;">エラーとオーバーフローを引き起こす方法でこれを実装します。 Cには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strncat（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strncpy（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">呼ばれる、いくつかの関連する関数strcat（）およびstrcpy </font><i><font style="vertical-align: inherit;">（）があり</font></i><font style="vertical-align: inherit;">ます。手紙</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの関数の名前の意味は、何らかの方法でパラメーターとしてサイズを取ることです。ただし、nは、多くの素朴なプログラマーの考え方は異なりますが、書き込まれるバッファーのサイズではなく、ソースから読み取る文字数です。ソースの文字がなくなった場合（つまり、ゼロバイトに達した場合）、strncpy（）およびstrncat（）は残りをゼロで埋めます。これらの関数には、宛先の実際のサイズをチェックするものはありません。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets（）とは異なり、これらの関数は安全な方法で使用できますが、これは簡単ではありません。 C ++およびObjective-Cには、これらのC関数のより優れた代替手段があり、文字列の操作が簡単かつ安全になりますが、下位互換性のためにC関数もサポートされています。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに、これらはC言語の基本的な欠陥を保持します。バッファはサイズを知らず、言語はバッファで実行される読み取りと書き込みをチェックせず、オーバーフローを許可します。</font><font style="vertical-align: inherit;">この動作により、OpenSSLの最近のHeartbleedバグが発生しました。</font><font style="vertical-align: inherit;">これはオーバーフローではなく、</font><font style="vertical-align: inherit;">OpenSSLのCコードがバッファに含まれている以上の読み取りを試みて、情報をマージしようとしたときの</font><font style="vertical-align: inherit;">再</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取り</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 穴パッチ </font></font></h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もちろん、人類は、読み取りバッファと書き込みバッファをチェックする多くの言語を開発しており、オーバーフローを防ぎます。 MozillaがサポートするRustなどのコンパイルされた言語、Javaや.NETなどのセキュアランタイム、Python、JavaScript、Lua、Perlなどのほとんどすべてのスクリプト言語はこの問題の影響を受けません（ただし、.NET開発者は明示的に保護を無効にして公開できます）自分はバグのようですが、それは個人的な選択です）。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファオーバーフローが引き続きセキュリティ環境の一部であるという事実は、Cの人気を示唆しています。これの理由の1つは、もちろん、大量のレガシーコードです。世界には、すべての主要なオペレーティングシステムのカーネルやOpenSSLなどの一般的なライブラリなど、膨大な量のCコードがあります。開発者がC＃のような安全な言語を使用したい場合でも、Cで記述されたサードパーティライブラリに依存している場合があります。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cを継続して使用するもう1つの理由はパフォーマンスですが、このアプローチの意味は必ずしも明確ではありません。コンパイルされたCおよびC ++は通常、高速な実行可能コードを生成することは事実であり、場合によってはこれは非常に重要です。しかし、私たちの多くにとって、プロセッサはほとんどの時間アイドル状態です。たとえば、ブラウザのパフォーマンスの10％を犠牲にすることができても、同時にバッファオーバーフローの不可能性の鉄の保証を取得できる場合、およびその他の一般的なホールは、これが悪い交換ではないと判断する可能性があります。そのようなブラウザを急いで作成する人は誰もいません。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてにもかかわらず、Cの仲間はどこにも行かない。バッファオーバーフローも同様です。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この種のエラーを防ぐために、いくつかの手順が取られています。開発中に、特別なツールを使用してソースコードと実行中のプログラムを分析し、これらのバグがリリースに忍び寄る前に危険な構造またはオーバーフローエラーを検出することができます。</font></font><a href="https://code.google.com/p/address-sanitizer/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddressSanitizer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの新しいツール</font><font style="vertical-align: inherit;">と</font></font><a href="http://valgrind.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valgrindの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような古い</font><font style="vertical-align: inherit;">ツール</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、このような機能を提供します。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、これらのツールは両方とも積極的な開発者の介入を必要とします。つまり、すべてのプログラムがそれらを使用するわけではありません。バッファオーバーフローが発生した場合のバッファオーバーフローの危険性を減らすことを目的としたシステム保護は、より多くの異なるソフトウェアを保護できます。これを理解して、オペレーティングシステムとコンパイラの開発者は、これらの脆弱性の悪用を複雑にする多くのメカニズムを実装しています。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのシステムの一部は、特定の攻撃を複雑にすることを目的としています。 Linux用のパッチセットの1つは、アドレスに少なくとも1つのゼロバイトが含まれるように、すべてのシステムライブラリが下位アドレスにロードされるようにします。これにより、Cで文字列処理を利用するオーバーフローでの使用が非常に複雑になります。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の救済策はより一般的です。多くのコンパイラには、ある種のスタック保護があります。実行段階で決定された値は、カナリアと呼ばれ、戻りアドレスの隣のスタックの最後に書き込まれます。各関数の最後で、この値はreturnステートメントを実行する前にチェックされます。カナリアの値が変更された場合（オーバーフロー中の上書きにより）、プログラムは続行せずに直ちにクラッシュします。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく最も重要なセキュリティ機能は、W ^ X（「排他的書き込みまたは実行」書き込み）、DEP（「データ実行防止」）、NX（「Xecuteなし」）、XD（「eXecute無効化」）、EVP （AMD固有の用語である「強化されたウイルス保護」）、XN（「eXecute Never」）、おそらくその他。原則はシンプルです。これらのシステムは、メモリをライトダウン（バッファーに適した）と実行可能（ライブラリおよびプログラムコード）、ただし両方同時にではないため、攻撃者がバッファをオーバーフローさせてリターンアドレスを制御できる場合でも、プロセッサはshellkを実行しませんod。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたがそれを呼ぶものは何でも、これは投資を必要としないので、これも重要なメカニズムです。このアプローチは、仮想メモリのハードウェアサポートメカニズムの一部であるため、プロセッサに組み込まれた保護手段を使用します。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前述のように、仮想メモリモードでは、各プロセスは独自のプライベートメモリアドレスのセットを受け取ります。オペレーティングシステムとプロセッサは、仮想アドレスと</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の何かの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比率を共同でサポートし</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。仮想アドレスが物理メモリにマップされることもあれば、ディスク上のファイルの一部にマップされることもあれば、どこにもないこともあります。単に割り当てられていないからです。このマッピングはきめ細かで、通常、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる4096バイトの部分で発生し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示に使用されるデータ構造には、各ページの場所（物理メモリ、ディスク、どこにもありません）だけでなく、また、通常、ページのセキュリティを定義する3つのビット（ページが読み取り可能、書き込み可能、​​実行済みかどうか）が含まれます。このような保護により、スタックなどのデータに使用されるプロセスメモリ領域は、読み取りおよび書き込み用にマークできますが、実行できません。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NXの興味深い点の1つは、オペレーティングシステムを保護をサポートするものに更新するだけで、既存のプログラムに遡及的に適用できることです。プログラムで問題が発生する場合があります。 Javaおよび.NETで使用されるJIT（Just-in-time）コンパイラは、実行時にメモリに実行可能コードを生成するため、書き込みおよび実行可能なメモリが必要です（ただし、これらのプロパティの同時性は必要ありません）。 NXがまだない場合は、読み取り可能な任意のメモリからコードを実行できるため、このようなJITコンパイラの特別な読み取り/書き込みバッファに問題はありませんでした。 NXの登場により、メモリ保護が読み取り/書き込みから読み取り/実行に変更されたことを確認する必要があります。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NXのようなものの必要性は、特にMicrosoftにとって明らかでした。 2000年代初頭、2つのワームがコードセキュリティに深刻な問題を抱えていることを明らかにしました。2001年7月にMicrosoft IIS WebサーバーでWindows 2000を実行している少なくとも359,000システムに感染したCode Redと、75,000以上のシステムに感染したSQL Slammer 2003年1月にMicrosoft SQL Serverを使用しました。これらのケースは評判をよく打ちました。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方のワームはスタックバッファオーバーフローを悪用し、Morrisワームよりもそれぞれ13年後と15年後に出現したにもかかわらず、操作方法がほぼ同じだったことは驚くべきことです。エクスプロイトの負荷はスタックベースのバッファに置かれ、リターンアドレスを書き直しました（わずかな違いは、両方のワームがスプリングボード方式を使用したことです。直接スタックアドレスの代わりに、スタックに制御を戻す命令のアドレスがリターンアドレスに書き込まれました）。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然、これらのワームは他の分野でより高度でした。 Code Redのロードは、単なる自己複製ではありませんでした。彼女はWebページを改ざんし、DoS攻撃を試みました。 SQL Slammerは、感染したマシンに痕跡を残さずに、ネットワーク上の感染と配布の新しいターゲットを検索するために必要なすべてを実行しました。マシンを再起動します-そこにはありません。どちらのワームもインターネットで動作しました。これは、モリスワームが広がったワームよりも何倍も大きかったため、感染数ははるかに多くなりました。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、主な問題-簡単に悪用されるスタックバッファオーバーフロー-は同じままです。これらのワームは見出しに登場し、多くの種類のWindowsをインターネット上のサーバーとして使用する可能性を疑っていました。マイクロソフトの答えは、セキュリティについて真剣に考え始めることでした。 Windows XP Service Pack 2は最初のセキュリティインストールでした。ソフトウェアファイアウォールの追加、ツールバーとプラグインのサイレントインストールを妨げるInternet Explorerの変更、NXのサポートなど、いくつかのソフトウェアの変更が行われました。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NX対応ハードウェアは、2004年頃にIntelがPrescott Pentium 4を導入したときに登場し始め、Windows XP SP2以降オペレーティングシステムのサポートが一般的になりました。</font><font style="vertical-align: inherit;">Windows 8では、NXの実行方法がわからないプロセッサのサポートを拒否して、この瞬間をさらに強制することにしました。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NXの後の出来事 </font></font></h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NXサポートの普及にもかかわらず、バッファオーバーフローは依然として緊急の情報セキュリティ問題です。その理由は、NXをバイパスする多くの方法の開発です。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらの最初のものは、上記のスプリングボードに類似しており、別のライブラリまたは実行可能ファイルにある命令を介してスタックバッファ内のシェルコードに制御を転送します。攻撃者は、制御をスタックに直接転送する実行可能コードのフラグメントを探す代わりに、何か有用なことを行うフラグメントを見つけます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく、この役割の最適な候補は、Unix関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム（）です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 1つのパラメーターが必要です。実行するコマンドを表す文字列のアドレスです。通常、このパラメーターはスタックを介して渡されます。攻撃者は必要なコマンドを作成し、それをオーバーフローしたバッファーに入れることができます。（従来）メモリ内のオブジェクトの場所は変わらないため、この行のアドレスがわかっており、攻撃中にスタックにプッシュできます。この場合、書き換えられた戻りアドレスは、バッファ内のアドレスを示していません。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">system（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を指します</font><font style="vertical-align: inherit;">。オーバーフローが発生しやすい関数が終了すると、呼び出し元の関数に戻る代わりに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">system（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が起動</font><font style="vertical-align: inherit;">し、攻撃者によって指定されたコマンドが実行されます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、NXを回避する方法です。機能</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムライブラリの一部であることは既に実行可能です。このエクスプロイトでは、スタックからコードを実行する必要はありません。</font><font style="vertical-align: inherit;">そこからコマンドを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読む</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけ</font><font style="vertical-align: inherit;">です。この手法は「return-to-libc」（libcに戻り、システム（）を含む多くの主要な機能を含むUnixライブラリであり、通常すべてのUnixプロセスにロードされるため、このような使用に適したターゲットになります） 1997年、ロシアの情報セキュリティの専門家である</font></font><a href="http://insecure.org/sploits/linux.libc.return.lpr.sploit.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solar Designer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この手法は便利ですが、制限があります。</font><font style="vertical-align: inherit;">多くの場合、関数はスタックからではなく、レジスタから引数を受け取ります。</font><font style="vertical-align: inherit;">実行のためにコマンドを転送するのは便利ですが、多くの場合、これらの愚かなゼロが含まれており、これは大きな障害です。</font><font style="vertical-align: inherit;">さらに、この方法で一連の異なる呼び出しを構成するのは簡単ではありません。</font><font style="vertical-align: inherit;">1つではなく複数のリターンアドレスを登録することは可能ですが、リターン値またはその他のものを使用して引数の順序を変更する方法はありません。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><table><tbody><tr><td> <a href=""><img src="https://habrastorage.org/files/1f0/b40/4bd/1f0b404bd4f84af5b3e7fc3b67d5cef9.png" width="300"></a> </td><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファをシェルコードで埋める代わりに、一連の戻りアドレスとデータで埋めます。</font><font style="vertical-align: inherit;">これらの戻りアドレスは、犠牲プログラムとそのライブラリ内の実行可能コードの既存のフラグメントに制御を移します。</font><font style="vertical-align: inherit;">コードの各部分は、操作を実行して戻りを実行し、次の戻りアドレスに制御を渡します。</font></font></i> </td></tr></tbody></table></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     長年にわたり、これらの制限を回避するために、libcへの復帰が一般化されてきました。  2001年の終わりに、このメソッドの<a href="http://phrack.org/issues/58/4.html">いくつかの</a>拡張<a href="http://phrack.org/issues/58/4.html">オプション</a>が文書化されました。複数呼び出しの可能性とゼロバイト問題の解決策です。 これらの問題のほとんどを解決したより複雑な方法は、 <a href="http://cseweb.ucsd.edu/~hovav/dist/geometry.pdf">2007年</a>に正式に記述されました：リターン指向プログラミング（ROP、リターン指向プログラミング）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      return-to-libcおよびspringboardと同じ原理を使用しますが、より一般化されています。 スプリングボードが実行をバッファ内のシェルコードに転送するために単一のコードを使用する場合、ROPは元の出版物で「ガジェット」と呼ばれる<i>多く</i>のコードを使用します。 各ガジェットは特定のパターンに従います。特定の操作（レジスタへの値の書き込み、メモリへの書き込み、レジスタの追加など）を実行した後、リターンコマンドを実行します。  x86をスプリングボードに適したものにするまさにその特性がここで機能します。 プロセスメモリに読み込まれたシステムライブラリには、「アクションとリターン」として解釈できる<i>数百の</i>シーケンスが含まれています。これは、ROP攻撃に使用できることを意味します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ガジェットを単一のユニットに結合するには、バッファオーバーフロー中にスタックに書き込まれた長い一連のリターンアドレス（および有用で必要なデータ）が使用されます。 戻り命令はガジェットからガジェットにジャンプしますが、プロセッサ<i>は</i>関数を<i>呼び出す</i>ことはめったにない（またはまったくしない） <i>が、</i>関数から<i>は戻り</i>ます。 興味深いことに、少なくともx86では、有用なガジェットの数と種類が多く、攻撃者は文字通り<i>何でも</i>できます。 特別な方法で使用されるこのx86のサブセットは、多くの場合チューリング完全です（ただし、機能の全範囲は、プログラムによってロードされるライブラリ、したがって利用可能なガジェットのリストに依存します）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      return-to-libcと同様に、実際に実行可能なコードはすべてシステムライブラリから取得されるため、NXのような保護は役に立ちません。 このアプローチの優れた柔軟性は、エクスプロイトが、例えば、レジ​​スターを介して引数を取る関数を呼び出す、他の関数の戻り値を使用するなど、libcに戻るシーケンスで整理するのが困難なことを行えることを意味します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ROP攻撃の負荷は異なります。 これは、シェル（シェルへのアクセス）を取得する単純なコードである場合があります。 もう1つの一般的なオプションは、ROPを使用してシステム関数を呼び出し、メモリページのNXパラメーターを変更して、書き込み済みから実行可能に変更することです。 これにより、攻撃者は通常の非ROPロードを使用できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> ランダム化 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      NXのこの弱点は古くから知られており、このタイプのパターンを悪用しています。攻撃者はメモリ内のスタックおよびシステムライブラリのアドレスを事前に知っています。 すべてはこの知識に基づいているため、明らかな解決策は攻撃者からこの知識を奪うことです。 これはまさにASLRが行うことです（アドレス空間レイアウトのランダム化）。スタックの位置と、ライブラリおよび実行可能コードのメモリ内の位置をランダム化します。 通常、プログラムが起動、再起動、またはそれらの組み合わせのたびに変更されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     非常に予想外なことに、攻撃者はROPに必要な命令フラグメントがどこにあるか、または少なくともオーバーフロースタックがどこにあるかを知らないため、この状況は操作を著しく複雑にします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ASLRは主にNXに付属しており、libcまたはROPに戻るなどの大きなホールを閉じます。 残念ながら、NXよりも透過性がわずかに劣ります。  JITコンパイラーや他の多くの特定のケースとは別に、NXは既存のプログラムに安全に統合できます。  ASLRにはさらに問題があります。それにより、プログラムやライブラリは、ロード先のアドレスの値に依存することができなくなります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     たとえば、Windowsでは、これはDLLにとって大きな問題ではありません。  Windowsでは、DLLは常に異なるアドレスへの読み込みをサポートしていましたが、EXEではこれが問題になる可能性があります。  ASLR以前は、EXEは常に<i>0x0040000</i>でロードされていたため、この事実に依存していました。  ASLRでは、これは当てはまりません。 潜在的な問題を防ぐために、Windowsでは、デフォルトでASLRサポートを明示的に指定するプログラムが必要です。 ただし、セキュリティ思想家は、WindowsにすべてのプログラムとライブラリのASLRを有効にすることにより、このデフォルトの動作を変更できます。 これが問題を引き起こすことはほとんどありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      x86上のLinuxでは、このプラットフォームでASLRを実装するアプローチにより、パフォーマンスが最大26％低下するため、状況は<a href="https://insights.sei.cmu.edu/cert/2014/02/differences-between-aslr-on-windows-and-linux.html">おそらく悪化</a>します。 さらに、このアプローチで<i>は</i> 、ASLRをサポートするプログラムとライブラリをコンパイル<i>する必要が</i>あります。  Windowsのように、管理者がASLRを強制する方法はありません（x64では、パフォーマンスの低下はまったくなくなりませんが、大幅に削減されます） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ASLRがアクティブな場合、単純なハッキングに対する強力な保護を提供します。 しかし、彼は完璧ではありません。 たとえば、制限の1つは、取得できるランダム性の程度です。これは、32ビットシステムで特に顕著です。 アドレス空間には40億の異なるアドレスがありますが、それらのすべてがライブラリのロードやスタックに使用できるわけではありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これには多くの制限があります。 それらのいくつかは目的の幅広さです。 一般に、オペレーティングシステムは、プロセスのアドレス空間の一方の端でライブラリを互いに近くにロードすることを選択して、アプリケーションでできるだけ多くの連続した空間を利用できるようにします。  256 MBのメモリごとに1つのライブラリを取得するのは望ましくありません。メモリの最大単位割り当ては256 MB未満になるため、アプリケーションが大量のデータを処理する能力が制限されるためです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     通常、実行可能ファイルとライブラリは、少なくともページの境界で始まるようにロードする必要があります。 通常、これは、4096で割り切れるアドレスにロードする必要があることを意味します。異なるプラットフォームには、同様のスタック制限があります。 たとえば、Linuxは16で割り切れるアドレスでスタックを開始します。メモリ制限のあるシステムでは、すべてを配置できるようにするために、ランダム性をさらに制限しなければならない場合があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     結果は異なりますが、攻撃者がヒットする可能性が高い場合に、正しいアドレスを推測できる場合があります。 状況によっては、低い確率（たとえば256の1つ）でも十分な場合があります。 クラッシュしたプロセスを自動的に再起動するWebサーバーを攻撃する場合、256の攻撃のうち255がプロセスをクラッシュすることは問題ではありません。 再起動され、再試行できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、64ビットシステムでは、アドレス空間が非常に大きいため、このようなアプローチは役に立ちません。 攻撃者は、100万回に1回、または10億回に1回しかチャンスを持たない可能性があり、これは重要ではないほど十分に小さいものです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     たとえば、ブラウザを攻撃するのは推測や落下は良い戦略ではありません。 攻撃者にチャンスを与えるためだけに、ユーザーが連続して256回ブラウザを再起動することはありません。 その結果、アクティブなNXおよびASLRを備えたシステムでのこのような脆弱性の悪用は、支援なしでは実行できません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このような支援にはいくつかの種類があります。 ブラウザでJavaScriptまたはFlashを使用すると（どちらにも実行可能コードを生成するJITコンパイラが含まれています）、きちんと設計された実行可能コードでメモリを埋めることができます。 これにより、大きな着陸帯のようなものが作成されます。これは、「ヒープスプレー」（「ヒープスプレー」）と呼ばれる技術です。 別のアプローチとして、ライブラリのアドレスを開いたり、メモリ内にスタックしたりするための2次的なバグを見つけ、攻撃者にROPの特定のリターンアドレスセットを作成するのに十分な情報を与えることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3番目のアプローチはブラウザでも一般的でした。ASLRの方法がわからないライブラリを使用します。  Adobe PDFプラグインやMicrosoft Officeなどの古いバージョンはASLRをサポートしておらず、WindowsはデフォルトでASLRを強制しません。 攻撃者がそのようなライブラリのロードを引き起こす可能性がある場合（たとえば、非表示のブラウザフレームにPDFをダウンロードすることにより）、ASLRを心配する必要はなくなりますが、ROP目的でこのライブラリを使用します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 終わりのない戦争 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     脆弱性を悪用する人々と防御する人々の間には、絶え間ない軍拡競争があります。  ASLRやNXなどの強力な防御システムは水準を引き上げ、欠陥の使用を困難にします。それらのおかげで、単純なバッファーオーバーフローの時代を残しましたが、賢明な攻撃者は穴の組み合わせを見つけて、これらの保護対策を回避できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     エスカレーションは続きます。  Microsoft <a href="https://support.microsoft.com/en-us/kb/2458544">EMET</a> （Enhanced Mitigation Experience Toolkit）には、ヒープスプレーまたはROPエクスプロイトの特定の重要な機能の呼び出しを検出できる一連の半実験的防御が含まれています。 しかし、継続的なデジタル戦争では、これらのトリックのいくつかでさえすでに敗北しています。 これにより、それらが役に立たなくなることはありません-脆弱性を悪用する複雑さ（およびそのための価格）は、各対策が適用されるたびに増加します-しかし、これは絶え間ない警戒の必要性を思い出させます。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J266577/index.html">カーダーの地下市場。 KingPINの翻訳。 第2章「死の武器」</a></li>
<li><a href="../J26658/index.html">Classmates.info</a></li>
<li><a href="../J266581/index.html">Androidの重大な脆弱性に対するStagefrightエクスプロイトコードが公開されました</a></li>
<li><a href="../J266583/index.html">起こった！ io.js + NodeJS = NodeJS 4.0.0</a></li>
<li><a href="../J266585/index.html">オープンソースJIRAのカレンダー</a></li>
<li><a href="../J266593/index.html">絶対最小値。 量子論が私たちの世界をどのように説明するか</a></li>
<li><a href="../J266595/index.html">ゴーストシミュレータ。 プログラマーになるというアイデアから、iOSで完成したゲームまで</a></li>
<li><a href="../J266597/index.html">データアーカイブを作成するBashスクリプト</a></li>
<li><a href="../J2666/index.html">ページナビゲーション</a></li>
<li><a href="../J266601/index.html">タブ内の設定とウィークリービルドVivaldi 1.0.270.16の他のささいなこと</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>