<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👠 🚈 ♑️ スーパースカラースタックプロセッサ：連続クロッシングスネークとハリネズミ 🔬 📶 🚕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事の続きでは、スタックされたマシンのフロントエンドが OoOを背後に持つスーパースカラープロセッサを隠すことを実証できました 。 
  
 この記事のトピックは、関数呼び出しです。 
  
  
  
  スタックと関数呼び出し  
  
 一般的な理由により、説明されているアーキテクチャでは...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>スーパースカラースタックプロセッサ：連続クロッシングスネークとハリネズミ</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/279123/"><img src="https://habrastorage.org/files/acb/653/0c8/acb6530c810f428785100c32cc6843cc.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この<a href="https://habrahabr.ru/post/278575/">記事</a>の続きで<a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">は、</a>スタックされたマシンの<a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">フロントエンドが</a> <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">OoOを背後に</a>持つ<a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">スーパースカラー</a>プロセッサを隠すことを実証できまし<a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">た</a> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事のトピックは、関数呼び出しです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> スタックと関数呼び出し </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一般的な理由により、説明されているアーキテクチャでは、関数の呼び出しに問題があると想定されています。 実際、関数から戻った後、現在の関数のコンテキストでレジスタの状態を期待して返します。 最新のレジスタアーキテクチャでは、レジスタ<a href="https://habrahabr.ru/post/267771/">は</a>このために2つのカテゴリに<a href="https://habrahabr.ru/post/267771/">分け</a>られます-呼び出し側は一部の安全を担当し、呼び出し側は他の人を担当します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、このアーキテクチャでは、フロントエンドはスタックであるため、コンパイラーはレジスターの存在を認識しない場合があります。 また、プロセッサ自体がコンテキストの保存/復元を処理する必要がありますが、これは重要なタスクのようです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、最初に、スタック自体のトピックについて余談します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタックの概念そのものが誤解を招く可能性があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://everything2.com/title/System%25252F370%2BS-type%2Blinkage%2Bconvention">IBM / 360に</a>はハードウェアスタックはありません。 ただし、関数を（再帰的にも含めて）呼び出すことができます。このため、パラメーターはメモリ領域に格納されます。これは、呼び出しの前にOSから要求する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      x86にはハードウェアスタックがありますが、このアーキテクチャをスタックに割り当てる人はいません。 このスタックは、ローカル変数と関数パラメーターを保存するための優れたメカニズムです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      AMD29K、SPARC、およびItaniumは、いわゆる<a href="https://en.wikipedia.org/wiki/Berkeley_RISC">バークレー</a>リスクアーキテクチャファミリに属し、それらのスタックには別の重要な機能があります。レジスタプールは、スタックの最上部（レジスタウィンドウ）であり、関数呼び出し時のパラメータ転送を高速化することになっています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      SPARC V7は、AMD29Kよりも数年早く登場しましたが、（著者にとっては）アーキテクチャ的にスリムではないようです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Itaniumの<a href="http://people.cs.pitt.edu/~mock/cs2210/handouts/itanium-register-convention.pdf">RSE</a>ユニットは、一般的にAMD29Kのユニットと似ていますが、後に登場しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <a href="http://datasheets.chipdb.org/AMD/29K/29kprog.pdf">AMD29K</a>は親切な言葉に値する </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2つのハードウェアスタックがあります。 アーキテクチャのいくつかのスタックは新しいものではなく、ソ連の（そして<a href="http://www.mcst.ru/doc/book_121130.pdf">現在の</a> ）エルブラスの<a href="http://www.cs.virginia.edu/brochure/images/manuals/b5000/descrip/descrip.html">バロウズB5000</a>にありました。 ただし、2番目のスタックは、プロシージャからの戻りアドレスを格納するように設計されています。 ここでは、両方ともデータの保存に使用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> メモリスタック-16を超える場合、大きなローカル変数（構造体と配列）およびパラメーターのテールを格納するために使用されます。レジスタgr125（msp）は、このスタックの最上部へのポインターです。 </li><li> レジスタスタック-スタックの最上位を形成する128個のローカルレジスタがあります 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> レジスタスタックは、メモリ内のスタックの最上部にすばやくアクセスするために使用されます（もちろん、上記のメモリスタックとは異なります） </li><li> グローバルレジスタgr126（rab）およびgr127（rfb）はスタックの最上部と最下部を定義し、gr1（rsp）は最上部へのポインターを格納します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/aef/e15/7d6/aefe157d679149559ffe34627b6654a7.PNG"></li><li>  1つのサイクルで2つの読み取りと1つのレコードを実行できます </li><li> プッシュ＆ポップなどの明示的なスタック操作はありません。関数が呼び出されると、コンパイラーによって定義されたレジスターの数が解放されます（呼び出しフレームがここで呼び出されるため、アクティブ化レコード） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li> アクティベーションレコードからのデータへのアクセス<b>は、各機能のlr0から番号が付けられた</b>レジスタを経由し<b>ます。</b> </li><li>  lr0とlr1は予約されており、最初は戻りアドレス、2番目は呼び出し側関数のアクティベーションレコードです。 </li><li> 呼び出し元および呼び出された関数の登録ウィンドウは、 <a href="http://people.cs.clemson.edu/~mark/subroutines/sparc.html">SPARC</a>と同様のパラメーターと交差します </li><li> 新しい関数を呼び出すのに十分な空きレジスタがない場合、 <a href="https://en.wikipedia.org/wiki/Trap_(computing)">トラップ</a> SPILLが発生し、そのハンドラはレジスタ値の一部をメモリにプッシュして解放します </li><li> 逆に、空きレジスタが多すぎると、FILLがトリガーされます </li><li> これが起こるために、コンパイラは命令を挿入します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><pre>         sub gr1、gr1,16;関数プロローグ、lr0 + lr1 + 2ローカル変数 
         asgeu SPILL、gr1、rab;ウィンドウの上部と比較 
 。  。  。  ;関数本体
         jmpi lr0;リターン 
         asleu FILL、lr1、rfb;ウィンドウgr127の下部と比較
</pre></blockquote></li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ul> ここで注目すべき面白いアイデアは何ですか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 各関数のレジスタの番号付けは独自です。これはバークレーRISCの機能です </li><li> ただし、スタック分割はこの特定のアーキテクチャの機能です。  SPARCでは、レジスタウィンドウ<a href="http://ieng9.ucsd.edu/~cs30x/sparcstack.html">は</a>通常の（高速ではない）変数と同じスタックに<a href="http://ieng9.ucsd.edu/~cs30x/sparcstack.html">保存さ</a>れます。 そして、塗りつぶし/流出はブレークで行われます-各ウィンドウはそのフレームからです。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタックを「大きいが遅い」と「小さいが速い」に分けることは非常に重要です。 動機に対処しましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> パラメーターの受け渡し、関数の呼び出し </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタックをローカル変数（およびパラメーター）のリポジトリとしてのアイデアは、その論理と完全性において美しいです。 弱点-システムのパフォーマンスは、レイテンシとメモリのパフォーマンスに依存します。  <a href="https://en.wikipedia.org/wiki/PDP-11">PDP-11の</a>時代には何もできませんでしたが、それ以来状況は変わりました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、レジスタへのアクセスはメモリへのアクセスよりも大幅に高速になり、データのキャッシュが必要になりました。 第二に、はるかに多くのレジスタを持つことが可能になりました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     多数のレジスタを所有すると、それらを使用して関数を呼び出すときに引数の転送を高速化することができます。 実際、通常、パラメーターはほとんどなく（ローカルデータよりも少ない）、その値はほとんどの場合、誰かが必要とします。 そして、どのローカルデータがレジスタに入るのに値するのかによって、最適化が決定されます。 もちろん、これは非常に粗雑な単純化であり、一般的な動機付けを示すためだけに設計されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     現在、レジスタを介してパラメーターを渡す2つの方法が一般的です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 特定のレジスタに特別な役割を割り当てます。 たとえば、 <a href="https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx">MSVC（x86-64）</a>では、最初の4つの整数引数はレジスタRCX、RDX、R8、R9を介して渡されます。 これから、すべての機能に対してレジスタの番号が統一されます。 この手法を使用するアーキテクチャには、MIPS、PPC、ARM、DEC Alphaも含まれます。コールチェーンには、スタック以外にパラメータを保存する場所がないことは明らかです。 これはすべてキャッシュに関するものです。 または、この関数の特定のパラメーターはもう使用されておらず、保存する必要がないと判断できるオプティマイザーに対して。 </li><li> 登録ウィンドウのテクニック。 このアーキテクチャのブランチは、Berkeley Riscプロジェクトから発展しました。 これには、i960、Itanium、SPARCだけでなく、すでに分解したAMD29Kも含まれます。 一番下の行は、限られた数のパラメーターと呼び出された関数のローカルデータがレジスタウィンドウにあり、次の関数が呼び出されるとウィンドウがシフトするため、このデータがスタックを形成します。 各関数には、独自のレジスタ番号があります。 ウィンドウに収まらないものはすべて通常のスタックに分類され、一時データ用のグローバルレジスタも使用できます。 したがって、 <a href="http://download.intel.com/design/i960/MANUALS/27248302.pdf">i960</a>およびSPARCの場合、レジスタスタックは通常のスタックに散在していますが、AMD29KおよびItaniumの場合、これらは異なるスタックです。 実際、AMD29KとItaniumは、コンパイラが「高速スタック」にふさわしいと考えるデータの種類を選択するためのコンパイラを提供します。他のすべては自動的に行われます。 これは、Cで廃止されたキーワード「レジスタ」を連想させるものですが、決定はコンパイラによって行われますが、高レベル言語です。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     潜在的なパフォーマンスの観点では、両方のアプローチはほぼ同等です。 最初のアプローチでは、最適化の全体的な負担はコンパイラにあり、プロセッサにはありません。これにより、（おそらく）最終システムの設計がより簡単で安価になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、少し夢中になったので、設計中のアーキテクチャで現在の関数のコンテキストを維持することに戻りましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 関数コンテキストの保存 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして、このコンテキストには何が含まれていますか？ 子プロシージャの呼び出し時に占有されていたレジスタ。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この場合、計算が不十分な式のレジスタはトポロジカルソートを介して相互接続されますが、これは呼び出された関数には関係ありません。 モップによる出力レジスターのキャプチャー時に、キャプチャーされた順番は関係ありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     注目に値するニュアンスがあります-関数呼び出しの開始前に、その引数が計算されたすべてのモップがうまくいくはずです。 したがって、プロセッサの観点から見ると、関数呼び出しは、任意の数の引数を持つ一般化された命令です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここで、レジスタの番号付けを決定する価値があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     番号付けを一般的にする、つまり  SPARCではなくMIPSパスをたどりました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 呼び出しチェーンが十分に長い場合、 <b>すべてのレジスタがビジー</b>であることは明らかです。 そして、どれをメモリにアンロードするか（SPILL）について話します。 つまり キャプチャ順序は依然として重要です。 </li><li> キャプチャ順序は通話履歴に依存します </li><li> 関数内では、動的に定義されます </li><li>特定のレジスタで関数の結果を返すという保証はありませんが、（FILLの逆実行中に）このレジスタと競合しない </li><li> 著者はそのような競合を回避する方法を見ていません。もちろん、それは実際には何も存在しないという意味ではありません </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ウィンドウを登録してみましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 各関数のレジスタの番号付けが新たに始まり、これは素晴らしいことです。 バックグラウンドを考慮することから私たちを救います </li><li> 従来技術-循環レジスタバッファ、FILL＆SP​​ILL </li><li>  2つの物理スタックを使用します-レジスタウィンドウとその他すべてに </li><li> 関数が呼び出されたときに使用されたレジスタを覚えておく必要があります そして、私たちはそのような情報を持っています。 レジスタr0、r5、r11がビジーであるとします。 実際、レジスタの使用範囲の4分の1しか使用されておらず、何らかの方法でそれらを「パック」する誘惑があります。 しかし、その後、子関数から戻るとき、それらを「アンパック」する必要があります。 したがって、現在の関数（この場合）のレジスターのプールは、12個のレジスターのサイズのままです（+サービス情報：戻りアドレス、前のフレーム）。 さらに、レジスタ自体の数はそれほど重要ではなく、同時読み取り/書き込み操作の数ははるかに高価ですが、変更されません </li><li> しかし、レジスタをメモリに保存することで、おそらく何かを行うことができます。明らかに不要なデータを未使用のレジスタからメモリに保存しないようにしましょう </li><li> これを行うには、ビジーな関数レジスタを書き込んだ後、雇用のマスクを保存します </li><li> このため、順番に、必要なレジスタの数ではなく、フレームごとにFILL＆SP​​ILLを実行する必要があります。一度に1つの呼び出しに関係するすべて </li><li> 循環レジスタバッファの現在の先頭には、常にフレーム記述子があります（SPILLの次の候補） </li><li>  FILLで取得する最初のレジスタには、使用済みレジスタのマスク（またはその一部）が含まれます。これを使用して、必要に応じて、必要な数のレジスタをメモリから取得します </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ただし、関数呼び出しの外側に注目することで、これらすべてが内部で実行される方法を見失っています。 著者は自分自身をハードウェアの専門家とは考えていませんが、それでも問題を予測しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     幸いなことに、 <a href="https://habrahabr.ru/post/280087/">次の記事</a>でそれらに対処します。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J279099/index.html">ゲーム市場の予測：7つの分析機関の数字</a></li>
<li><a href="../J2791/index.html">RIFは参加者の登録を開始しました</a></li>
<li><a href="../J279101/index.html">貧しいXWiki、一言で言えば-2</a></li>
<li><a href="../J279105/index.html">コンテナ：「マジックフレームワーク」を検索し、Kubernetesがその理由になった理由</a></li>
<li><a href="../J279111/index.html">内部のC ++例外処理、またはC ++での例外の動作</a></li>
<li><a href="../J279125/index.html">ダガー2。パート1。 基本、依存関係グラフの作成、スコープ</a></li>
<li><a href="../J279127/index.html">Nutanix Big Update：NutanixOS 4.6</a></li>
<li><a href="../J279129/index.html">エラーの質問へ</a></li>
<li><a href="../J27913/index.html">7月のロシアのMSI Wind</a></li>
<li><a href="../J279133/index.html">モバイル＃144開発者向けの興味深い資料のダイジェスト（3月9〜13日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>