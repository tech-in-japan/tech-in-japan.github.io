<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏾 💍 👀 変更されたジオメトリバッファアンチエイリアシングアルゴリズム 🆘 🌿 🚁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="エイリアシングはコンピューターグラフィックスの基本的な問題の1つであり、これに対処するためにさまざまなアンチエイリアシングアルゴリズムが発明されています。 MLAAの出現は、後処理アルゴリズムに関心を集めています。 そのようなアルゴリズムの1つ（少し注意が必要です）は、 Geometry Buffe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>変更されたジオメトリバッファアンチエイリアシングアルゴリズム</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/307366/"> エイリアシングはコンピューターグラフィックスの基本的な問題の1つであり、これに対処するためにさまざまなアンチエイリアシングアルゴリズムが発明されています。  <a href="https://habrahabr.ru/post/124913">MLAA</a>の出現は、後処理アルゴリズムに関心<a href="https://habrahabr.ru/post/124913">を</a>集めています。 そのようなアルゴリズムの1つ（少し注意が必要です）は、 <i>Geometry Buffer Anti-Aliasing</i> （GBAA）です。 この記事では、元のアルゴリズムを変更して、場合によってはアンチエイリアスの品質を向上させる試みについて説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/896/ffd/a06/896ffda0608daacc04b99f41243ef623.png" alt="画像"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 幾何学的ポストプロセスアンチエイリアシング（GPAA） </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://humus.name/index.php%3Fpage%3D3D%26ID%3D87">GBAA</a>は<a href="http://humus.name/index.php%3Fpage%3D3D%26ID%3D86">Geometric Post-process Anti-Aliasing（GPAA）アルゴリズムの</a>高度なバージョン<a href="http://humus.name/index.php%3Fpage%3D3D%26ID%3D86">です</a> 。 その根底にある考え方は、元の画像の鋭いエッジを検索する代わりに、幾何学的なエッジの位置を推定する（MLAAのように）代わりに、「純粋な形」でエッジに関する情報を使用してレンダラーから受け取ることができるということです。 アルゴリズムは非常に簡単です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> シーンのレンダリング（メインパッセージ）; </li><li> バックバッファのコピーを作成します。 </li><li> 追加のパスで幾何学的エッジをレンダリングし、隣接するピクセルの色を混合して滑らかなエッジを取得します。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ピクセルカラーの混合（ブレンド）は、次のように実行されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 各ピクセルについて、方向（垂直または水平）と最も近いエッジまでの距離が決定されます。 </li><li> 方向と距離を使用して、隣接する三角形のピクセルカバレッジが計算されます。 </li><li> 方向は隣接するピクセルを選択するために使用され、カバレッジは混合係数を計算するために使用されます。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この図は、アルゴリズムのロジックを示しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8f/958/134/d8f95813476916dc94de0b447214e1c5.png" alt="GPAAイラスト"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     太線は、幾何学的エッジを示します。 矢印は、隣接するピクセルの選択を示します。 破線はピクセルの中心に対するオフセットを示し、ブレンド係数の計算に使用されます。 ブレンドは、テクスチャからの単一の選択で行われます。オフセットが現在のピクセルのテクスチャ座標に追加され、線形フィルターが残りを行います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     頂点シェーダーでは、幾何学的エッジの座標がスクリーン平面に投影され、エッジが位置する直線の方程式を取得するために使用されます。  4次元ベクトル形式の方程式はピクセルシェーダーに分類され、そこでピクセルのカバレッジと色が計算されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">シェーダーコード（HLSL）</b> <div class="spoiler_text"><pre><code class="hljs pgsql">struct VsIn { float3 Position0 : Position0; float3 Position1 : Position1; }; struct PsIn { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_Position; // The parameters are <span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> across the <span class="hljs-type"><span class="hljs-type">line</span></span> so use the nointerpolation <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span>. // This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> necessarily required, but <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> this we can make the vertex shader slightly shorter. nointerpolation <span class="hljs-type"><span class="hljs-type">float4</span></span> KMF : KMF; }; float4x4 ViewProj; <span class="hljs-type"><span class="hljs-type">float4</span></span> ScaleBias; PsIn main(VsIn <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>) { PsIn <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> pos0 = mul(ViewProj, <span class="hljs-type"><span class="hljs-type">float4</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.Position0, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-type"><span class="hljs-type">float4</span></span> pos1 = mul(ViewProj, <span class="hljs-type"><span class="hljs-type">float4</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.Position1, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position = pos0; // Compute screen-space position <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span> float2 pos = (pos0.xy / pos0.w) * ScaleBias.xy + ScaleBias.zw; float2 dir = (pos1.xy / pos1.w) * ScaleBias.xy + ScaleBias.zw - pos; // <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> mostly horizontal <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> vertical <span class="hljs-type"><span class="hljs-type">bool</span></span> x_gt_y = abs(dir.x) &gt; abs(dir.y); // Pass down the screen-space <span class="hljs-type"><span class="hljs-type">line</span></span> equation <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x_gt_y) { <span class="hljs-type"><span class="hljs-type">float</span></span> k = dir.y / dir.x; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.xy = float2(k, <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">float</span></span> k = dir.x / dir.y; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.xy = float2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, k); } <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.z = -dot(pos.xy, <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.xy); <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.w = asfloat(x_gt_y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; } Texture2D BackBuffer; SamplerState <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>; float2 PixelSize; <span class="hljs-type"><span class="hljs-type">float4</span></span> main(PsIn <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>) : SV_Target { // Compute the difference <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> geometric <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sample position <span class="hljs-type"><span class="hljs-type">float</span></span> diff = dot(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.KMF.xy, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.Position.xy) + <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.KMF.z; // Compute the coverage <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the neighboring surface <span class="hljs-type"><span class="hljs-type">float</span></span> coverage = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f - abs(diff); float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coverage &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> sample a neighbor pixel <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = diff &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asuint(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.KMF.w)) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; } // Blend pixel <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> neighbor pixel <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> texture filtering <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> shifting the coordinate appropriately. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BackBuffer.Sample(<span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.Position.xy + coverage * <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.xy) * PixelSize); }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムの主な利点は、品質とパフォーマンスです。 アンチエイリアシングの品質は、リブの角度に依存しません。これは、後処理技術の伝統的な問題です。 最初の図は、さまざまな品質プリセットを使用したFXAAの結果を示し、2番目の図はGPAAの結果を示しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cd/82c/38a/6cd82c38a8bd1d680d47ab4d37ec651b.png" alt="FXAA水平エッジ"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>FXAA 3、FXAA 5</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d7/79d/979/5d779d979de8538d2d6661d01dff8549.png" alt="GPAA水平エッジ"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>GPAA</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最も高価な操作はスクリーンバッファーのコピーです：1280x720解像度でHD 5870ビデオカードに1フレーム（元の実装）をレンダリングするには0.93ミリ秒かかります。スクリーンバッファーのコピーには0.08ミリ秒かかり、エッジの平滑化には実際に0.01ミリ秒かかります。 欠点は、明らかに、エッジとそれらを格納するための追加メモリを抽出するためのジオメトリの予備処理が必要なことです。 さらに、消費者レベルのGPUは、ラインラスタライゼーションを比較的ゆっくり実行します。 一緒に、これらの問題はGPAAのスケーラビリティに悪影響を及ぼし、シーンの幾何学的な複雑さが増大します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> ジオメトリバッファーアンチエイリアシング（GBAA） </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、GBAAはGPAAの改良バージョンです。 改善自体は、三角形の境界線への方向と距離がジオメトリシェーダーで計算されるという事実にあります。これにより、ジオメトリの予備処理とラインのラスタライズが不要になり、使用されるメモリ量が削減され、最も重要なことは、パフォーマンスがシーンのジオメトリの複雑さに依存することがなくなります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次の図は、境界までの距離の定義を示しています。各エッジについて、幾何学的シェーダーは最初に高さ<i>dを</i>計算し、次に軸方向距離<i>d <sub>xを</sub></i>計算します。 結果は頂点属性に格納され、ラスタライザーによって補間され、ピクセルシェーダーのブレンド係数の計算に使用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/75e/03a/09875e03ad8246adcec106f2d1caa9b4.png" alt="GBAA距離の計算"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      GPAAに対する追加の利点は、幾何学的なエッジだけでなく、距離を推定できる他の境界（たとえば、アルファ透明テクスチャの境界）のアンチエイリアスを実行できることです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f33/dd5/054/f33dd5054a78b520f319916eed8c2d5e.png" alt="GBAAアルファ透明度"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ピクセルシェーダーは、ジオメトリシェーダーの計算結果を使用して、ピクセルと交差するエッジを見つけます。 エッジへの最小オフセットがピクセルの半分未満の場合、隣接するピクセルが選択され、ブレンド係数が計算され、ブレンドが実行されます。 それ以外の場合、ピクセルは変更されません。 シルエットリブの変位に関する情報は、シルエットの内側にあるピクセルでのみ利用できるため、これらのピクセルには追加の処理が必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> オフセットは、隣接する4つのピクセルから選択されます。 </li><li> オフセットに応じて、4つの近傍の1つが選択されます（オフセットが現在のピクセルに向かう方向に対応するもの）： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -左：0.5 &lt;= offset.x &lt;= 1.0 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -右：-1.0 &lt;= offset.x &lt;= -0.5 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -上：0.5 &lt;= offset.y &lt;= 1.0 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -下限：-1.0 &lt;= offset.y &lt;= -0.5 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li> 選択したオフセットから、現在のピクセルの調整されたオフセットが取得されます。その後、係数を計算してブレンドを実行するためだけに残ります。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">シェーダーコード（HLSL）</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">struct PsIn { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_Position; float2 TexCoord : TexCoord; }; [Vertex shader] PsIn main(uint VertexID : SV_VertexID) { // Produce a fullscreen triangle PsIn <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.x = (VertexID == <span class="hljs-number"><span class="hljs-number">0</span></span>)? <span class="hljs-number"><span class="hljs-number">3.0</span></span>f : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.y = (VertexID == <span class="hljs-number"><span class="hljs-number">2</span></span>)? <span class="hljs-number"><span class="hljs-number">3.0</span></span>f : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.zw = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.TexCoord = <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.xy * float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>f) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; } [Fragment shader] Texture2D BackBuffer; Texture2D &lt;float2&gt; GeometryBuffer; SamplerState Linear; SamplerState <span class="hljs-type"><span class="hljs-type">Point</span></span>; float2 PixelSize; <span class="hljs-type"><span class="hljs-type">float4</span></span> main(PsIn <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>) : SV_Target { float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = GeometryBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord); // <span class="hljs-keyword"><span class="hljs-keyword">Check</span></span> geometry buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> an edge cutting through the pixel. [flatten] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min(abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x), abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)) &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) { // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> edge was <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> we look <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> neighboring pixels<span class="hljs-string"><span class="hljs-string">' geometry information. This is necessary because // relevant geometry information may only be available on one side of an edge, such as on silhouette edges, // where a background pixel adjacent to the edge will have the background'</span></span>s geometry information, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> // the foreground<span class="hljs-string"><span class="hljs-string">'s geometric edge that we need to antialias against. Doing this step covers up gaps in the // geometry information. offset = 0.5f; // We only need to check the component on neighbor samples that point towards us float offset_x0 = GeometryBuffer.Sample(Point, In.TexCoord, int2(-1, 0)).x; float offset_x1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 1, 0)).x; float offset_y0 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, -1)).y; float offset_y1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, 1)).y; // Check range of neighbor pixels'</span></span> distance <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> use <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> edge cuts this pixel. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_x0 - <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(offset_x0 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); // Left x-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [ <span class="hljs-number"><span class="hljs-number">0.5</span></span> .. <span class="hljs-number"><span class="hljs-number">1.0</span></span>] cuts this pixel <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_x1 + <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(offset_x1 + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); // Right x-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [<span class="hljs-number"><span class="hljs-number">-1.0</span></span> .. <span class="hljs-number"><span class="hljs-number">-0.5</span></span>] cuts this pixel <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_y0 - <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, offset_y0 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); // Up y-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [ <span class="hljs-number"><span class="hljs-number">0.5</span></span> .. <span class="hljs-number"><span class="hljs-number">1.0</span></span>] cuts this pixel <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_y1 + <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, offset_y1 + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); // Down y-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [<span class="hljs-number"><span class="hljs-number">-1.0</span></span> .. <span class="hljs-number"><span class="hljs-number">-0.5</span></span>] cuts this pixel } // Convert distance <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> texture coordinate shift float2 <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &gt;= float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))? float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) : float2(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>; // Blend pixel <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> neighbor pixel <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> texture filtering <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> shifting the coordinate appropriately. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BackBuffer.Sample(Linear, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord + <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> * PixelSize); }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 修正 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      GBAAには不快な機能があり、収束するエッジ付近のアーチファクトで表現されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/680/ac4/bc8/680ac4bc88b430c40d29dd1029a27fd9.png" alt="GBAAアーティファクト"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     細いサブピクセルの三角形は、画面解像度で画像を操作するすべてのポストフィルタリングアルゴリズムの問​​題の原因であり、残念ながらGBAAも例外ではありません。 問題のあるケースでアンチエイリアスの品質を改善するために、これらのアーティファクトのメカニズムを理解し、元のアルゴリズムを変更しようとしました。 最初のケースを考えます： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ba/b0a/71e/7bab0a71edaeab5f83cc4cab86fd7e4c.png" alt="GBAAアーティファクト1"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここで、中央の現在のピクセルのサンプリングポイントは細い三角形の内側になり、左右のピクセルのサンプリングポイントは細い三角形に隣接する大きな三角形になります。 写真に示すように、細い三角形の右端が中央のピクセルの中心に近い場合、GBAAは、中央に対する右端のオフセットに基づいて、中央のピクセルで直角三角形のカバレッジを決定し、中央と右のピクセルの間に線形補間された色を生成します。 ただし、中央のピクセルは一度に3つの三角形のフラグメントをカバーし、少なくとも1つのピクセルの色が他のピクセルと異なる場合、結果の色は誤って決定されます。  <i>a</i> 、 <i>b</i> 、 <i>c</i>を3つのピクセルの初期色とし、 <i>α</i> 、 <i>β</i> 、 <i>γを</i>中央のピクセルで覆われた三角形の断片の面積とピクセル面積<i>の</i>比とします。 この場合の中央のピクセルの調整色は、式によって決定できます 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>b <sub>out</sub> =αa+βb+γc</i> 、 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     元のアルゴリズムは式によってそれを計算しますが 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>b <sub>out</sub> =（α+β）b +γc</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     たとえば、左のピクセルが白で、中央と右のピクセルが黒の場合、前述の状況では、元のアルゴリズムは中央のピクセルに常に黒を生成し、元の画像の断片を変更しません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2番目のケースは、細い三角形が2つのピクセルの中心の間にある場合に発生します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f21/2e3/771/f212e37710c624f8825906ad1f6dbc07.png" alt="GBAAアーティファクト2-例1"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここでは、最初の場合とは異なり、正しい色を計算するために必要な情報の一部が失われます。細い三角形の中に収まるサンプリングポイントはありません。 そのような場合が最終画像にどのように影響するかを理解するために、より大きなフラグメントを考えてみましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e14/5a9/d93/e145a9d937d8017cbd2e2e82abfb628b.png" alt="GBAAアーティファクト2-例2"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     右に移動すると、暗い三角形が上に移動し、さらに小さな領域を占めるため、上の行のピクセルの輝度が増加します。 これは、キューが最後の列に達するまで発生します。 処理中に発生するケースは以前に考慮されています。 ここで、最初の2列が問題の主な原因です。上のピクセルは元の色を取得する必要がありますが、代わりに元のアルゴリズムはそれらを下のピクセルの色と混合します。 左側は間違ったブレンド係数を使用して取得された三角形の境界の断片であり、右側は正しい結果です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/882/558/e87882558166d23e4392c9fc96174f38.png" alt="GBAAアーティファクト2の結果"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この場合、元のアルゴリズムの動作は、薄い三角形の間にあるピクセルの元の色を保持することで改善できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらの2つのケースを処理するために、元のアルゴリズムにいくつかの変更を加えることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 最初の場合のピクセルの色を正しく計算するには、2番目のオフセットに関する情報が必要ですが、元のアルゴリズムでは1つしか保存されません。 これには、ジオメトリバッファに追加のスペースが必要です。  1つ目と同じ軸に沿って2つ目のオフセットがあり、その反対側にある場合は、このオフセットもジオメトリバッファーに格納する必要があります。 後処理段階で、トリプルカバレッジのケースを判断するには、ピクセルが異なる側面の2つのエッジと交差するかどうかを確認し、交差する場合は、補正された色を計算する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  2番目のケースの処理は、アルゴリズムの構造に最小限の影響しか与えないため、後処理段階で追加の検証を導入する必要があります。 隣接するピクセルが同じ軸のオフセットの反対方向に対応する対応するオフセットの方向にある場合、ピクセルは元の色を取得する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">シェーダーコード（HLSL）</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">struct PsIn { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_Position; float2 TexCoord : TexCoord; }; [Vertex shader] PsIn main(uint VertexID : SV_VertexID) { // Produce a fullscreen triangle PsIn <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.x = (VertexID == <span class="hljs-number"><span class="hljs-number">0</span></span>)? <span class="hljs-number"><span class="hljs-number">3.0</span></span>f : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.y = (VertexID == <span class="hljs-number"><span class="hljs-number">2</span></span>)? <span class="hljs-number"><span class="hljs-number">3.0</span></span>f : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.zw = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.TexCoord = <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.xy * float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>f) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; } [Fragment shader] Texture2D BackBuffer; Texture2D &lt;float2&gt; GeometryBuffer; Texture2D &lt;<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; InvGeometryBuffer; SamplerState Linear; SamplerState <span class="hljs-type"><span class="hljs-type">Point</span></span>; float2 PixelSize; <span class="hljs-type"><span class="hljs-type">int</span></span> Tweak; <span class="hljs-type"><span class="hljs-type">int</span></span> ShowEdges; <span class="hljs-type"><span class="hljs-type">void</span></span> check_opposite_neighbor(float2 tex_coord, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> major <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> float2 <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-type"><span class="hljs-type">bool</span></span> x_major = abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x) &lt; abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x_major) <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = float2(sign(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, sign(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)); // <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> neighbor<span class="hljs-string"><span class="hljs-string">'s offset float2 opp_offset = GeometryBuffer.Sample(Point, tex_coord + off*PixelSize); // Make sure it is valid bool apply_offset = true; if (min(abs(opp_offset.x), abs(opp_offset.y)) &lt; 0.5f) { // Make sure it points towards current sample // if so - don'</span></span>t apply texture coordinate <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x_major) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sign(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x)!=sign(opp_offset.x) &amp;&amp; abs(opp_offset.x) &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sign(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)!=sign(opp_offset.y) &amp;&amp; abs(opp_offset.y) &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; } } } <span class="hljs-type"><span class="hljs-type">float4</span></span> main(PsIn <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>) : SV_Target { float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = GeometryBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord); <span class="hljs-type"><span class="hljs-type">bool</span></span> edge_found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-type"><span class="hljs-type">bool</span></span> triple_coverage = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> result; // <span class="hljs-keyword"><span class="hljs-keyword">Check</span></span> geometry buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> an edge cutting through the pixel. [flatten] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min(abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x), abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)) &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) { // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> edge was <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> we look <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> neighboring pixels<span class="hljs-string"><span class="hljs-string">' geometry information. This is necessary because // relevant geometry information may only be available on one side of an edge, such as on silhouette edges, // where a background pixel adjacent to the edge will have the background'</span></span>s geometry information, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> // the foreground<span class="hljs-string"><span class="hljs-string">'s geometric edge that we need to antialias against. Doing this step covers up gaps in the // geometry information. offset = 0.5f; // We only need to check the component on neighbor samples that point towards us float offset_x0 = GeometryBuffer.Sample(Point, In.TexCoord, int2(-1, 0)).x; float offset_x1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 1, 0)).x; float offset_y0 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, -1)).y; float offset_y1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, 1)).y; // Check range of neighbor pixels'</span></span> distance <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> use <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> edge cuts this pixel. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_x0 - <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(offset_x0 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); // Left x-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [ <span class="hljs-number"><span class="hljs-number">0.5</span></span> .. <span class="hljs-number"><span class="hljs-number">1.0</span></span>] cuts this pixel } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_x1 + <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(offset_x1 + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); // Right x-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [<span class="hljs-number"><span class="hljs-number">-1.0</span></span> .. <span class="hljs-number"><span class="hljs-number">-0.5</span></span>] cuts this pixel } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_y0 - <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, offset_y0 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); // Up y-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [ <span class="hljs-number"><span class="hljs-number">0.5</span></span> .. <span class="hljs-number"><span class="hljs-number">1.0</span></span>] cuts this pixel } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_y1 + <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, offset_y1 + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); // Down y-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [<span class="hljs-number"><span class="hljs-number">-1.0</span></span> .. <span class="hljs-number"><span class="hljs-number">-0.5</span></span>] cuts this pixel } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tweak) { <span class="hljs-type"><span class="hljs-type">float</span></span> inv_offset = InvGeometryBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inv_offset != <span class="hljs-number"><span class="hljs-number">0.0</span></span>f) { triple_coverage = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; // Sample two neighbors <span class="hljs-type"><span class="hljs-type">float</span></span> maj_offset; float2 <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x) &lt; abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)) { <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>.x = -sign(inv_offset); maj_offset = <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>.y = -sign(inv_offset); maj_offset = <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y; } <span class="hljs-type"><span class="hljs-type">float4</span></span> n1 = BackBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord + <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>*PixelSize); <span class="hljs-type"><span class="hljs-type">float4</span></span> n2 = BackBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord - <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>*PixelSize); // Calculate coverage <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> this sample (b) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> two neighbors (a, c) <span class="hljs-type"><span class="hljs-type">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f-abs(maj_offset); // a (n1) <span class="hljs-type"><span class="hljs-type">float</span></span> gamma = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f-abs(inv_offset); // c (n2) <span class="hljs-type"><span class="hljs-type">float</span></span> beta = <span class="hljs-number"><span class="hljs-number">1</span></span>-alpha-gamma; // b (this) // Blend final color result = alpha*n1 + beta*BackBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord) + gamma*n2; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> check_opposite_neighbor(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShowEdges &amp;&amp; edge_found) result = <span class="hljs-type"><span class="hljs-type">float4</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!triple_coverage) { // Convert distance <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> texture coordinate shift float2 <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &gt;= float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))? float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) : float2(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>; // Blend pixel <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> neighbor pixel <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> texture filtering <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> shifting the coordinate appropriately. result = BackBuffer.Sample(Linear, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord + <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> * PixelSize); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> テスト </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アンチエイリアスの品質を比較するために、元のGBAAが顕著なアーティファクトを生成したシーンのフラグメントが選択されました。 次に、各フラグメントについて、カメラの位置が固定され、4つのスクリーンショットが保存されました。元の画像、強調表示されたエッジを含む元の画像、GBAAの結果、および変更されたGBAAの結果です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/951/27b/b45/95127bb45a1f908d2266c1418fb9c0f9.png" alt="結果-1"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2db/9b9/8ed/2db9b98ed46c7d87dd0ad1e51e01fc33.png" alt="結果-2"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca0/fbe/014/ca0fbe014d76782a3517019697693362.png" alt="結果-3"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/45f/fe8/44545ffe85f6a746e653a9b10e8cb879.png" alt="結果-4"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     エッジが収束するフラグメントの品質はまだ理想的ではありませんが、それらのアーチファクトは目立たなくなりました。 複雑なテクスチャのシーンは、残余効果をよくマスクします。 達成された品質改善は、生産性の低下を犠牲にして得られます。 元のGBAAの後処理段階が1920x1080の解像度で0.14ミリ秒かかった場合、修正されたアルゴリズムは0.22ミリ秒を必要とし、57％増加します。 ただし、このレベルのパフォーマンスでさえ満足のいくものであり続け、MLAAとその修正は残されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> おわりに </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ピクセルシェーダーの分岐を最適化するためにあまり努力しなかったことに注意する必要があります。これにより、パフォーマンスが向上する可能性があります。  <abbr title="グラフィックスコアネクスト">GCN</abbr>などの新しいGPUアーキテクチャ<a href="https://michaldrobot.com/2014/05/12/low-level-optimizations-for-gcn-digital-dragons-2014-slides/">は、ピクセルシェーダー</a>で<a href="https://michaldrobot.com/2014/05/12/low-level-optimizations-for-gcn-digital-dragons-2014-slides/">頂点属性を読み取る機能を提供し</a>ます。これにより、ジオメトリシェーダーを使用せずにアルゴリズム（元のアルゴリズムと変更されたアルゴリズムの両方）を実装し、それに関連するオーバーヘッドを排除できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     コンパイルされたバイナリとソースは<a href="https://github.com/nitrocaster/gbaa-plus">GitHubで</a>入手でき<a href="https://github.com/nitrocaster/gbaa-plus">ます</a> 。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J307354/index.html">すべてのプログラマは、OOPの作成者を除き、C ++がOOPをサポートしていると考えています</a></li>
<li><a href="../J307356/index.html">SDNおよびNFVへのネットワークの進化</a></li>
<li><a href="../J307358/index.html">最小限の費用でicinga2のマイクロモニタリングを引き上げます</a></li>
<li><a href="../J30736/index.html">BarCamp中央アジア。 イベントレポート</a></li>
<li><a href="../J307360/index.html">.Net Native VKによる1Cの非同期プログラミング</a></li>
<li><a href="../J307368/index.html">AIモンスターとヒートマップを使用したパスの検索</a></li>
<li><a href="../J307372/index.html">Cremes-新しい高度なサイバースパイマルウェア</a></li>
<li><a href="../J307374/index.html">.clearfixの代替</a></li>
<li><a href="../J307378/index.html">型破りなマッピングについて少し</a></li>
<li><a href="../J30738/index.html">LogitechのApple用の新しいキーボード</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>