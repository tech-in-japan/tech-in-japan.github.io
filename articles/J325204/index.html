<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍸 👲🏻 👰🏾 macOS上のDelphiでObjective-Cのコードブロックを使用する：ブリッジの構築方法 👨🏾‍🏫 👨🏿‍🏫 🍀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="おそらく、ゴム製のアヒルのデバッグ方法と呼ばれるプログラミングの問題を解決する素晴らしい方法を聞いたことがあるでしょう。 この方法の本質は、トイレに座って、リラックスし、水におもちゃのアヒルを置いて、解決策が見つからない問題の本質を彼に説明することです。 そして、奇跡的に、そのような会話の後、解決策...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>macOS上のDelphiでObjective-Cのコードブロックを使用する：ブリッジの構築方法</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/325204/"><p><img src="https://habrastorage.org/getpro/habr/post_images/02d/df6/357/02ddf63577545394ade5204bb053acbe.jpg" alt="画像"></p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> おそらく<a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D1%2583%25D1%2582%25D1%2591%25D0%25BD%25D0%25BA%25D0%25B0">、</a>ゴム製のアヒルのデバッグ<a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D1%2583%25D1%2582%25D1%2591%25D0%25BD%25D0%25BA%25D0%25B0">方法</a>と呼ばれるプログラミングの問題を解決する素晴らしい方法を聞いたことがあるでしょう。 この方法の本質は、トイレに座って、リラックスし、水におもちゃのアヒルを置いて、解決策が見つからない問題の本質を彼に説明することです。 そして、奇跡的に、そのような会話の後、解決策が見つかりました。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  <a href="https://habrahabr.ru/post/319922">Habrに関する前回の記事では</a> 、macOS用のWi-Fiネットワークを検査するプログラムの開発について話しましたが、Habrがアヒルの子であることが判明しました。DelphiのObjective-Cからコードブロックを実装する方法を考え出すことができなかった。 そしてそれは助けた！ 啓発が来て、それはすべてうまくいきました。 思考の流れと最終結果についてお伝えしたいと思います。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>したがって、前の記事を読んでいない人のために、もう一度問題の本質を簡単に概説してください。  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">コード下ブロック</a> - C ++、及びDelphiでサポートされていないのObjective-Cの言語機能。 より正確には、Delphiはその対応のコードブロックを持っていますが、それは私達のMacOS用APIの各1から期待するコードブロック、と互換性がありません。 実際、多くのクラスには、完了ハンドラーとしてコードブロックを使用する関数があります。 最も単純な例- <a href="https://developer.apple.com/reference/appkit/nssavepanel/1527007-beginwithcompletionhandler%3Flanguage%3Dobjc">beginWithCompletionHandler</a>クラス<code>NSSavePanel</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    と<code>NSOpenPanel</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     。 送信されたコードブロックは、ダイアログが閉じたときに実行されます。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">IBAction</span></span>)openExistingDocument:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender { <span class="hljs-built_in"><span class="hljs-built_in">NSOpenPanel</span></span>* panel = [<span class="hljs-built_in"><span class="hljs-built_in">NSOpenPanel</span></span> openPanel]; <span class="hljs-comment"><span class="hljs-comment">// This method displays the panel and returns immediately. // The completion handler is called when the user selects an // item or cancels the panel. [panel beginWithCompletionHandler:^(NSInteger result){ if (result == NSFileHandlingPanelOKButton) { NSURL* theDoc = [[panel URLs] objectAtIndex:0]; // Open the document. } }]; }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> アヒルの子と話した後、私は間違った終わりから問題に近づいていることに気付きました。 確かに、この問題はDelphiだけに存在するわけではありません。 したがって、他の言語での問題の解決方法から始める必要があります。  Googleの手、そして私たちは、非常に近いPythonとJavaScriptのための私達のトピックコードにある<a href="https://github.com/jsbain/objc_hacks/blob/master/objcblock.py">ここ</a>と<a href="https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes/Examples/Using_Objective-C_from_js-ctypes">ここ</a> 。 良いスタート：彼らが成功すれば、我々は成功するでしょう。 実際には、我々は、フィールドだけで、正しい形式で塗りつぶしを構造を作成する必要があり、そのような構造体へのポインタで、それによって魔法のランプ、私たちは、私たちはブロックするように期待し、これらのクラスのメソッドのMacOSの、渡すことができるようになりますことを。 もう少しGugleniya、我々は見つける<a href="">ヘッダー</a>アップルのサイト上に： </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block_descriptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reserved; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*copy)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *dst, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *src); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*dispose)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block_layout</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *isa; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reserved; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*invoke)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *, ...); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block_descriptor</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">descriptor</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// imported variables };</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> パスカルでそれを述べています： </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"> Block_Descriptor = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PBlock_Literal = ^Block_Literal;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> 今、ブロックのビットを読み出す（後<a href="https://www.cocoawithlove.com/2009/10/how-blocks-are-implemented-and.html">ブロックが実装されている方法</a>とHabré、 <a href="https://habrahabr.ru/post/271255/">Objective-Cの：両方の作業単位</a> ）最も単純な実施例においては、我々は膝で、確立をブロックするように進みます。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">Var</span></span> OurBlock: Block_Literal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlock</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FillChar(OurBlock, SizeOf(Block_Literal), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Isa –    -,      //    , "NSBlock". OurBlock.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); //    .    cdecl,    . OurBlock.Invoke := @InvokeCallback; //    Block_Descriptor New(aDesc); aDesc.Reserved := 0; //   aDesc.Size := SizeOf(Block_Literal); OurBlock.Descriptor := aDesc; result:= @OurBlock; end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ILocalobjectとして'NSBlock'））.GetObjectID）。 <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">Var</span></span> OurBlock: Block_Literal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlock</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FillChar(OurBlock, SizeOf(Block_Literal), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Isa –    -,      //    , "NSBlock". OurBlock.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); //    .    cdecl,    . OurBlock.Invoke := @InvokeCallback; //    Block_Descriptor New(aDesc); aDesc.Reserved := 0; //   aDesc.Size := SizeOf(Block_Literal); OurBlock.Descriptor := aDesc; result:= @OurBlock; end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> フィールド<code>flags</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    我々は簡単にするために予備ゼロを行います。 後で便利になります。 今のところ、空のコールバック関数を宣言する必要があります。 コールバック関数への最初の引数は、のインスタンスへのポインタである<code>NSBlock</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、および他のパラメータのリストは、コードブロックの原因となりココアクラスの特定の方法に依存します。 上記の例では、と<code>NSSavePanel</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、タイプの単一の引数を持つプロシージャ<code>NSInteger</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     。 それでは、初心者向けに書きましょう。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer; i1: NSInteger)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> 重要な瞬間、ゴールで撃った： </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"> FSaveFile := TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; objc_msgSendP2( (FSaveFile <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID, sel_getUid(PAnsiChar(<span class="hljs-string"><span class="hljs-string">'beginSheetModalForWindow:completionHandler:'</span></span>)), (NSWin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID, CreateBlock );</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     。 <code class="delphi hljs"> FSaveFile := TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; objc_msgSendP2( (FSaveFile <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID, sel_getUid(PAnsiChar(<span class="hljs-string"><span class="hljs-string">'beginSheetModalForWindow:completionHandler:'</span></span>)), (NSWin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID, CreateBlock );</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ：'））、 <code class="delphi hljs"> FSaveFile := TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; objc_msgSendP2( (FSaveFile <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID, sel_getUid(PAnsiChar(<span class="hljs-string"><span class="hljs-string">'beginSheetModalForWindow:completionHandler:'</span></span>)), (NSWin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID, CreateBlock );</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> ファイル保存ダイアログが開き、[OK]または[キャンセル]を押して...はい！ 私たちは、に設定されているポイント、破るために取得<code>Sleep(0)</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    およびはい、引数<code>i1</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、我々がクリックされたダイアログ内のどのボタンに応じて、0または1のどちらかになります。 勝利！ アヒルの子と私は幸せですが、多くの仕事があります。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> コールバック引数の数とタイプは異なる場合があります。 最も人気のある特定のセットがありますが、柔軟性が必要です。 </li><li> 多数のコードブロックを同時に動作させることができます。 例えば、我々は完了のためのコール完了ハンドラを使用してファイルをダウンロードして、並行して、オープンしてファイル保存ダイアログを閉じることができます。 まず、2番目に作成したブロックコードが機能し、ファイルがダウンロードされると、最初のブロックコードが機能します。 記録を残しておくといいでしょう。 </li><li> 何らかの方法でコールバックの原因となったブロックを特定し、このブロックに対応するDelphiコードを呼び出す必要があります。 </li><li> それはすべての利便性と美しさを失わずに匿名のデルファイの方法とコードブロックの間の橋渡しをするために素晴らしいことです。 次のような呼び出しをお願いします。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs">SomeNSClassInstance.SomeMethodWithCallback ( Arg1, Arg2, TObjCBlock.CreateBlockWithProcedure( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: NSInteger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p1</span></span></span><span class="hljs-function"> = 0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowMessage</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Cancel'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">else</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowMessage</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'OK'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) );</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> コールバックビューから始めましょう。 明らかに、最も簡単で信頼性の高い方法は、関数の種類ごとにコールバックを作成することです。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer; p1: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer; p1, p2: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback3</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer; p1, p2, p3: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> などなど。 しかし、どういうわけか退屈でエレガントではないでしょうか？ したがって、思考はさらに私たちを導く。 あなたは、コールバックの一種類のみを宣言した場合、必要な数の引数を読んで、スタックを引数とクロールの番号を知るために、コールバックを引き起こしたユニットの識別情報をキャプチャしますか？ </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, ArgNum: integer; p: PByte; Args: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> i:= FindMatchingBlock(aNSBlock); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p:= @aNSBlock; Inc(p, Sizeof(pointer)); <span class="hljs-comment"><span class="hljs-comment">//      ArgNum:= GetArgNum(...); if ArgNum &gt; 0 then begin SetLength(Args, ArgNum); Move(p^, Args[0], SizeOf(pointer) * ArgNum); end; ... end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> いい考え？ いいえ、悪いです。 これは、32ビットのコードで動作しますが、64ビットコードにはCDECLが起こらないいないため、64ビットで地獄にクラッシュしますが、一つの共通の呼び出し規約、CDECLとは異なり、引数なしでは、スタック内にあり、しかしプロセッサのレジスタに。 それでは、さらに簡単に、次のようなコールバックを宣言します。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock, p1, p2, p3, p4: pointer)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> そして、必要なだけの引数を読みます。 残りの引数にはゴミがありますが、それらには対処しません。 また、コードブロックで結果が必要な場合に備えて、プロシージャを機能するように変更しました。 免責事項：このアプローチの安全性がわからない場合は、個々のコールバック関数の種類ごとに使用しています。 アプローチはかなり安全だと思うが、彼らが言うように、好みは異なる。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> 識別部に関しては、すべての非常に簡単であることが判明： <code>aNSBlock</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    コールバックへの最初の引数として、私たちに来て、まったく同じ示し<code>Descriptor</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、我々は、作成時にブロックを割り当てます。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> 今、あなたは、異なる種類の匿名メソッドを行うことができ、私たちは教室のMacOSの中で実際に発生する、引数の可能なセットの90％をカバーし、我々は常にリストを展開することができます： </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithCFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc1)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc2)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc3)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc4)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc5)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc6)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc7)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、PT3、PT4、PT5、PT6、PT7）。 <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithCFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc1)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc2)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc3)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc4)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc5)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc6)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc7)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ; CONST ATYPE：TProcType）：ポインタ。 <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithCFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc1)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc2)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc3)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc4)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc5)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc6)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc7)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> したがって、例えば、二つの引数のサイズであり、手順の作成部<code>SizeOf(pointer)</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、次のようになります。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc3)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）：ポインタ。 <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc3)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）、TProcType.pt3）。 <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc3)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  CreateBlockWithCFuncは次のようになります。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithCFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:= BlockObj.AddNewBlock(aTProc, aType); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ; CONST ATYPE：TProcType）：ポインタ。 <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithCFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:= BlockObj.AddNewBlock(aTProc, aType); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> そうです。 我々はBlockObj、シングルトンクラスのインスタンスにアピール<code>TObjCBlockList</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    すべてこの経済を管理するために必要とされ、ユニット利用可能外ではありません。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"> TBlockInfo = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PBlockInfo = ^TBlockInfo; <span class="hljs-title"><span class="hljs-title">TObjCBlockList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> (TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FBlockList: TArray&lt;TBlockInfo&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearAllBlocks</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindMatchingBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCurrBlock: pointer)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> BlockList: TArray&lt;TBlockInfo&gt; <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FBlockList ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> BlockObj: TObjCBlockList;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> 私たちのクラスの「心」はここで勝ちます： </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlockList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BLOCK_HAS_COPY_DISPOSE = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//           SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); //      FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; //  ,       . , //  copy  displose. ?   . FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; //         : FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); //   -: aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     CONST ATYPE：TProcType）：ポインタ。 <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlockList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BLOCK_HAS_COPY_DISPOSE = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//           SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); //      FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; //  ,       . , //  copy  displose. ?   . FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; //         : FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); //   -: aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ]にSizeOf（TBlockInfo）、 <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlockList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BLOCK_HAS_COPY_DISPOSE = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//           SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); //      FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; //  ,       . , //  copy  displose. ?   . FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; //         : FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); //   -: aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     BlockStructure.Isa：= NSClassFromString（（StrToNSStr（ 'NSBlock'） <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlockList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BLOCK_HAS_COPY_DISPOSE = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//           SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); //      FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; //  ,       . , //  copy  displose. ?   . FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; //         : FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); //   -: aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ：= @InvokeCallback ;. <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlockList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BLOCK_HAS_COPY_DISPOSE = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//           SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); //      FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; //  ,       . , //  copy  displose. ?   . FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; //         : FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); //   -: aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     BlockStructure.Flags：= BLOCK_HAS_COPY_DISPOSE。 <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlockList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BLOCK_HAS_COPY_DISPOSE = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//           SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); //      FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; //  ,       . , //  copy  displose. ?   . FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; //         : FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); //   -: aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> まあ、すべての基本を書きました。 わずかな微妙な点のみが残っています。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> まず、異なるスレッドのクラスインスタンスを操作できるように、スレッドセーフを追加する必要があります。 それは非常に単純であり、適切なコードを追加しました。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> 第二に、私たちは知る必要があり、作成した構造を最終的に「ネイル」することができます。 配列要素<code>FBlockList</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     。 一見すると、それはすぐにシステムがコールバックを起こしているようとして、ユニットを除去することができるようです： - さんが行われ、すべてのファイルをロードし、完了ハンドラーと呼ばれていました。 実際、これは常にそうではありません。 何度でも呼び出されるブロックがあります。 例えば、この方法では<a href="https://developer.apple.com/reference/appkit/nsimage/1519860-imagewithsize">imageWithSize：ひっくり返さ：drawingHandler：</a>クラス<code>NSImage</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    万回を発生することが、あなたが知っているように、という絵を描きますブロックへのポインタを渡す必要があります。 それは私たちが便利になることをここにある<code>aDesc.dispose_helper := @DisposeCallback</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     。 プロシージャコール<code>DisposeCallback</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    ちょうどユニットがもはや必要ないことを通知します、あなたが安全に削除することができます。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3 id="vishenka-na-torte"> ケーキの上のチェリー </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> そして、同じユニットでセルフテストを書きましょうか？ コンパイラの次のバージョンまたは64ビットに切り替えると、突然何かが壊れます。  Cocoaクラスにアクセスせずにブロックをテストするにはどうすればよいですか？ これには、Delphiで次のように宣言する必要がある特別な低レベル関数があることがわかります。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">imp_implementationWithBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: id)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> libobjc <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> _PU + <span class="hljs-string"><span class="hljs-string">'imp_implementationWithBlock'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">imp_removeBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(anImp: pointer)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> libobjc <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> _PU + <span class="hljs-string"><span class="hljs-string">'imp_removeBlock'</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> 最初の関数は、引数として渡したブロックを呼び出すC関数へのポインターを返します。  2番目は単にメモリを「クリーン」にします。 我々は素晴らしいクラスの助けを借りて、ブロックを作成する必要がありますので[OK]を、それを渡す<code>imp_implementationWithBlock</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、ユニットが働いたかを確認するために受信したアドレスにして屏息で関数を呼び出します。 すべてをやろうとしています。 オプション1、 <strong>ナイーブ：</strong> </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelfTest</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; test: NativeUint; func : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( p1, p2, p3, p4: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> test:= <span class="hljs-number"><span class="hljs-number">0</span></span>; p:= TObjCBlock.CreateBlockWithProcedure( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1, p2, p3, p4: pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">:</span></span>= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); @func := imp_implementationWithBlock(p); func(pointer(<span class="hljs-number"><span class="hljs-number">1</span></span>), pointer(<span class="hljs-number"><span class="hljs-number">2</span></span>), pointer(<span class="hljs-number"><span class="hljs-number">3</span></span>), pointer(<span class="hljs-number"><span class="hljs-number">4</span></span>)); imp_removeBlock(@func); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test &lt;&gt; (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception.Create(<span class="hljs-string"><span class="hljs-string">'Objective-C code block self-test failed!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> 起動して...おっと。  P1 = 1、P2 = 3、P3 = 4、P4 =デブリ：匿名メソッドに陥ります。 なに...？ 誰がデュースを食べましたか？ そして、最後のパラメーターのゴミはなぜですか？ これは、という事実が判明し<code>imp_implementationWithBlock</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    あなたのようにブロックを呼び出すことができますトランポリン、返す<code>IMP</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     。 問題は、ある<code>IMP</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    のObjective-Cには常に2つの最初の引数、必要としていた<code>(id self, SEL _cmd)</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    すなわち オブジェクトおよびセレクターへのポインター、およびコードブロックの最初に必要な引数は1つだけです。 引数のリスト編集を呼び出すときにトランポリンが返さ：第二引数は<code>_cmd</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、不要として捨て、その場所に最初の引数を書かれているが、最初の引数の代わりにへのポインタを代入する<code>NSBlock</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> はい、このように、トランポリンは気付かれずに忍び寄りました。 さて、第二の選択肢、 <strong>右：</strong> </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelfTest</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; test: NativeUint; func : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( p1, _cmd, p2, p3, p4: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> test:= <span class="hljs-number"><span class="hljs-number">0</span></span>; p:= TObjCBlock.CreateBlockWithProcedure( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1, p2, p3, p4: pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">:</span></span>= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); @func := imp_implementationWithBlock(p); <span class="hljs-comment"><span class="hljs-comment">// , _cmd  ! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end;</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p> これですべてがスムーズになり、ブロックの操作を楽しむことができます。 ユニット全体をダウンロードすることができ<a href="">、ここで</a>以下閲覧します。 コメント（「記憶、ここにあなたの記憶が流れている」）と改善のための提案を歓迎します。 </p>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">完全なソースコード</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、いかなる種類の保証もなく、明示または <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     商品性の保証、 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     請求、損害またはその他の <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、不法行為もしくはその他から生じます、 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     .Wnd。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     completionHandler：'））、 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、PT3、PT4、PT5、PT6、PT7）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ; CONST ATYPE：TProcType）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     、P3、P4：ポインタ）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     .LocProc）（）; <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     .LocProc）（P1）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     .LocProc）（P1、P2）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     .LocProc）（P1、P2、P3）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     .LocProc）（P1、P2、P3、P4）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     .LocProc）（NSinteger（P1））。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     [I] .LocProc）（aRect））。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）、TProcType.pt1）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）、TProcType.pt2）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）、TProcType.pt6）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）、TProcType.pt7）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ; CONST ATYPE：TProcType）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）; <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     P2、P3、P4：ポインタ）。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     コードブロックのセルフテストが失敗しました！'）; <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     CONST ATYPE：TProcType）：ポインタ。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ]にSizeOf（TBlockInfo）、 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     BlockStructure.Isa：（ILocalobjectとして（StrToNSStr（ 'NSBlock'））.GetObjectID）= NSClassFromString。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ：= @InvokeCallback ;. <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     BlockStructure.Flags：= BLOCK_HAS_COPY_DISPOSE。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ：= aDesc ;. <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ）] BlockStructure ;. <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     ：整数。 <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     （aCurrBlock）.Descriptor <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> </div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J325192/index.html">サービスHostTrackerのビデオレビュー</a></li>
<li><a href="../J325196/index.html">Cisco Unified Wireless実装のCAPWAPステートマシン：検出状態</a></li>
<li><a href="../J325198/index.html">Qt：Embedded World 2017とロードマップ</a></li>
<li><a href="../J325200/index.html">従業員と会社間の会話：方法と理由</a></li>
<li><a href="../J325202/index.html">DirectX 12のPIXグラフィカルデバッガーの生まれ変わり</a></li>
<li><a href="../J325206/index.html">オンライン教育における推薦システム。 適応学習</a></li>
<li><a href="../J325216/index.html">大規模なクラスターでのデータ損失の確率</a></li>
<li><a href="../J325218/index.html">「エリクシル入門」-ロシア語のエリクシルに関する最初の本</a></li>
<li><a href="../J325220/index.html">最初のPhaserゲームを作成します。 パート2-リソースの読み込み</a></li>
<li><a href="../J325222/index.html">ダイジェストに行きます。 Goの世界のイベント、記事、興味深いプロジェクト[2017年3月15〜30日]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>