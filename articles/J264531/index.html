<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✡️ 🚞 ⛓️ アプリケーションプログラマ向けのASRおよびTTSテクノロジ：理論上の最小値 🥣 👷🏻 💋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="はじめに  
  
 過去数年にわたり、音声インターフェースはますます私たちを取り囲んでいます。 かつて映画でしか見られなかった遠い未来についての話は、実在するものでした。 携帯電話での音声の合成（Text To Speech-TTS）および認識（自動音声認識-ASR）のためのエンジンの埋め込みはす...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>アプリケーションプログラマ向けのASRおよびTTSテクノロジ：理論上の最小値</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/264531/"><h3> はじめに </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     過去数年にわたり、音声インターフェースはますます私たちを取り囲んでいます。 かつて映画でしか見られなかった遠い未来についての話は、実在するものでした。 携帯電話での音声の合成（Text To Speech-TTS）および認識（自動音声認識-ASR）のためのエンジンの埋め込みはすでに行われています。 さらに、アプリケーションにASRとTTSを埋め込むための非常にアクセスしやすいAPIが登場しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これで、誰でも音声インターフェイスを備えたプログラムを作成できるようになります（エンジンの費用を支払うのに苦労しません）。 このレビューは、特に既存のエンジン（たとえば、Nuance）の使用に専念し、それらの作成には専念しません。 また、最初に音声インターフェイスに遭遇した各プログラマに必要な一般情報も提供されます。 この記事は、音声テクノロジーを自社製品に統合することの実現可能性を評価しようとするプロジェクトマネージャーにとっても役立つ場合があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それでは始めましょう... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、種のために-冗談： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     グルジア語学校でのロシア語レッスン。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     先生は次のように述べています。「子供たち、覚えておいてください。塩、豆、麺という言葉はソフトサインで、フォーク、バルク、プレートという言葉はソフトサインなしで書かれています。 子どもたち、覚えて、理解するのは不可能だから！」 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この冗談は、私にはとんでもないように見えました。 今-むしろ人生。 なぜそう 今、私は説明しようとします... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  1.音素 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スピーチと言えば（すでにばかげている）、まず音素の概念に対処する必要があります。 簡単に言えば、音素は、人が発音および認識できる独立した音です。 しかし、この定義は確かに十分ではありません。多くの音を発音することができ、言語の音素のセットが限られているためです。 もっと厳密に定義したいと思います。 だから-あなたは言語学者に行く必要があります。 悲しいかな、言語学者自身はそれが何であるかについて同意することはできません（そして彼らは本当にそれを必要としません）が、彼らはいくつかのアプローチを持っています。 音素と意味を結び付けます。 たとえば、英語版のWikiは、「意味の変化をもたらす可能性のある、対照的な最小の言語単位」と語っています。 知覚を持つ他の人。 そこで、私たちの同胞<a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D1%2583%25D0%25B1%25D0%25B5%25D1%2586%25D0%25BA%25D0%25BE%25D0%25B9,_%25D0%259D%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25BB%25D0%25B0%25D0%25B9_%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B3%25D0%25B5%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2587">N. Trubetskoy</a>は「音韻単位、この言語の観点から次々と続く短い音韻単位に分解できない音素単位」と書いています。 そして、それと別の定義には、私たちにとって重要な明確化があります。 一方では、音素を変更すると、単語の意味を変更することができます（そうする必要はありません）。 したがって、「コード」と「猫」は2つの異なる単語として認識されます。 一方、「museum」または「muse」と言っても意味は変わりません。 あなたの対談者がどういうわけかあなたのアクセントを分類することができるということは可能ですか？ 音素の不可分性も重要です。 しかし、Trubetskoyが正しく指摘したように、言語に依存する可能性があります。  1つの国籍の人が1つの音を聞く場合、他の人は2つの音を次々と聞くことができます。 ただし、1つだけではなく、すべての言語に適した音声不変式が必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  2.音声アルファベット </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1888年に何らかの形で定義を確定するために、 <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B6%25D0%25B4%25D1%2583%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2584%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BB%25D1%2584%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2582">International Phonetic Alphabet</a> （IPA）が作成されました。 このアルファベットは、特定の言語に<b>依存しない</b>という点で優れて<b>い</b>ます。 つまり これは、ほとんどすべての既存の（さらには死んだ）言語の音を発音して認識することができる「スーパーマン」のために設計されています。 アルファベットIPAは、私たちの時代（2005年）まで徐々に変わりました。 それは主にコンピューター以前の時代に作成されたため、哲学者は神が魂を置くように音を示す記号を描いた。 もちろん、彼らはどういうわけかラテン系のアルファベットに焦点を合わせましたが、非常に、非常に条件付きで。 その結果、IPA文字はUnicodeで使用できるようになりましたが、キーボードから入力するのは簡単ではありません。 ここで読者は尋ねるかもしれません-なぜ人々はIPAを必要としますか？ 少なくとも発音どおりに綴られた単語の例はどこで見ることができますか？ 私の答えは、普通の人はIPAを知る必要がないということです。 しかし、これらすべてにより、地理名、姓、固有名に関連する多くのWiki記事で非常に簡単に見ることができます。  IPAを知っていれば、なじみのない言語で特定の名前の正しい発音をいつでも確認できます。 たとえば、フランス人として「パリ」と言いたいですか？ そこに行きます-[paʁi]。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  3.音声表記 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     気配りのあるウィキユーザーは、奇妙な表音アルファベットアイコンが角かっこ[mɐˈskva]の中にあること、時にはスラッシュの中にあることに気づくことができます-/ ˈlʌnd cann /。 違いは何ですか？ 角括弧で、いわゆる 狭い、または「狭い」転写。 国内文学では、音声と呼ばれます。 スラッシュでは、ブロードが書かれています。  「広範囲」または音素転写。 実用的な意味は次のとおりです。音声表記は非常に正確な発音を提供します。これはある意味で、話者のアクセントに関係なく理想的です。 言い換えれば、音声表記を使用すると、「Cockneyはこの単語をそのように発音します」と言うことができます。 音素転写はバリエーションを可能にします。 そのため、同じエントリが//にあるオーストラリア英語とカナダ英語の発音は異なる場合があります。 実際、狭い文字起こしでさえ簡単ではありません。 つまり  wawファイルからかなり離れています。 男性、女性、子供の声は同じ音素を異なる方法で発音する。 また、音声の一般的な速度、音量、および音声の基本ピッチは考慮されません。 実際、これらの違いにより、音声の生成と認識のタスクは重要です。 さらに本文では、特に明記されていない限り、狭い転写では常にIPAを使用します。 同時に、IPAの直接使用を最小限に抑えるようにします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  4.言語 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     生きている自然言語には、それぞれ独自の音素セットがあります。 より正確には、これはスピーチの特性です。一般的に言えば、言葉を発音することなく言語を知ることができるからです（聴覚障害者や愚かな者に言語を教える方法）。 アルファベットが異なるように、言語の音声構成は異なります。 したがって、言語の音声の複雑さも異なります。  2つのコンポーネントで構成されています。 第一に、書記素を音素に変換することの難しさ（英語では「マンチェスター」と「リバプール」を読むことを覚えています）と、音自体（音素）を発音するのが難しいことです。 通常、いくつの音素に言語が含まれていますか？ 数十個。 幼少期から、ロシア語の発音は3ペニーのように単純であり、ヨーロッパの言語とは対照的に、すべてが書かれたとおりに読まれることが教えられました。 もちろんだまされました！ 言葉が文字通りに書かれている通りに読んだ場合、彼らはあなたを理解しているが、常に真実であるとは限らない。 しかし、彼らは確かにロシア人を数えません。 さらに、ヨーロッパ人にとってストレスのような恐ろしいことが関係しています。 神が意味を変えながら魂を自分の魂に乗せるように、冒頭（英語のように）または末尾（フランス語のように）に置くのではなく、単語全体にわたって私たちと歩きます。  D <b>o</b> rogiとdor <b>o</b> giは2つの異なる単語であり、品詞ですらあります。 ロシア語の音素はいくつですか？  Nuanceには54個あります。 比較のために、英語では45音素、フランス語では34音音素しかありません。貴族が数世紀前に習得するのが簡単な言語だと考えていたのは無意味ではありませんでした！ もちろん、ロシア語はヨーロッパで最も難しい言語ではありませんが、そのうちの1つです（覚えておいてください、私はまだ文法について沈黙しています）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  5.X-SAMPAおよびLH + </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     人々が長い間キーボードから音声表記を導入したかったので、Unicodeが広く配布される前から、ASCIIテーブルの文字のみを使用できるようにする表記法が開発されました。 これらの最も一般的な2つは、John Wells教授の創作である<a href="https://en.wikipedia.org/wiki/X-SAMPA">X-SAMPA</a>と、 <a href="https://en.wikipedia.org/wiki/Lernout_%2526_Hauspie">Lernout＆Hauspieの</a>内部形式であるLH +であり、その技術は後にNuance Communicationsによって購入されました。  X-SAMPAとLH +にはかなり大きな違いがあります。 正式には、X-SAMPAは、特定の規則により、ASCIIのみを使用して同じIPA音素を記録できる表記法です。 もう1つはLH +です。 ある意味では、LH +は幅広い（音素的な）転写の類似体です。 実際には、各言語で、同じLH +記号が異なるIPA音素を示すことがあります。 一方で、それは良いことです。なぜなら、 レコードは短縮され、考えられるすべてのIPA文字をエンコードする必要はありませんが、一方、あいまいさが生じます。 また、IPAへの翻訳のたびに、連絡表を目の前に置いておく必要があります。 ただし、最も悲しいことは、特定の言語の「音声」のみがLH +で録音された行を正しく発音できることです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  6.投票 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     いいえ、過去に悪いコードを書きすぎたプログラマーが頭の中でよく耳にする声ではありません。 むしろ、ナビゲーターやその他のモバイルデバイスの所有者がトラッカーやファイルウォッシュで頻繁に検索する人についてです。 これらの声にも名前があります。  「Milena」と「Katerina」という言葉は、音声インターフェースの経験豊富なユーザーに多くのことを語っています。 これは何？ おおまかに言って、これらはコンピューターが音素を音に変換できるようにするさまざまな企業（Nuanceなど）によって準備されたデータセットです。 声は女性と男性であり、多くの費用がかかります。 プラットフォームと開発者によっては、音声ごとに2〜5000ドルを支払う必要がある場合があります。 したがって、少なくとも5つの最も一般的なヨーロッパ言語でインターフェースを作成したい場合、請求書は数万に達する可能性があります。 もちろん、私たちはソフトウェアインターフェースについて話している。 そのため、音声は言語固有です。 ここから音声表記への結合が始まります。 これを最初に実現するのは簡単ではありませんが、記事の冒頭の冗談は本当の真実です。  1つの母国語を持つ人々は、通常、母国語にない別の音素<b>を</b>発音<b>でき</b>ません。 さらに悪いことに、個々の音素だけでなく、それらの特定の組み合わせもあります。 したがって、あなたの言語で単語がソフトな「l」で終わらない場合、（最初は）発音できません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     声でも同じこと。 音声は、その言語の音素のみを発音するように設計されています。 さらに-言語の特定の方言で。 つまり カナダのフランス語とフランス語のフランス語の音声は、音が異なるだけでなく、発音された音素のセットも異なります。 ちなみに、これはASRおよびTTSエンジンのメーカーにとって便利です。 各言語は別々のお金で販売できます。 一方、あなたはそれらを理解することができます。 音声の作成は非常に時間がかかり、お金もかかります。 おそらくこれがまさに、ほとんどの言語のオープンソースソリューションの市場がまだ広くない理由です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     すべてのIPA音素を発音できる「ユニバーサル」ボイスの作成を妨げるものはないように思われ、多言語インターフェイスの問題を解決します。 しかし、何らかの理由で誰もそれをしません。 ほとんどの場合、これは不可能です。 つまり 彼は言うことができますが、すべてのネイティブスピーカーは、発音の「自然さ」の欠如に不満を感じるでしょう。 少し練習したイギリス人の口の中ではロシア語のように聞こえ、フランス人の口の中では英語のように聞こえます。 したがって、多言語主義が必要な場合は、分岐する準備をしてください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  7. TTS APIの例 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TTSでの作業プロセスが下位レベル（C ++を使用）でどのように見えるかを読者に示すために、Nuanceエンジンに基づく音声合成の例を示します。 もちろん、これは不完全な例です。実行できるだけでなく、コンパイルすることもできますが、プロセスのアイデアを提供します。  TTS_Speak（）を除くすべての関数は、バインディングとして必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TTS_Initialize（）-エンジンの初期化に役立ちます 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TTS_Cleanup（）-初期化解除のため 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TTS_SelectLanguage-言語を選択し、認識パラメーターを設定します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TTS_Speak（）-実際にサウンドサンプルを生成します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TTS_Callback（）-他のイベントの場合と同様に、オーディオデータの次の部分の再生準備ができたときに呼び出されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">TTSとそのバインディング</b> <div class="spoiler_text"><pre><code class="hljs pgsql">static const NUAN_TCHAR * _dataPathList[] = { __TEXT("\\lang\\"), __TEXT("\\tts\\"), }; static VPLATFORM_RESOURCES _stResources = { VPLATFORM_CURRENT_VERSION, sizeof(_dataPathList)/sizeof(_dataPathList[<span class="hljs-number"><span class="hljs-number">0</span></span>]), (NUAN_TCHAR **)&amp;_dataPathList[<span class="hljs-number"><span class="hljs-number">0</span></span>], }; static VAUTO_INSTALL _stInstall = {VAUTO_CURRENT_VERSION}; static VAUTO_HSPEECH _hSpeech = {<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; static VAUTO_HINSTANCE _hTtsInst = {<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; static WaveOut * _waveOut = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; static WaveOutBuf * _curBuffer = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; static <span class="hljs-type"><span class="hljs-type">int</span></span> _volume = <span class="hljs-number"><span class="hljs-number">100</span></span>; static <span class="hljs-type"><span class="hljs-type">int</span></span> _speechRate = <span class="hljs-number"><span class="hljs-number">0</span></span>; // use <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> speech rate static NUAN_ERROR _Callback (VAUTO_HINSTANCE hTtsInst, VAUTO_OUTDEV_HINSTANCE hOutDevInst, VAUTO_CALLBACKMSG * pcbMessage, VAUTO_USERDATA UserData); static const TCHAR * _szLangTLW = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; static VAUTO_PARAMID _paramID[] = { VAUTO_PARAM_SPEECHRATE, VAUTO_PARAM_VOLUME }; static NUAN_ERROR _TTS_GetFrequency(VAUTO_HINSTANCE hTtsInst, short *pFreq) { NUAN_ERROR Error = NUAN_OK; VAUTO_PARAM TtsParam; <span class="hljs-comment"><span class="hljs-comment">/*-- get frequency used by current voicefont --*/</span></span> TtsParam.eID = VAUTO_PARAM_FREQUENCY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NUAN_OK != (Error = vauto_ttsGetParamList (hTtsInst, &amp;TtsParam, <span class="hljs-number"><span class="hljs-number">1</span></span>)) ) { ErrorV(_T("vauto_ttsGetParamList rc=0x%1!x!\n"), Error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error; } switch(TtsParam.uValue.usValue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_FREQ_8KHZ: *pFreq = <span class="hljs-number"><span class="hljs-number">8000</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_FREQ_11KHZ: *pFreq = <span class="hljs-number"><span class="hljs-number">11025</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_FREQ_16KHZ: *pFreq = <span class="hljs-number"><span class="hljs-number">16000</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_FREQ_22KHZ: *pFreq = <span class="hljs-number"><span class="hljs-number">22050</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: break; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUAN_OK; } <span class="hljs-type"><span class="hljs-type">int</span></span> TTS_SelectLanguage(<span class="hljs-type"><span class="hljs-type">int</span></span> langId) { NUAN_ERROR nrc; VAUTO_LANGUAGE arrLanguages[<span class="hljs-number"><span class="hljs-number">16</span></span>]; VAUTO_VOICEINFO arrVoices[<span class="hljs-number"><span class="hljs-number">4</span></span>]; VAUTO_SPEECHDBINFO arrSpeechDB[<span class="hljs-number"><span class="hljs-number">4</span></span>]; NUAN_U16 nLanguageCount, nVoiceCount, nSpeechDBCount; nLanguageCount = sizeof(arrLanguages)/sizeof(arrLanguages[<span class="hljs-number"><span class="hljs-number">0</span></span>]); nVoiceCount = sizeof(arrVoices) /sizeof(arrVoices[<span class="hljs-number"><span class="hljs-number">0</span></span>]); nSpeechDBCount = sizeof(arrSpeechDB)/sizeof(arrSpeechDB[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-type"><span class="hljs-type">int</span></span> nVoice = <span class="hljs-number"><span class="hljs-number">0</span></span>, nSpeechDB = <span class="hljs-number"><span class="hljs-number">0</span></span>; nrc = vauto_ttsGetLanguageList( _hSpeech, &amp;arrLanguages[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;nLanguageCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ TTS_ErrorV(_T("vauto_ttsGetLanguageList rc=0x%1!x!\n"), nrc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nLanguageCount == <span class="hljs-number"><span class="hljs-number">0</span></span> || nLanguageCount&lt;=langId){ TTS_Error(_T("vauto_ttsGetLanguageList: No proper languages found.\n")); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } _szLangTLW = arrLanguages[langId].szLanguageTLW; NUAN_TCHAR* szLanguage = arrLanguages[langId].szLanguage; nVoice = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> first voice; NUAN_TCHAR* szVoiceName = arrVoices[nVoice].szVoiceName; nSpeechDB = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> first speech DB { VAUTO_PARAM stTtsParam[<span class="hljs-number"><span class="hljs-number">7</span></span>]; <span class="hljs-type"><span class="hljs-type">int</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> stTtsParam[cnt].eID = VAUTO_PARAM_LANGUAGE; _tcscpy(stTtsParam[cnt].uValue.szStringValue, szLanguage); cnt++; // voice stTtsParam[cnt].eID = VAUTO_PARAM_VOICE; _tcscpy(stTtsParam[cnt].uValue.szStringValue, szVoiceName); cnt++; // speechbase parameter - frequency stTtsParam[cnt].eID = VAUTO_PARAM_FREQUENCY; stTtsParam[cnt].uValue.usValue = arrSpeechDB[nSpeechDB].u16Freq; cnt++; // speechbase parameter - reduction <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> stTtsParam[cnt].eID = VAUTO_PARAM_VOICE_MODEL; _tcscpy(stTtsParam[cnt].uValue.szStringValue, arrSpeechDB[nSpeechDB].szVoiceModel); cnt++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_speechRate) { // Speech rate stTtsParam[cnt].eID = VAUTO_PARAM_SPEECHRATE; stTtsParam[cnt].uValue.usValue = _speechRate; cnt++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_volume) { // Speech volume stTtsParam[cnt].eID = VAUTO_PARAM_VOLUME; stTtsParam[cnt].uValue.usValue = _volume; cnt++; } nrc = vauto_ttsSetParamList(_hTtsInst, &amp;stTtsParam[<span class="hljs-number"><span class="hljs-number">0</span></span>], cnt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ ErrorV(_T("vauto_ttsSetParamList rc=0x%1!x!\n"), nrc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> TTS_Initialize(<span class="hljs-type"><span class="hljs-type">int</span></span> defLanguageId) { NUAN_ERROR nrc; nrc = vplatform_GetInterfaces(&amp;_stInstall, &amp;_stResources); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ Error(_T("vplatform_GetInterfaces rc=%1!d!\n"), nrc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } nrc = vauto_ttsInitialize(&amp;_stInstall, &amp;_hSpeech); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ Error(_T("vauto_ttsInitialize rc=0x%1!x!\n"), nrc); TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } nrc = vauto_ttsOpen(_hSpeech, _stInstall.hHeap, _stInstall.hLog, &amp;_hTtsInst, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ ErrorV(_T("vauto_ttsOpen rc=0x%1!x!\n"), nrc); TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } // Ok, <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!TTS_SelectLanguage(defLanguageId)){ TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } // init Wave <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> device { short freq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NUAN_OK != _TTS_GetFrequency(_hTtsInst, &amp;freq)) { TTS_ErrorV(_T("_TTS_GetFrequency rc=0x%1!x!\n"), nrc); TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } _waveOut = WaveOut_Open(freq, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_waveOut == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>){ TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } // init TTS output { VAUTO_OUTDEVINFO stOutDevInfo; stOutDevInfo.hOutDevInstance = _waveOut; stOutDevInfo.pfOutNotify = TTS_Callback; // <span class="hljs-keyword"><span class="hljs-keyword">Notify</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> callback! nrc = vauto_ttsSetOutDevice(_hTtsInst, &amp;stOutDevInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ ErrorV(_T("vauto_ttsSetOutDevice rc=0x%1!x!\n"), nrc); TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } // OK TTS engine initialized <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> TTS_Cleanup(<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_hTtsInst.pHandleData){ vauto_ttsStop(_hTtsInst); vauto_ttsClose(_hTtsInst); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_hSpeech.pHandleData){ vauto_ttsUnInitialize(_hSpeech); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_waveOut){ WaveOut_Close(_waveOut); _waveOut = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } vplatform_ReleaseInterfaces(&amp;_stInstall); memset(&amp;_stInstall, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(_stInstall)); _stInstall.fmtVersion = VAUTO_CURRENT_VERSION; } <span class="hljs-type"><span class="hljs-type">int</span></span> TTS_Speak(const TCHAR * const message, <span class="hljs-type"><span class="hljs-type">int</span></span> length) { VAUTO_INTEXT stText; stText.eTextFormat = VAUTO_NORM_TEXT; stText.szInText = (<span class="hljs-type"><span class="hljs-type">void</span></span>*) message; stText.ulTextLength = length * sizeof(NUAN_TCHAR); TraceV(_T("TTS_Speak: %1\n"), message); NUAN_ERROR rc = vauto_ttsProcessText2Speech(_hTtsInst, &amp;stText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc == NUAN_OK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc == NUAN_E_TTS_USERSTOP) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } ErrorV(_T("vauto_ttsProcessText2Speech rc=0x%1!x!\n"), rc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } static NUAN_ERROR TTS_Callback (VAUTO_HINSTANCE hTtsInst, VAUTO_OUTDEV_HINSTANCE hOutDevInst, VAUTO_CALLBACKMSG * pcbMessage, VAUTO_USERDATA UserData) { VAUTO_OUTDATA * outData; switch(pcbMessage-&gt;eMessage){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_BEGINPROCESS: WaveOut_Start(_waveOut); break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_ENDPROCESS: break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_STOP: break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_OUTBUFREQ: outData = (VAUTO_OUTDATA *)pcbMessage-&gt;pParam; memset(outData, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(VAUTO_OUTDATA)); { WaveOutBuf * buf = WaveOut_GetBuffer(_waveOut); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buf){ VAUTO_OUTDATA * outData = (VAUTO_OUTDATA *)pcbMessage-&gt;pParam; outData-&gt;eAudioFormat = VAUTO_16LINEAR; outData-&gt;pOutPcmBuf = WaveOutBuf_Data(buf); outData-&gt;ulPcmBufLen = WaveOutBuf_Size(buf); _curBuffer = buf; break; } TTS_Trace(_T("VAUTO_MSG_OUTBUFREQ: processing was stopped\n")); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUAN_E_TTS_USERSTOP; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_OUTBUFDONE: outData = (VAUTO_OUTDATA *)pcbMessage-&gt;pParam; WaveOutBuf_SetSize(_curBuffer, outData-&gt;ulPcmBufLen); WaveOut_PutBuffer(_waveOut, _curBuffer); _curBuffer = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: break; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUAN_OK; }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     読者が気づくかもしれませんが、コードはかなり面倒で、単純な（一見）機能には多数のプリセットが必要です。 悲しいかな、これはエンジンの柔軟性の裏返しです。 もちろん、他の言語用の他のエンジンのAPIは、はるかにシンプルからコンパクトにできます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  8.再び音素 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      APIを見ると、読者が尋ねる場合があります-TTS（Text-To-Speech）がテキストを音声に直接変換できる場合、なぜ音素が必要なのでしょうか。 可能ですが、「しかし」が1つあります。 エンジンに<b>なじみのある</b>単語<b>は、</b>音声に変換されます。  「なじみのない」という言葉は状況をさらに悪化させます。 地名、固有名詞など。 これは、たとえばロシアなどの多国籍国で特に顕著です。 土地の永遠に6分の1の領域にある都市や町の名前は、異なる人々、異なる言語、異なる時間に与えられました。 ロシア文字でそれらを綴る必要性は、各国語で悪い冗談を演じました。 タタール語、ネネツ語、アブハジア語、カザフ語、ヤクート語、ブリャト語の音素は、ロシア語のプロクラス階のベッドに絞り込まれました。 そこには、多くの音素がありますが、それでも前の連合の人々のすべての言語を伝えるだけでは十分ではありません。 しかし、さらに悪いことに、表音記録が少なくとも元のものとある程度類似している場合、TTSエンジンを読むと「Kuchuk-Kainardzhi」のような名前は笑い声にすぎません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、これはロシア語の問題に過ぎないと考えるのは単純です。 人口の点でより均質な国にも同様の困難が存在します。 そのため、フランス語では、単語の最後にある文字p、b、d、t、sは通常読まれません。 しかし、地名を付けると、地元の伝統がここで発効します。 そのため、最後の「パリ」という言葉は実際には発音されず、「ヴァリリス」という言葉では-逆もまた同様です。 違いは、パリはフランスの北に位置し、ヴァロリスは南のプロヴァンスにあり、発音規則が多少異なることです。 そのため、単語の音声転写が必要です。 通常、カードには付属しています。 確かに、形式の統一は観察されません。 そのため、NavTeqは伝統的にX-SAMPAトランスクリプションとTomTom-LH +を使用します。  TTSエンジンが両方を受け入れている場合、そうでない場合はどうでしょうか？ ここであなたは変態しなければなりません。 たとえば、ある文字起こしを別の文字変換に変換することは、それ自体では簡単ではありません。 音声情報がまったくない場合、エンジンにはそれを取得するための独自のメソッドがあります。  Nuanceエンジンについて言えば、「データ駆動型書記素から音素」（DDG2P）および「共通言語コンポーネント」（CLC）です。 ただし、これらのオプションの使用はすでに極端な手段です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  9.特別なシーケンス </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Nuanceには、テキストまたは音声記録を発音する機能だけでなく、それらを動的に切り替える機能もあります。 これを行うには、次の形式のエスケープシーケンスを使用します。&lt;ESC&gt; / + 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一般に、エスケープシーケンスを使用して、多くのパラメーターを指定できます。 一般的な形式では、次のようになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>                                          &lt;ESC&gt; \ &lt;param&gt; = &lt;値&gt; \
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     例えば 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      \ x1b \ rate = 110 \-発音速度を設定します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      \ x1b \ vol = 5 \-ボリュームを設定します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      \ x1b \ audio = "beep.wav" \-wavファイルのデータをオーディオストリームに挿入します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     同様に、エンジンのスペルを単語にしたり、ポーズを挿入したり、音声を変更したり（たとえば、男性から女性に）することができます。 もちろん、すべてのシーケンスが便利なわけではありませんが、全体的に非常に便利な機能です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  10.辞書 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     特定の単語セットを特定の方法（略語、略語、固有名詞など）で発音しなければならない場合がありますが、それぞれの場合にテキストを音声表記に置き換える必要があります（これは常に可能とは限りません）。 この場合、辞書が助けになります。  Nuance用語集の辞書とは何ですか？ これは、ペアのセットを持つファイルです：&lt;text&gt; &lt;transcription&gt;。 このファイルはコンパイルされ、エンジンによってロードされます。 発音時に、エンジンは単語/テキストが辞書に存在するかどうかを確認し、存在する場合は、音声表記に置き換えます。 たとえば、バチカンの街路や広場の名前を含む辞書。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> [ヘッダー]
名前=バチカーノ
言語= ITI
コンテンツ= EDCT_CONTENT_BROAD_NARROWS
表現= EDCT_REPR_SZZ_STRING
 [データ]
 「コロンゴナート」// 'lar.go_del_ko.lo.'n：a.to
 「Piazza del Governatorato」//「pja.t＆s：a_del_go.ver.na.to.'ra.to
 "Piazza della Stazione" // 'pja.t＆s：a_de.l：a_sta.'t＆s：jo.ne
 「サンタマルタ広場」// 'pja.t＆s：a_di_'san.ta_'mar.ta
 「サンピエトロ広場」// 'pja.t＆s：a_'sam_'pjE.tro
 「PiazzettaChâteauneufDu Pape」// pja.'t＆s：et：a_Sa.to.'nef_du_'pap
 「サリタ・アイ・ジャルディーニ」// sa.'li.ta_aj_d＆Zar.'di.ni
 「ストラドンデイジャルディーニ」// stra.'do.ne_dej_d＆Zar.'di.ni
 「Via dei Pellegrini」// 'vi.a_dej_pe.l：e.'gri.ni
 「フォンダメント通り」// 'vi.a_del_fon.da.'men.to
 「Via del Governatorato」// 'vi.a_del_go.ver.na.to.'ra.to
 「Via della Posta」// 'vi.a_de.l：a_'pOs.ta
 「Vatica della Stazione Vaticana」// 'vi.a_de.l：a_sta.'t＆s：jo.ne_va.ti.'ka.na
 「Via della Tipografia」// 'vi.a_de.l：a_ti.po.gra.'fi.a
 「ヴィアディポルタアンジェリカ」// 'vi.a_di_'pOr.ta_an.'d＆ZE.li.ka
 「Via Tunica」// 'vi.a_'tu.ni.ka
 "Viale Centro del Bosco" // vi.'a.le_'t＆SEn.tro_del_'bOs.ko
 「Viard del Giardino Quadrato」// vi.'a.le_del_d＆Zar.'di.no_kwa.'dra.to
 「Viatic Vaticano」// vi.'a.le_va.ti.'ka.no
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  11.認識 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     音声認識は、その合成よりもさらに困難です。 シンセサイザーが古き良き時代に何らかの形で機能していれば、賢明な認識は今しか利用できなくなりました。 いくつかの理由があります。最初の理由は、なじみのない言語に直面している普通の生きている人の問題に非常に似ています。2番目の理由は、なじみのない地域のテキストとの衝突です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私たちは声を思い出させる音の振動を知覚し、まずそれを音素に分割し、形成しなければならない身近な音を言葉に分離しようとします。 言語が馴染みのある場合、これは簡単に取得できますが、そうでない場合は、音声を音素に「正しく」分解することさえできません（「Alla、I'm at the bar！」に関する話を思い出してください）。 私たちが聞くところでは、話す人は完全に異なっています。 これは、長年にわたり、私たちの脳が特定の音素で「訓練」されており、時間とともにそれらだけを知覚することに慣れているためです。 なじみのない音に出会い、彼は自分が聞いたものに最も近い母国語[言語]の音素を選択しようとします。 ある意味では、これはCELPなどの音声コーデックで使用されるベクトル量子化手法に似ています。 そのような近似が成功するという事実ではありません。 そのため、「快適な」音素は「便利」になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ソ連に戻って、学校で勉強している間、そして外国人と会うとき、私たちの名前を「音訳」しようとしたことを覚えておいてください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>ボリス・ペトロフの名前</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     先生たちは私たちをscり、なぜあなたの名前を歪めたのですか 彼はこれを理解すると思いますか？ ロシア語を話そう！ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     悲しいかな、ここでも彼らは私たちを欺いたり、間違えたりしました...もしあなたが英語/ドイツ語/中国語であなたの名前を発音することができれば、それはネイティブスピーカーがそれを知覚することは本当に簡単です。 中国人はこれをかなり前に理解し、西洋のパートナーと通信するために自分自身のために特別な「ヨーロッパ」の名前を取りました。 機械認識では、特定の言語はいわゆる音響モデルによって記述されます。 テキストを認識する前に、特定の言語の音響モデルをロードする必要があります。これにより、入力時にテキストを待機する音素をプログラムに明確にする必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2番目の問題も同様に複雑です。 生きている人との類推に戻りましょう。 対話者の話を聞いて、私たちは無意識のうちに彼が次に言うことのモデルを頭の中に構築します。言い換えれば、会話のコンテキストを作成します。 そして、文脈から外れた言葉を物語に突然挿入すると（例えば、サッカーに関しては「インボリュート」）、対談者に認知的不協和を引き起こす可能性があります。 大雑把に言えば、コンピューターではこの非常に不協和音が絶えず発生します。なぜなら、彼は人に何を期待するのかわからないからです。 人にとっては簡単です。対談者に再度尋ねることができます。 コンピューターは何をすべきですか？ この問題を解決し、コンピューターに正しいコンテキストを与えるために、文法が使用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  12.文法 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     文法（通常はBNFの形式で与えられます）は、コンピューター（より正確にはASRエンジン）に、この特定の瞬間にユーザーに期待することのアイデアを与えるだけです。 通常、これらは「または」を介して組み合わされたいくつかの選択肢ですが、より複雑な文法も可能です。 カザンの地下鉄駅を選択するための文法の例を次に示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> ＃BNF + EM V1.0;
 ！文法テスト。
 ！start &lt;metro_KAZAN_stations&gt;;
 &lt;metro_KAZAN_stations&gt;：
 "Ametyevo"！Id（0）！発音（ "^。 'M％je.t％jjI.vo-"）|
 「航空機」！Id（1）！発音（ "^ v％jI'astro-'it％jIl％jno-j ^"）|
 "Slides"！Id（2）！発​​音（ "'gor.k％jI"）|
 「ヤギ定住」！Id（3）！発音（ "'ko.z％jj ^ _slo-.b ^。' Da"）|
 "Kremlin"！Id（4）！発音（ "kr％jIm.'l％jof.sko-.j ^"）|
 "Gabdulla Tukay Square"！Id（5）！発音（ "'plo.S％jIt％j_go-.bdu.'li0_'tu.ko-.j ^"）|
 Victory Avenue！Id（6）！発音（ "pr ^。 'Sp％jekt_p ^。' B％je.di0"）|
北駅！Id（7）！発音（ "'s％je.v％jIr.ni0j_v ^ g.'zal"）|
 「布地決済」！Id（8）！発音（ "'su.ko-.no-.j ^ _slo-.b ^。' Da"）|
 "Yashlek"！Id（9）！発音（ "ja.'Sl％jek"）;
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ご覧のとおり、各行は選択肢の1つであり、実際のテキスト、整数ID、音素で構成されています。 音素は一般にオプションですが、それにより認識がより正確になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     文法はどれくらい大きくできますか？ 十分に大きい。 私たちの実験では、37000の代替案が許容レベルで認識されているとします。 複雑で分岐した文法では事態はさらに悪化します。 認識時間が長くなり、品質が低下し、文法の長さへの依存は非線形です。 したがって、私のアドバイスは複雑な文法を避けることです。 とにかく、さようなら。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     文法（およびコンテキスト）は静的および動的です。 静的文法の例をすでに見ました;事前にコンパイルされ、エンジンの内部バイナリ表現に保存されます。 ただし、ユーザーの操作中にコンテキストが変わる場合があります。 ナビゲーションの典型的な例は、最初の文字による都市の選択です。 ここで認識の可能なオプションのセットは、それぞれの文字が入力されるたびに変化します。認識コンテキストは常に再構築する必要があります。 これらの目的のために、動的コンテキストが使用されます。 大まかに言えば、プログラマーは文法を「オンザフライ」でコンパイルし、プログラムの実行中にそれらをエンジンにパームします。 もちろん、モバイルデバイスについて話している場合、処理速度はあまり高くないため、ユーザーインターフェイスがフリーズしないように、小さな文法（約100語）に制限する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  13. ASR APIの例 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     テキスト認識は、合成ほど簡単ではありません。 ユーザーがマイクの前で静かになっている場合、周囲のノイズを認識する必要があります。  「ehhhhhh」などと言ったら、認識も失敗する可能性があります。 最良の場合、ASRは通常、一連のオプション（仮説とも呼ばれる）を返します。 各仮説には一定の重みがあります。 文法が大きい場合、認識オプションは非常に多くなります。 この場合、仮説（たとえば、信頼性の降順で最初の5つ）を連続的に述べ、ユーザーにそれらの1つを選択するように依頼することは理にかなっています。 理想的には、短い文法（ "yes" | "no"）で、信頼性の高いインジケータを持つ1つのオプションを返します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次の例には、次の関数が含まれています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ConstructRecognizer（）-「認識」を作成し、そのパラメーターを構成します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      DestroyRecognizer（）-「認識」を破棄します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ASR_Initialize（）-ASRエンジンを初期化します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ASR_UnInitialize（）-ASRエンジンの初期化を解除します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      evt_HandleEvent-「認識」スレッドによって生成されたイベントを処理します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ProcessResult（）-認識結果を出力します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">ASRとそのバインディング</b> <div class="spoiler_text"><pre> <code class="hljs perl">typedef struct RECOG_OBJECTS_S { void *pHeapInst; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Pointer to the heap. const char *acmod; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to acmod data const char *ddg2p; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to ddg2p data const char *clc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to clc data const char *dct; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to dct data const char *dynctx; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to empty dyn ctx data LH_COMPONENT hCompBase; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the base component. LH_COMPONENT hCompAsr; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the ASR component. LH_COMPONENT hCompPron; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the pron component (dyn ctx) LH_OBJECT hAcMod; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the AcMod object. LH_OBJECT hRec; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the SingleThreadedRec Object LH_OBJECT hLex; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to lexicon object (dyn ctx) LH_OBJECT hDdg2p; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to ddg2p object (dyn ctx) LH_OBJECT hClc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the CLC (DDG2P backup) LH_OBJECT hDct; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to dictionary object (dyn ctx) LH_OBJECT hCache; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to cache object (dyn ctx) LH_OBJECT hCtx[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the Context object. LH_OBJECT hResults[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the Best results object. ASRResult *results[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> recognition results temporary storage LH_OBJECT hUswCtx; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the UserWord Context object. LH_OBJECT hUswResult; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the UserWord Result object. unsigned long sampleFreq; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Sampling frequency. unsigned long frameShiftSamples; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Size of one frame in samples <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> requestCancel; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> boolean indicating user wants to cancel recognition // used to generate transcriptions <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> dyn ctx LH_BNF_TERMINAL *pTerminals; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terminals_count; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *terminals_transtype; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> array with same size as pTerminals; <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> value indicates the type of transcription in pTerminal: user-provided, from_ddg2p, from_dct, from_clc SLOT_TERMINAL_LIST *pSlots; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> slots_count; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> reco options <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> isNumber; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> set to <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> doing number recognition const char * UswFile; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to file where userword should be recorded char * staticCtxID; } RECOG_OBJECTS; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> store ASR objects static RECOG_OBJECTS recogObjects; static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ConstructRecognizer(RECOG_OBJECTS *pRecogObjects, const char *szAcModFN, const char * ddg2p, const char * clc, const char * dct, const char * dynctx) { LH_ERROR lhErr = LH_OK; PH_ERROR phErr = PH_OK; ST_ERROR stErr = ST_OK; LH_ISTREAM_INTERFACE IStreamInterface; void *pIStreamAcMod = NULL; LH_ACMOD_INFO *pAcModInfo; LH_AUDIOCHAINEVENT_INTERFACE EventInterface; <span class="hljs-regexp"><span class="hljs-regexp">/* close old objects */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hAcMod)){ DestroyRecognizer(pRecogObjects); } pRecogObjects-&gt;sampleFreq = <span class="hljs-number"><span class="hljs-number">0</span></span>; pRecogObjects-&gt;requestCancel = <span class="hljs-number"><span class="hljs-number">0</span></span>; pRecogObjects-&gt;pTerminals = NULL; pRecogObjects-&gt;terminals_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; pRecogObjects-&gt;pSlots = NULL; pRecogObjects-&gt;slots_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; pRecogObjects-&gt;staticCtxID = NULL; pRecogObjects-&gt;acmod = szAcModFN; pRecogObjects-&gt;ddg2p = ddg2p; pRecogObjects-&gt;clc = clc; pRecogObjects-&gt;dct = dct; pRecogObjects-&gt;dynctx = dynctx; EventInterface.pfevent = evt_HandleEvent; EventInterface.pfadvance = evt_Advance; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the input stream <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the acoustic model. stErr = st_CreateStreamReaderFromFile(szAcModFN, &amp;IStreamInterface, &amp;pIStreamAcMod); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ST_OK != stErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the AcMod object. lhErr = lh_CreateAcMod(pRecogObjects-&gt;hCompAsr, &amp;IStreamInterface, pIStreamAcMod, NULL, &amp;(pRecogObjects-&gt;hAcMod)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Retrieve some information from the AcMod object. lhErr = lh_AcModBorrowInfo(pRecogObjects-&gt;hAcMod, &amp;pAcModInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; pRecogObjects-&gt;sampleFreq = pAcModInfo-&gt;sampleFrequency; pRecogObjects-&gt;frameShiftSamples = pAcModInfo-&gt;frameShift * pRecogObjects-&gt;sampleFreq/<span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create a SingleThreadRec object lhErr = lh_CreateSingleThreadRec(pRecogObjects-&gt;hCompAsr, &amp;EventInterface, pRecogObjects, <span class="hljs-number"><span class="hljs-number">3000</span></span>, pRecogObjects-&gt;sampleFreq, pRecogObjects-&gt;hAcMod, &amp;pRecogObjects-&gt;hRec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> cretae DDG2P &amp; lexicon <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> dyn ctx <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pRecogObjects-&gt;ddg2p) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = InitDDG2P(pRecogObjects); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pRecogObjects-&gt;clc) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = InitCLCandDCT(pRecogObjects); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO: what now? } // Return without errors. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error: <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Print an error message <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the error comes from the private heap <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> stream component. // Errors from the VoCon320<span class="hljs-number"><span class="hljs-number">0</span></span> component have been printed by the callback. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PH_OK != phErr) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Error from the private heap component, error code = %d.\n"</span></span>, phErr); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ST_OK != stErr) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Error from the stream component, error code = %d.\n"</span></span>, stErr); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DestroyRecognizer(RECOG_OBJECTS *pRecogObjects) { unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curCtx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hUswResult)){ lh_ObjClose(&amp;pRecogObjects-&gt;hUswResult); pRecogObjects-&gt;hUswResult = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hUswCtx)){ lh_ObjClose(&amp;pRecogObjects-&gt;hUswCtx); pRecogObjects-&gt;hUswCtx = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hDct)){ lh_ObjClose(&amp;pRecogObjects-&gt;hDct); pRecogObjects-&gt;hDct = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hCache)){ lh_ObjClose(&amp;pRecogObjects-&gt;hCache); pRecogObjects-&gt;hCache = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hClc)){ lh_ObjClose(&amp;pRecogObjects-&gt;hClc); pRecogObjects-&gt;hClc = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hLex)){ lh_LexClearG2P(pRecogObjects-&gt;hLex); lh_ObjClose(&amp;pRecogObjects-&gt;hLex); pRecogObjects-&gt;hLex = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hDdg2p)){ lh_DDG2PClearDct (pRecogObjects-&gt;hDdg2p); lh_ObjClose(&amp;pRecogObjects-&gt;hDdg2p); pRecogObjects-&gt;hDdg2p = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(curCtx=<span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx&lt;sizeof(recogObjects.hCtx)/sizeof(recogObjects.hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); curCtx++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hCtx[curCtx])){ lh_RecRemoveCtx(pRecogObjects-&gt;hRec, pRecogObjects-&gt;hCtx[curCtx]); lh_ObjClose(&amp;pRecogObjects-&gt;hCtx[curCtx]); pRecogObjects-&gt;hCtx[curCtx] = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hResults[curCtx])){ lh_ObjClose(&amp;pRecogObjects-&gt;hResults[curCtx]); pRecogObjects-&gt;hResults[curCtx] = lh_GetNullObj(); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hRec)){ lh_ObjClose(&amp;pRecogObjects-&gt;hRec); pRecogObjects-&gt;hRec = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hAcMod)){ lh_ObjClose(&amp;pRecogObjects-&gt;hAcMod); pRecogObjects-&gt;hAcMod = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ASR_Initialize(const char * acmod, const char * ddg2p, const char * clc, const char * dct, const char * dynctx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = <span class="hljs-number"><span class="hljs-number">0</span></span>; size_t curCtx; LH_HEAP_INTERFACE HeapInterface; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Initialization of all handles. recogObjects.pHeapInst = NULL; recogObjects.hCompBase = lh_GetNullComponent(); recogObjects.hCompAsr = lh_GetNullComponent(); recogObjects.hCompPron = lh_GetNullComponent(); recogObjects.hAcMod = lh_GetNullObj(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(curCtx=<span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx&lt;sizeof(recogObjects.hCtx)/sizeof(recogObjects.hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); curCtx++){ recogObjects.hCtx[curCtx] = lh_GetNullObj(); recogObjects.hResults[curCtx] = lh_GetNullObj(); } recogObjects.hRec = lh_GetNullObj(); recogObjects.hLex = lh_GetNullObj(); recogObjects.hDdg2p = lh_GetNullObj(); recogObjects.hClc = lh_GetNullObj(); recogObjects.hCache = lh_GetNullObj(); recogObjects.hDct = lh_GetNullObj(); recogObjects.hUswCtx = lh_GetNullObj(); recogObjects.hUswResult = lh_GetNullObj(); recogObjects.sampleFreq = <span class="hljs-number"><span class="hljs-number">0</span></span>; recogObjects.requestCancel = <span class="hljs-number"><span class="hljs-number">0</span></span>; recogObjects.pTerminals = NULL; recogObjects.terminals_count= <span class="hljs-number"><span class="hljs-number">0</span></span>; recogObjects.pSlots = NULL; recogObjects.slots_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; recogObjects.staticCtxID = NULL; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Construct all components <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> objects needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> recognition. // Connect the audiochain objects. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acmod) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> initialize components // Create a base <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> an ASR component. (+pron <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> dyn ctx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK != lh_InitBase(&amp;HeapInterface, recogObjects.pHeapInst, LhErrorCallBack, NULL, &amp;recogObjects.hCompBase)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK != lh_InitAsr(recogObjects.hCompBase, &amp;HeapInterface, recogObjects.pHeapInst, &amp;recogObjects.hCompAsr)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK != lh_InitPron(recogObjects.hCompBase, &amp;HeapInterface, recogObjects.pHeapInst, &amp;recogObjects.hCompPron)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; rc = ConstructRecognizer(&amp;recogObjects, acmod, ddg2p, clc, dct, dynctx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rc; error: <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> An error occured. Close the engine. CloseOnError(&amp;recogObjects); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ASR_UnInitialize(void) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Disconnects the audiochain objects. // Closes all objects <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> components of the vocon recognizer. rc = DestroyRecognizer(&amp;recogObjects); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Close the PRON component. lh_ComponentTerminate(&amp;recogObjects.hCompPron); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Close the ASR <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Base component. lh_ComponentTerminate(&amp;recogObjects.hCompAsr); lh_ComponentTerminate(&amp;recogObjects.hCompBase); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> evt_HandleEvent(void *pEvtInst, unsigned long type, LH_TIME timeMs) { RECOG_OBJECTS *pRecogObjects = (RECOG_OBJECTS*)pEvtInst; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_BOS ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ask upper level <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> beep <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_BOS at time %d ms.\n"</span></span>, timeMs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_TS_FX ) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_TS_FX at time %d ms.\n"</span></span>, timeMs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_TS_REC ) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_TS_REC at time %d ms.\n"</span></span>, timeMs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_FX_ABNORMCOND ) { LH_ERROR lhErr = LH_OK; LH_FX_ABNORMCOND abnormCondition; <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_FX_ABNORMCOND at time %d ms.\n"</span></span>, timeMs); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Find out what the exact abnormal condition is. lhErr = lh_FxGetAbnormCondition(pRecogObjects-&gt;hRec, &amp;abnormCondition); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; switch (abnormCondition) { case LH_FX_BADSNR: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_BADSNR.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_OVERLOAD: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_OVERLOAD.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_TOOQUIET: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_TOOQUIET.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_NOSIGNAL: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_NOSIGNAL.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_POORMIC: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_POORMIC.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_NOLEADINGSILENCE: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_NOLEADINGSILENCE.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } // LH_AUDIOCHAIN_EVENT_FX_TIMER // It usually is used to get the signal level <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> SNR at regular intervals. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_FX_TIMER ) { LH_ERROR lhErr = LH_OK; LH_FX_SIGNAL_LEVELS SignalLevels; <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_FX_TIMER at time %d ms.\n"</span></span>, timeMs); lhErr = lh_FxGetSignalLevels(pRecogObjects-&gt;hRec, &amp;SignalLevels); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Signal level: %ddB, SNR: %ddB at time %dms.\n"</span></span>, SignalLevels.energy, SignalLevels.SNR, SignalLevels.timeMs); } // LH_AUDIOCHAIN_EVENT_RESULT <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_RESULT ){ LH_ERROR lhErr = LH_OK; LH_OBJECT hNBestRes = lh_GetNullObj(); LH_OBJECT hCtx = lh_GetNullObj(); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_RESULT at time %d ms.\n"</span></span>, timeMs); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Get the NBest result object <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> process it. lhErr = lh_RecCreateResult (pRecogObjects-&gt;hRec, &amp;hNBestRes); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK == lhErr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK == lh_ResultBorrowSourceCtx(hNBestRes, &amp;hCtx)){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _ready = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;sizeof(pRecogObjects-&gt;hCtx)/sizeof(pRecogObjects-&gt;hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hCtx[i])){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hCtx.pObj == pRecogObjects-&gt;hCtx[i].pObj){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hResults[i])){ lh_ObjClose(&amp;pRecogObjects-&gt;hResults[i]); } pRecogObjects-&gt;hResults[i] = hNBestRes; hNBestRes = lh_GetNullObj(); _ready = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_ready) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;sizeof(pRecogObjects-&gt;hCtx)/sizeof(pRecogObjects-&gt;hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hCtx[i])){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lh_ObjIsNull(pRecogObjects-&gt;hResults[i])){ _ready = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } } ASSERT(lh_ObjIsNull(hNBestRes)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_ready) { ProcessResult (pRecogObjects); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;sizeof(pRecogObjects-&gt;hResults)/sizeof(pRecogObjects-&gt;hResults[<span class="hljs-number"><span class="hljs-number">0</span></span>]); i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hResults[i])){ lh_ObjClose(&amp;pRecogObjects-&gt;hResults[i]); } } } } // Close the NBest result object. } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ProcessResult (RECOG_OBJECTS *pRecogObjects) { LH_ERROR lhErr = LH_OK; size_t curCtx, i, k, count=<span class="hljs-number"><span class="hljs-number">0</span></span>; size_t nbrHypothesis; ASRResult *r = NULL; long lid; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> get total hyp count <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(curCtx=<span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx&lt;sizeof(pRecogObjects-&gt;hCtx)/sizeof(pRecogObjects-&gt;hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); curCtx++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hResults[curCtx])){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK == lh_NBestResultGetNbrHypotheses (pRecogObjects-&gt;hResults[curCtx], &amp;nbrHypothesis)){ count += nbrHypothesis; } } } // traces <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">" __________RESULT %3d items max_______________\n"</span></span>, count); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| | |\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| result | confi- | result string [start rule]\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| number | dence |\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"|________|________|___________________________\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| | |\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { r = ASRResult_New(count); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Get &amp; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> out the result information <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> hypothesis. count = <span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx = sizeof(pRecogObjects-&gt;hCtx)/sizeof(pRecogObjects-&gt;hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; curCtx&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx--){ LH_OBJECT hNBestRes = pRecogObjects-&gt;hResults[curCtx-<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(hNBestRes)){ LH_HYPOTHESIS *pHypothesis; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK == lh_NBestResultGetNbrHypotheses (hNBestRes, &amp;nbrHypothesis)){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nbrHypothesis; i++) { char *szResultWords; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Retrieve information on the recognition result. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK == lh_NBestResultFetchHypothesis (hNBestRes, i, &amp;pHypothesis)){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Get the result string. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK == lh_NBestResultFetchWords (hNBestRes, i, &amp;szResultWords)){ <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| %6lu | %6lu | '%s' [%s]\n"</span></span>, i, pHypothesis-&gt;conf, szResultWords, pHypothesis-&gt;szStartRule); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Return the fetched data to the engine. lh_NBestResultReturnWords (hNBestRes, szResultWords); } lh_NBestResultReturnHypothesis (hNBestRes, pHypothesis); } } } } } } // traces <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"|________|________|___________________________\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明らかに、TTSの場合のように、コードは非常に大きく、準備手順は多くのスペースを占有します。</font><font style="vertical-align: inherit;">そして、これはまだ完全に機能するコードではありません！</font><font style="vertical-align: inherit;">出版するとき、私は多くの不必要なものを投げました。</font><font style="vertical-align: inherit;">このすべては、音声I / Oテクノロジーを使用するにはかなり高い「エントリしきい値」が必要であることをここまで読んだ人たちにもう一度示しています。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.ストリーム認識（ディクテーション） </font></font></h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の技術における最後の言葉は、インライン認識、つまりディクテーションです。</font><font style="vertical-align: inherit;">このテクノロジーは、AndroidおよびiOS用の最新のスマートフォンですでに利用可能です。</font><font style="vertical-align: inherit;">含む-APIの形式。</font><font style="vertical-align: inherit;">ここで、プログラマは、文法を作成するときに認識コンテキストを指定する必要はありません。</font><font style="vertical-align: inherit;">入り口でスピーチがあります-出口で、認識された言葉。</font><font style="vertical-align: inherit;">残念ながら、この方法がどのように機能するかについての詳細はまだ入手できません。</font><font style="vertical-align: inherit;">認識プロセスはデバイス自体ではなく、音声が送信されるサーバーで行われ、そこから結果が取得されます。</font><font style="vertical-align: inherit;">しかし、私は何年も後にクライアント側で技術が利用可能になると信じたいです。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> おわりに </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASRとTTSテクノロジーについて伝えたかったのはおそらくそれだけでしょう。</font><font style="vertical-align: inherit;">私はそれがあまりにも退屈で非常に有益ではないことを願っています。</font></font></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J264517/index.html">イントレピッドプログラマー：直接的なライフハッキング</a></li>
<li><a href="../J264519/index.html">チュートリアル：InstantCMS 2のインタラクティブなSVGカートグラムコンポーネント</a></li>
<li><a href="../J264525/index.html">無料のIBM Bluemix開発者向けリソース</a></li>
<li><a href="../J264527/index.html">極端なLACP</a></li>
<li><a href="../J26453/index.html">ホスティングコストについて、または冗談はどこにありますか？</a></li>
<li><a href="../J264535/index.html">Android Devs Meetup 2：前回の会議のビデオとプレゼンテーション</a></li>
<li><a href="../J264547/index.html">HP ProLiant DL360 Gen6とHP ProLiant DL360 Gen8を比較してください。 なぜもっと払うのですか？</a></li>
<li><a href="../J26455/index.html">pdfmenot-PDFファイルを保存するためのサービス</a></li>
<li><a href="../J264557/index.html">ウェビナー「ミートフライエレファント」</a></li>
<li><a href="../J264567/index.html">銀行のクトゥルヒ：ICFPC 2015の決定方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>