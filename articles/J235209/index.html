<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◽️ ⚙️ 🌼 Unicodeの実用化ガイド 🤧 🏴󠁧󠁢󠁷󠁬󠁳󠁿 🏖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="やっとやった！ 長い間、CP1251の恥ずべき遺産は開発者を悩ませていました。 ユニコードの時代は古くからあり、今でもシングルバイトエンコーディングを使用し、外部システムとの互換性のために松葉杖をさまざまな場所に配置しています。 しかし、その理由は非常に合理的でした。MyWorldが開発された大規模...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>Unicodeの実用化ガイド</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> <a href="http://habrahabr.ru/company/mailru/blog/235209/"><img src="https://habrastorage.org/files/688/ce3/73d/688ce373d4bd4d37993f6cb76b97c0fc.png"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     やっとやった！ 長い間、CP1251の恥ずべき遺産は開発者を悩ませていました。 ユニコードの時代は古くからあり、今でもシングルバイトエンコーディングを使用し、外部システムとの互換性のために松葉杖をさまざまな場所に配置しています。 しかし、その理由は非常に合理的でした。MyWorldが開発された大規模なプロジェクトをUnicodeに移行するのは非常に面倒です。 私たちはこれを半年間見積もっており、ロシア語圏の聴衆に実質的な利益をもたらさない機能にそれほど多くのリソースを費やす準備ができていませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、歴史はその調整を行い、しばしば非常に予想外です。 この国で最も人気のあるソーシャルネットワークであるプロジェクトMy Worldがカザフスタンで非常に人気があることは周知の事実です。 そして、私たちは常に、カザフ語ユーザーに、拡張キリル文字セットのカザフ語アルファベットの文字を使用する機会を与えたいと考えていました。残念ながら、CP1251で場所を見つけることができませんでした。 そして、長期的な開発を最終的に正当化することができた、私たちにとっての追加のインセンティブは、国外でのプロジェクトの人気のさらなる成長でした。 私たちは、外国人ユーザーに向けて一歩を踏み出す時だと実感しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     もちろん、プロジェクトの国際化に必要な最初のことは、データの受信、送信、処理、およびUTF-8での保存を開始することでした。 大規模プロジェクトでのこの手順は、話そうとするいくつかのかなり興味深い問題を解決しなければならなかった方法に沿って、単純で長くはありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> データベース変換 </h1> 最初に出会った選択肢は、かなり標準的なものでした-ページの表示から、またはデータストレージから。 これは最も時間のかかるプロセスであり、開発者と管理者による調整されたアクションを必要とするため、リポジトリから始めることにしました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私たちのソーシャルネットワークでは、速度の理由から、多数のさまざまな専用リポジトリが使用されているため、状況は複雑でした。 もちろん、それらのすべてに国際化の対象となるテキストフィールドが含まれているわけではありませんが、それでも多くのテキストフィールドがありました。 そして、最初に行わなければならなかったのは、リポジトリ内のテキスト文字列のコンテンツについて、すべてのリポジトリの完全なインベントリを実施することでした。 確かに、私たちは多くのことを学びました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  MySQL </h1>  MySQLでストレージをUTF-8に変換し始めました。 この理由は、一般に、このベースのエンコーディングの変更がネイティブにサポートされるという事実でした。 しかし実際には、すべてがそれほど単純ではありませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、変換中はダウンタイムなしでデータベースを変換する必要がありました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     第二に、すべてのテーブルで、 <i>テーブル `my_table`を文字セットutf8に変換するように変更する</i>ことが判明しました<i>。</i> 合理的ではなく、さらに不可能です。 フィールドにASCII文字のみが含まれている場合でも、UTF-8フィールドのインデックスは常に<i>3 * length_in_characters</i>バイトを要するため、合理的ではありません。 そして、インデックスフィールド、特に16進文字列を含むフィールドなど、このようなフィールドがたくさんありました。  MySQLのインデックスキーの最大長は767バイトであり、インデックス（特に複数列のインデックス）が適合しないため、不可能です。 さらに、場所によってはバイナリデータが誤って場所に保存されたり、その逆の場合もあり、各フィールドを慎重にチェックする必要があることがわかっています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そこで利用可能なテーブルに関するデータベースから情報を収集した後、それらの大部分がほとんど使用されていないことが明らかになりました。 結果として、データベース内のすべてのテーブルの約半分をデータベースから削除しました。 未使用のテーブルを見つけるために、次の手法を使用しました：tcpdumpを使用して、1日でデータベースへのすべてのクエリを収集し、このダンプのテーブルのリストを現在のデータベーススキームと交差させ、念のため、コードで未使用のテーブルを検索しました（同時にコードをクリアしました）。  Tcpdumpは、MySQLツールを使用してすべてのリクエストをログに書き込むのとは異なり、データベースの再起動を必要とせず、リクエスト処理の速度に影響を与えないため、使用されました。 もちろん、テーブルをすぐに削除するのは怖いので、最初は特別なサフィックスを付けてテーブルの名前を変更し、数週間待ってから削除しました（理由は、正当な理由で再保険されていたため、いくつかの余分な未使用のテーブルが過失によってフックされ、返品する必要がありました）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次に、データベース変換用のDDLの作成を開始しました。 このために、いくつかの標準パターンが使用されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> テーブルにテキストフィールドがなかった場合（ <i>念のため</i> 、突然追加します）、クエリを実行しました<i>。alter table `my_table` default character set utf8;</i> </li><li> テーブルに国際化が必要な<i>varchar</i>テキストフィールドしかない場合： <i>alter table `my_table` convert to character set utf8;</i> </li><li>  ASCII文字のみを含むフィールドはASCIIに変換されました： <i>alter table `my_table` modify` my_column` varchar（n）character set ascii ...;</i> </li><li> 国際化が必要なフィールドは標準です： <i>alter table `my_table` modify` my_column` varchar（n）character set utf8 ...;</i> </li><li> しかし、一意のインデックスを持つ一部のフィールドでは、文字eとeの<i>照合utf8_general_ci</i> （ <i>cp1251_general_ci</i>とは異なり<i>ます</i> ）が<i>等しい</i>ため、松葉杖を<i>使わなければなりませんでした</i> ： <i>alter table `my_table` modify` my_column` varchar（n）charater set utf8 collat​​e utf8_bin ...;</i> </li><li> 変換後のインデックスへの変換を停止したインデックスフィールドについては、松葉杖も必要でした： <i>テーブル `my_table`ドロップインデックス` my_index`の変更、 `my_column` varchar（n）文字セットutf8 ...の変更、インデックス` my_index`（ `my_column`（ m））;</i>  （ここで、 <i>m &lt;n</i> 、およびインデックスは、原則として、いくつかのフィールドにまたがっています）; </li><li> バイナリデータを含むテキストフィールドは、 <i>バイナリ</i>と<i>varbinaryに</i>変換されました<i>。</i> </li><li>  CP1251のテキスト文字列を含むバイナリフィールドは2つの<i>方法で</i>変換されました： <i>alter table `my_table` modify` my_column` varchar（n）character set cp1251;</i>  <i>alter table `my_table` modify` my_column` varchar（n）文字セットutf8</i> ; これは、最初のクエリMySQLがデータがcp1251でエンコードされていることを理解し、2番目のクエリがそれをutf8に変換するために必要です。 </li><li> テキストブロブは個別に処理<i>する</i>必要がありました。これは、 <i>文字セットutf8への変換</i>では、すべての文字が3バイト長である最大長のテキストに合わせてMySQLがブロブを最小に拡張するためです。 つまり、 <i>テキストは</i>自動的に<i>mediumtextに</i>展開され<i>ます</i> 。 多くの場合、これは私たちが望んでいたものではないため、明示的に指定し<i>ました。alter table `my_table` alter` my_column`テキスト文字セットutf8;</i> </li><li> そして、もちろん、将来のために、最後のコード： <i>alter database `my_database`デフォルト文字セットutf8;</i> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     変換時のダウンタイムなしでベースをUTF-8に変換するタスクは、通常の方法、つまりレプリカを使用して解決されました。 しかし、機能なしではありません。 まず、ウィザードからレプリカを取得するときに文字列が自動的に変換されるようにするには、 <i>ステートメント</i>モードでレプリケーションが必須であることが必要です。rawモードでは、変換は実行されません。 次に、 <i>ステートメント</i>レプリケーションに切り替えるには、 <i>トランザクション分離レベル</i>をデフォルトの<i>反復可能読み取り</i>から<i>コミットの</i> <i>読み取り</i>に変更する必要もあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     実際に次のように変換されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> ウィザードをステートメント複製モードに切り替えます。 </li><li> 変換のためにデータベースの一時コピーを作成し、その上で変換を実行します。 </li><li> 変換の最後に、メインデータベースからレプリカモードにコピーを転送します。データが追いつき、行もその場で変換されます。 </li><li> 各レプリカベースについて： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -負荷をレプリカから一時レプリカにUTF-8で転送します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -すべてのレプリカを一時ベースからゼロから転送し、そこから複製を有効にします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -負荷をレプリカに戻します。 </li><li> 一時ベースをウィザードモードに転送し、NATを使用して古いマスターから一時マスターに要求を転送します。 </li><li> 古いマスターをタイムベースから転送し、レプリケーションに追いつきます。 </li><li> マスターを元に戻し、NATを削除し、レプリケーションを混合に戻します。 </li><li> 一時ベースを無効にします。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     その結果、3か月間の骨の折れる作業で、15個の異なるベーススキームで98個すべてのマスター（およびレプリカの束）を変換することができました（特に大きな1つの750GBベースがほぼ2週間のマシン時間で変換されました）。 管理者は泣き、夜は眠れませんでした（開発者に眠らせないこともありました）が、それでも私たちが望むほど速くはないプロセスが続いた。 最初に、彼らは最善を望み、上記のスキームに従って変換を実行しました;プロセスをスピードアップするために、彼らはSSDディスクを搭載したマシンを使用しました。 しかし、3か月目の終わりに、この状況ではさらに2か月が必要であることに気付き、彼らはそれに耐えられず、負荷全体をレプリカからマスターに転送し、古いレプリカに直接変換し始めました。 幸いなことに、この期間中にマスターで異常な状況は発生せず、1週間以内に（主にレプリカがかなり弱い古い車で回転していたため）、変換は完了しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     データベース自体の変換に加えて、コードでUTF-8のサポートを取得し、スムーズで目立たない移行を保証することも必要でした。 ただし、MySQLではすべてが簡単です。 事実、彼はデータを保存する個別のエンコーディングと、クライアントにデータを提供する個別のエンコーディングを持っています。 歴史的に、サーバー上では、 <i>character_set_ * = cp1251</i>と書かれてい<i>ました</i> 。 パラメータ<i>character_set_client、character_set_connection、character_set_results</i>については、古いクライアントを壊さないように何も変更せず、cp1251を残しました。 残りはutf8に置き換えられました。 その結果、cp1251で動作する古いクライアントは、データベースが変換されているかどうかに関係なくcp1251でデータを受信し、接続を確立した後、UTF-8で動作する新しいクライアントはすぐにset names utf8コマンドを実行します; このエンコードのすべての利点を使用し始めます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> タランツール </h1>タランチュラとは何なのか、もうわかりません。 このMy Worldの発案はすでに十分な名声を得ており、優れたオープンソース<a href="http://tarantool.org/">プロジェクトに</a>成長しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     その使用の長年にわたって、私たちはその中に膨大な量の情報を蓄積することができました。そして、タランチュラのインスタンスが400個あることが判明したとき、率直に言って、変換に時間がかかるのは怖かったです。 しかし、幸いなことに、そのうち60のみがテキストフィールド（主にユーザープロファイル）を持っていることがわかりました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     確かに、タランチュラのトランスコーディングは非常に興味深いタスクであることが判明しました。 そして、解決策は非常にエレガントでした。 しかし、もちろん、完全にそのままではありません。 タランツールがオープンソースプロジェクトとして開発を始めた後、コミュニティと私たちのニーズはわずかに異なることが判明したという歴史的な事実をすぐに確認します。 コミュニティには、わかりやすい製品、すぐに使えるキーバリューストレージが必要ですが、モジュラーアーキテクチャ（ストレージを書き込むためのフレームワーク）、高度に特殊化された追加機能、パフォーマンス最適化を備えた製品が必要です。 そのため、どこかでタランツールを使い続け、どこかで最初のタランチュラの作者が開発したフォーク<a href="https://github.com/delamonpansie/octopus">タコ</a>を使い始めました。 これにより、変換プロセスが大幅に簡素化されました。 実際、タコではluaに複製フィルターを書き込むことができます。つまり、ウィザードのスナップショットとxlogから元のコマンドを送信するのではなく、lua関数を使用して変更を通過します。 この機能は、マスターからのすべてのデータではなく、特定のタプルフィールドのみを含む部分レプリカを作成できるようにするために、かなり前に追加されました。 そして、私たちは同じ方法で、複製のプロセスでその場でテキストをトランスコードできるという考えを得ました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それでも、このタスクのタコはわずかに終了する必要がありました： <i>フィーダー</i> （xlogレプリカを供給するウィザードプロセス）は長い間別個のタコモジュール<i>mod_feeder</i>として実装されてきましたが、ストレージなしでは個別に起動できませんでした（この場合、 <i>キー</i> - <i>mod_box</i>モジュールによって実装された値）。これは、レプリケーションメカニズムの変更がウィザードの再起動を必要としないようにするために必要でした。 もちろん、私はluaでレプリケーションフィルターを作成する必要がありました。これは、名前空間ごとに必要なフィールドをCP1251からUTF-8に変換しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     タランチュラとタコで実際にデータを変換することに加えて、まだ変換されているがまだ変換されていないシャードを使用してコードの透過的な動作を確保するとともに、CP1251での作業からUTF-8での作業へのアトミックスイッチングを提供する必要がありました。 そのため、ストレージの前に特別なトランスコーディングプロキシを配置することが決定されました。これは、クライアントのリクエストのフラグに応じて、ベースエンコーディングからクライアントエンコーディングにデータを変換します。 ここで、タコが再び私たちの助けになりました。または、 <i>mod_colander</i>モジュールを使用すると、luaを含む高速プロキシサーバーを作成できます（タコはluajitとffiを使用するため、非常に生産的です）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     合計で、tarantool / octopusからUTF-8への変換スキームは次のとおりです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> マスターとレプリカで<i>utf8proxyを構成</i>します。 タランチュラが以前聞いていた港でそれを上げ、別の港にタランチュラ自身を再設置します。 これ以降、クライアントはCP1251とUTF-8の両方で要求を満たすことができます。 </li><li> ウィザードを備えたサーバーで、変換<i>utf8feederを</i>実行し、ウィザードが書き込む同じディレクトリからスナップショットとxlogを読み取るように構成します。 </li><li> 別のサーバーでは、ウィザードの一時的なレプリカを作成し、変換中のフィーダーから複製するように構成します。 データは、UTF-8エンコーディングで一時的なレプリカにすでに到着しています。 </li><li> 一時レプリカから複製するように構成した<i>utf8proxy</i>レプリカ、一時レプリカから古いレプリカを転送してから、負荷を戻します。 </li><li> ポートを<i>utf8proxy</i>マスターにファイアウォールし（更新に競合がないように）、 <i>utf8proxy</i>を一時レプリカに再構成し、一時レプリカを一時マスターにし、古いマスターを消滅させ、ポートを<i>utf8proxyに起動し</i>ます。 </li><li> 新しいマスターを一時的なマスターから転送し、レプリカを複製に切り替えます。 </li><li>  <i>utf8proxy</i>を使用して、新しいマスターをマスターにし、一時マスターをオフにします。 このステップでは、すべてのインスタンスにUTF-8のデータが含まれているため、クライアントから非キリル文字のテキストの書き込みを開始できます。 </li><li> すべてのクライアントがUTF-8に移行した後、 <i>utf8proxyを削除し</i>ます。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/c22/dbe/bf9/c22dbebf901b4a41be43fe136241a772.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     タランチュラ/タコのトランスコードのプロセス全体に約1か月かかりました。 残念ながら、いくつかのオーバーレイがありました。複数のシャードを並行して変換したため、マスターを戻すときに2つのシャードを所定の場所で混在させることができました。 問題が発見されるまでに、かなりの量のデータ変更がすでに発生していました。 両方のシャードからのxlogを分析し、正義を回復する必要がありました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Memcached </h1> 一見、キャッシュの変換が最も簡単だと思われます（いずれにせよ、最初はそうでした）：別の名前のキーにUTF-8を書き込むか、他のインスタンスに書き込みます。 しかし、実際にはこれはうまくいきません。 これには2つの理由があります。1つ目は、2倍のキャッシュが必要になること、2つ目は、エンコードを切り替えるときにキャッシュが非加熱になることです。 複数のサーバー間でスムーズに切り替えることで2番目の問題に対処できる場合、多数のキャッシュがある場合、最初の問題ははるかに複雑になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そのため、各キーに、そのキーが格納されているエンコーディングに関するフラグを立てるというパスをたどりました。 さらに、 <i>キャッシュの</i>パールクライアント<i>:: Memcached :: Fast memcacheには</i>既にこの機能があります： <i>キーフラグ</i> （ <i>F_UTF8 = 0x4</i> ）の1つでmemcacheに行を保存するとき、 <i>SVf_UTF8</i>行の内部パールフラグを書き込みます。 。 したがって、フラグが設定されている場合、行はUTF-8で明確になり、そうでない場合、すべてが少し複雑になります。この行はCP1251のテキストまたはバイナリのいずれかです。 もちろん、必要に応じてテキスト文字列を変換しますが、バイナリに問題がありました：不必要な変換でそれらを壊さないために、テキスト文字列とバイナリのset / get（など）メソッドを分離し、memcachedに保存されたすべてのバイナリ文字列を見つけ、それらを受け取り、自動トランスコーディングなしで適切な方法に置き換えます。 同じコードがシッシュコードに適用され、 <i>F_UTF8</i>フラグのサポートが追加されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> その他のリポジトリ </h1> 前述の標準リポジトリに加えて、「新機能」のテープ、コメント、メッセージキュー、ダイアログ、検索などを保存するために使用される膨大な数の自己記述型リポジトリを使用します。 それぞれについて詳しく説明するのではなく、主なケースとそれらを解決する方法にのみ注目します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <b>ダウンタイムなしでストレージを変換することは困難です。または、すぐに新しいストレージにデータを転送するか、寿命の短いデータを転送する予定です。</b> そのような場合、データは変換されませんでしたが、新しいレコードには、レコード全体がどのエンコーディングに含まれているかを示すフラグを使用するか、UTF-8の場合は各文字列フィールドの先頭にBOMマーカーを使用するという2つの方法のいずれかでエンコーディング記号が付けられました。 </li><li>  <b>行自体がリポジトリに保存されるのではなく、それらからのハッシュ合計が保存されます。</b> 検索のために使用されます。 彼らは、UTF-8に変換された元の文字列からハッシュ合計を再レンダリングするスクリプトを使用して、リポジトリ全体を歩き回りました。 変換時には、各検索クエリに対してデータベースへの2つのクエリを実行する必要がありました。1つはCP1251で、もう1つはUTF-8です。 </li><li>  <b>リポジトリの前にプロキシが既にインストールされており、リポジトリへのすべてのリクエストはプロキシを通過します。</b> この場合、タランチュラの場合と同様にプロキシに変換されますが、タランチュラの一時的な機能である場合、唯一の違いは、この場合、データベースに保存されているデータが関連するまで残ることです。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> コードでのUTF-8サポート </h1> 管理者がデータベースを変換する方法と並行して、開発者はコードをUTF-8エンコーディングで動作するように適合させました。 コードベース全体は、Perl、C、テンプレートの3つの部分に条件付きで分割されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プロジェクトをUTF-8エンコーディングに切り替える手順を設計する際の重要な要件の1つは、1つのサーバーを切り替える機能でした。 まず、これは、最初にテスターの努力によって、次にユーザーの数パーセントによって、戦闘ベースを使用してUTF-8でプロジェクトをテストする可能性を確保するために必要でした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  PerlおよびUTF-8 </h1>  UTF-8で動作するようにパールコードを適合させるには、いくつかの基本的な問題を解決する必要がありました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> コードに散在するキリル文字列を変換します。 </li><li> すべてのストレージとサービスに接続するときは、サーバーのエンコードを検討してください。 </li><li>  HTTPリクエストのパラメータが、サーバーが実行されているエンコーディングに含まれない可能性があることを考慮してください。 </li><li> サーバーエンコーディングでコンテンツを提供し、正しいテンプレートを使用する必要があります。 </li><li> バイト文字列と文字列を明確に論理的に分離し、入力でUTF-8（バイトから文字）をデコードし、出力でエンコードする必要があります。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     パールコードをCP1251からUTF-8に変換するというタスクをやや非自明な方法で解決しました：フィルターを使用してコンパイルするときに、その場でモジュールを変換することから始めました（ <i>perlfilter</i>および<i>Filter :: Util :: Callを</i>参照してください。ディスクとコンパイル）。 これは、リポジトリブランチのマージ中に複数の競合を回避するために必要でした。これは、1つの別個のブランチでレポジトリを変換し、開発およびテストプロセス中に保管しようとした場合に発生します。 テストプロセス全体と起動後最初の1週間、サーバーがUTF-8として構成されている場合、ソースコードは引き続きCP1251に残り、デーモンの起動時にバトルサーバーで直接変換されました。 ローンチの1週間後、リポジトリを変換し、すぐにマスターで結果を凍結しました。 その結果、マージとの競合は、この時点で開発中だったブランチでのみ発生しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最もルーチンは、UTF-8全体に変換しなかったストレージの自動文字列変換を必要なすべての場所に追加するプロセスでした。 しかし、真珠での文字列変換が不要な場合でも、真珠ではバイト文字列と文字列の間に差がある（そして重要な）ことを考慮する必要がありました。 もちろん、データベースから読み取った後、すべてのテキスト行を自動的にシンボリックにしたかったため、バイナリデータが転送されるかテキストであるかについてすべての入力/出力を分析する必要があり、すべての必要な行をunpackedとしてマークするためにpack / unpackのすべての呼び出しを実行する必要がありましたシンボリック（またはパッケージを作成する前に、文字列バイトを作成して、長さを文字ではなくバイトでカウントする）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      HTTPリクエストパラメータがCP1251またはUTF-8（リファラーページが読み込まれたエンコーディングに応じて）に来るという事実の問題は、リクエストで追加のパラメータを渡すことで最初に解決することが望まれていました。 しかし、その後、CP1251とUTF-8がどのようにエンコードされているかを分析した後、文字列が有効なUTF-8であるかどうかをチェックすることで、CP1251のキリル文字とUTF-8のキリル文字を常に明確に区別できるという結論に達しましたCP1251では、有効なUTF-8をコンパイルすることはほとんど不可能です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一般に、UTF-8での作業が真珠で組織化される方法は、非常に便利ではありますが、それでも魔法であることが多く、次のことに留意する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 行に<i>SVf_UTF8</i>フラグがあることを忘れてください（デバッグにのみ役立ちます）。代わりに、行をバイトと文字として扱う方が良いです。フラグ<i>SVf_UTF8を</i>持つ真珠線の内部表現がUTF-8であることを忘れてください。 </li><li> 関数<i>Encode :: _ utf8_on（）、Encode :: _ utf8_off（）、utf8 :: upgrade（）、utf8 :: downgrade（）、utf8 :: is_utf8（）、utf8 :: valid（）;</i> </li><li> 文字のUnicode文字列をUTF-8に変換するときは、 <i>utf8 :: encode（）を</i>使用します。 </li><li> パールの場合、 <i>UTF-8</i>エンコーディングと<i>utf8</i>エンコーディングはわずかに異なるエンコーディングであることを考慮してください：最初の場合、コードポイント&lt;= 0x10FFFF（Unicode標準で定義されている）のみが有効で、2番目の場合、IV（アーキテクチャに応じてint32またはint64）、 UTF-8エンコードアルゴリズムを使用してエンコード。 </li><li> したがって、 <i>utf8 :: decode（）</i>は、UTF-8を無効にできない信頼できるソース（独自のデータベース）からのデコードにのみ使用でき、外部入力をデコードするときは常に<i>Encode :: decode（ 'UTF-8 '、$ _）</i> Unicodeの観点から無効なコードポイントから保護します。 </li><li>  <i>utf8 :: decode（）</i>関数の結果は、バイト文字列が有効なutf8であるかどうかを確認するのに役立つ場合があることを忘れないでください。有効なUTF-8の確認と同じ目的で、 <i>Encode :: decode（）の</i> 3番目のパラメーターを使用できます<i>。</i> </li><li>  latin1テーブルの上半分には同じ番号のUnicodeコードポイントと同じ文字が含まれていますが、UTF-8では異なる方法でエンコードされることに注意してください。 これは、誤ったダブルコール<i>utf8 :: decode（）</i>の結果に影響します。ASCIIテーブルのコードポイントのみを含む文字列、またはコードポイント&gt; 0xffの文字を少なくとも1つ含む文字列の場合、すべてが正常に動作しますが、テーブルlatin1とasciiの上半分で、latin1のキャラクターがbeられます。 </li><li> 最新の真珠を使用してください。  perl 5.8.8で、すばらしいバグを思い付きました： <i>使用ロケール</i>と正しい入力を持ついくつかの正規表現の組み合わせにより、正規の無限ループが発生します。 厳密に必要な関数のセット（ <i>sort、cmp、lt、le、gt、ge、lc、uc、lcfirst、ucfirst）</i>についてのみ<i>、ロケール</i>の<i>使用</i>範囲を可能な限り制限する必要があり<i>ました。</i> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  CおよびUTF-8 </h1> 幸いなことに、Cコードには真珠ほど多くの行がありませんでしたので、古典的な道を歩きました。すべてのキリル行を別のファイルに取りました。 これにより、単一ファイル内のマージとの潜在的な競合を制限することができ、その後のローカライズも簡素化されました。 リポジトリをUTF-8に変換する過程で、彼らは何か面白いものを見つけました-コード内のロシア語のコメントは、4つのキリル文字エンコード（cp1251、cp866、koi8-r、iso8859-5）に含まれていました。 変換中に特定の各行のエンコーディングの自動検出を使用する必要がありました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     リポジトリの変換に加えて、Cは基本的な文字列関数のサポートも必要としました：文字の長さの決定、レジスタのキャスト、長さによる文字列のトリミングなど<i>。C</i>でUnicodeを操作するためのすばらしい<i>libicu</i>ライブラリがありますが、内部表現としてUTF-16を使用します。 もちろん、UTF-8とUTF-16の間のトランスコーディングのオーバーヘッドを回避したかったため、最も一般的に使用される単純な関数では、トランスコーディングなしでUTF-8で直接動作するアナログを実装する必要がありました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> テンプレート、javascriptおよびUTF-8 </h1> 幸いなことに、テンプレートを使用すると、すべてが非常にシンプルになりました。 本番環境では、これらはrpmパッケージに配置されているため、論理的な解決策はトランスコードをrpmビルドプロセスにカットすることでした。  UTF-8のテンプレートを含むパッケージをもう1つ追加しました。これは隣接するディレクトリにインストールされ、その後コード（pearlとsylvianの両方）は対応するディレクトリからテンプレートを選択しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      JavaScriptを使用すると、そのままでは機能しませんでした。  JavaScriptをロードするとき、ほとんどのブラウザーはそのContent-Typeを考慮しますが、そうでない古いインスタンスがいくつかありますが、ページエンコーディングに焦点を当てています。 したがって、彼らは松葉杖を置きます：javascriptでパッケージを構築するとき、すべての非ASCII文字をコードポイント番号の形式のエスケープシーケンスに置き換えました。 このアプローチでは、jsのサイズは大きくなりますが、ブラウザーはそれを正しくロードします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> 結果は何ですか </h1> 最後に、半年後、ソリティアは一緒になりました。 管理者は数百のデータベースの再コーディングを完了し、開発者はコードを終了し、テストプロセスも終了しました。 ワールドコントロールパネルのノブを徐々に切り替えました。まず、同僚のすべてのアカウントがUTF-8に転送され、次にユーザーの1％が転送され、その後バックエンドサーバーと10台のフロントエンドサーバーをそれぞれ10サーバーずつ切り替え始めました。 視覚的には、プロジェクトページもロードスケジュールも変更されず、喜ばずにはいられませんでした。 理由なく半年が経過したことが明らかになった唯一の外部の変更は、 <i>char-</i> <i>set = windows-1251</i>の<i>Content-Type</i>行<i>をcharset = UTF-8に変更したこと</i>です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それから3か月が経ち、ロシア語を話すユーザーはすでにテキストに絵文字やその他のささいなことを挿入する機能を高く評価しており、カザフ語は母国語で対応し始め、最近ではウェブインターフェイスとモバイルアプリケーションを母国語で使用する機会があります。  unicode'izationに続くプロジェクトの国際化とローカリゼーションのプロセスには、興味深いタスクが十分にありました。これについては別の記事を作成するようにします。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J235197/index.html">オープンな再帰DNSサーバーはどのくらい危険ですか？</a></li>
<li><a href="../J235199/index.html">キュービートラック。 旅行ミニサーバー。 パート2</a></li>
<li><a href="../J2352/index.html">SocialtextはオフラインWikiを編集します</a></li>
<li><a href="../J235205/index.html">CoffeeScript開発者向けの小さなユーティリティ</a></li>
<li><a href="../J235207/index.html">ArduinoなしでOpenWRTからサーボを制御します</a></li>
<li><a href="../J235213/index.html">Windows Phone用のOpenstreetmap地図ベースのナビゲーションアプリ</a></li>
<li><a href="../J235215/index.html">RTL-SDRでのKVの受信、コンバーターなしで無料</a></li>
<li><a href="../J235217/index.html">アシスタント開発者としてのWindows RT-使用経験</a></li>
<li><a href="../J235225/index.html">夏の過ごし方：Computer Continuum-2014 Summer School</a></li>
<li><a href="../J23523/index.html">Linuxのショートカット</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>