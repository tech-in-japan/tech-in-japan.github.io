<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💠 ♣️ ⏮️ 将来のWinRTまたはGoing Native 2.0 💭 📭 🍤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Windows 8 Metroをサポートする唯一のDirectXの最速かつ最も完全な.NETラッパーの作成者であるAlexandre Mutelは、フランスのデモグループFRequencyのメンバーであるSiliconStudioのゲームエンジンのR＆D開発者として働いています。 
  
 
  
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>将来のWinRTまたはGoing Native 2.0</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body">  <i>Windows 8 Metroをサポートする唯一のDirectXの最速かつ最も完全な.NETラッパーの作成者であるAlexandre Mutelは、フランスのデモグループFRequencyのメンバーであるSiliconStudioのゲームエンジンのR＆D開発者として働いています。</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最近、Javaや.NETなどのマネージ言語の時代以降、「Going Native」のアイデアが復活したことについて多くのノイズを耳にしました。 昨年、WinRTが導入されたばかりのとき、.NETは死んでC ++はその栄光をすべて返していると主張するそれほど遠くないコメントが現れ始めました-JITが始まっている間、アプリケーションを開発する真の唯一の方法スクリプト言語の世界にはますます登場しています（JavaScriptはJITの利点を最も積極的に使用しています）。 何らかの方法でコードは実行前にネイティブになります-唯一の違いは、ネイティブになるパスの長さと、最適化される方法です。  「ネイティブ」という言葉の意味は少し変わり、「パフォーマンス」という言葉と密接に関連しています。 マネージ言語[C＃]の強力なプロモーターとしても、そのパフォーマンスは、実際に作成されたC ++アプリケーションよりも低くなります。  WinRTのようなものが言語間の相互作用の基礎になる場合、この事実を受け入れてC ++に戻る必要があることがわかりました。 本当は、.NETが死ぬことを望みます。この投稿では、理由と理由について説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 制御言語の時代 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     管理言語での開発の最近の歴史を確認し、現在の問題を強調しましょう。 スローガンJavaを覚えていますか？  「Write Onceはどこでも実行されます。」 これは、完全に「安全な」仮想マシン言語と豊富なAPIのセットが、あらゆるOSおよびプラットフォーム向けのアプリケーションを簡単に開発する機会を提供する新しいパラダイムの導入でした。 これは、制御言語の時代の始まりでした。  Javaはさまざまな開発業界で非常にうまく採用されましたが、メモリ管理の機能、不十分に最適化されたJIT（それ以降はすべてが大幅に改善されていますが）、不足しているなどの多数の悪いアーキテクチャソリューションを認識している多くの開発者によって拒否されました構造のサポート、メモリへの直接アクセス、およびJNIを介したネイティブコードの呼び出しは、非常に非効率的で時間がかかりました（さらに<a href="http://marxsoftware.blogspot.jp/2011/10/javaone-2011-from-java-se-2012-to-java.html">最近では、</a>すべてのネイティブタイプのオブジェクトを削除して、  lすべてのオブジェクト-なんてひどいアイデアでしょう！）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     また、Javaはスローガン自体の約束を果たすことができませんでした。実際、各プラットフォームのすべての機能を単一のAPIでカバーすることは不可能であり、Swingのようなものに至り、最適なUIフレームワークではありません。 また、Javaはもともと単一のプログラミング言語向けに設計されていましたが、多くの人はJITとバイトコードでスクリプト言語をJava JVMに移植する能力を見出しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     マネージド言語の時代の初めに、マイクロソフトは言語の独自の拡張機能（誰もがこの話の終わりを知っている）でJava市場に参入しようとし、最終的にはマネージド言語用の独自のプラットフォームを取得しました。安全ではない、ネイティブコードの呼び出し、軽量だが非常に効率的なJITおよびNGEN、急成長しているC＃、C ++ / CLI言語など。最初は、言語間の相互作用を考慮し、Javaスローガンの負担なしで（MacOSまたはMoonlight上のSilverlightは悪くない 試行）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     両方のプラットフォームは、同様のモノリシックスタックを使用しました。メタデータ、バイトコード、JIT、ガベージコレクター-これらはすべて密接に関連しています。 したがって、同様のパフォーマンス上の問題がありました。JITは起動時の遅延を意味し、コードの実行は本来の速さではありません。 主な理由： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  JITはコードを非常に迅速に生成する必要があるため、C ++ -O2と比較して不十分な最適化を行います（また、Java HotSpot JVMとは異なり、.NET JITは既存のコードをその場で最適化されたコードに置き換えることはできません）。 </li><li>  Arrayなどの.NETタイプは、アクセス時に常に境界チェックを行います（単純なループはカウントしません。ループ終了条件が配列の長さ以下である場合、JITはチェックを削除できます）。 </li><li> ガベージコレクターは、アセンブリ中にすべてのスレッドを停止します（ただし、.NET 4.5の新しいガベージコレクターはこの点で多少<a href="http://blogs.msdn.com/b/dotnet/archive/2012/07/20/the-net-framework-4-5-includes-new-garbage-collector-enhancements-for-client-and-server-apps.aspx">改善さ</a>れています）。これにより、予測できないパフォーマンス低下が発生する可能性があります。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、パフォーマンスがこのように低い場合でも、ユニバーサルフレームワークを備えた管理されたエコシステムは、生産性と言語間の相互作用の王様であり、サポートされているすべての言語で全体的なパフォーマンスがまともです。 管理言語の時代のクライマックスは、おそらくWindowsPhoneとVisualStudio 2010（WPFを使用してインターフェイスをレンダリングしましたが、WPF自体はかなりの量のネイティブコードの上で機能していました）の発売でした。 マネージド言語は、当時アプリケーションを開発する唯一の許可された方法でした。 未解決の.NETパフォーマンスの問題の長いリスト、「ネイティブ開発者」の反撃を促すのに十分な長さを考えると、これは起こる可能性のある最高のものではありませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これは、ある意味で.NETを放棄することを意味することが判明しました。  Microsoftの内部キッチンについてはあまり知りませんが、頻繁に報告されていることから判断すると、部門間には強い対立があります。 良くも悪くも、近年の.NETの場合、Microsoftのパフォーマンスは低下しているようです（たとえば、JIT / NGENには実質的に大きな改善はありません。開発者が待ち望んでいるSIMDのようなものを含む、パフォーマンスの改善に対する多くの未解決の要求はありません）すでに非常に長い時間）。 そして、これらの変更はすべて、.NETがグローバル戦略であり、すべての部門の強力なサポートと参加がある場合にのみ可能であるように思えます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     同時に、Googleはブラウザから直接サンドボックスでネイティブコードを実行できるNativeClientテクノロジーの宣伝を開始しました。 昨年、「Going Native」トレンドに従って、Microsoftは次のIE用に設計されたHTML5でもネイティブになると発表しました。 シック。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「 <a href="http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/">リーダーQ＆A：優れたJITがマネージコードを節約するのはいつですか？</a> 」で、Going Nativeエバンジェリストの1人であるHerb Sutterが、JITの「Going Native」思考の哲学に対する興味深い洞察を提供します（「JITを<a href="http://tirania.org/blog/archive/2012/Apr-04.html">高速化できますか？</a> 」 Miguel de Icazaの投稿）多くの不正確な事実がありますが、キーを見てみましょう：JITが将来良くなったとしても、マネージド言語はセキュリティを優先してパフォーマンスとセキュリティのどちらかをすでに選択しています。 したがって、大リーグへの道はすでに彼らのために注文されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     その瞬間、WinRTが表示され、鋭い角が少し滑らかになります。  .NETの哲学の一部（メタデータおよび文字列や配列などのいくつかの一般的な型）と古き良きCOMモデル（ネイティブの言語間相互作用の共通分母として）を使用して、WinRTはCLR世界以外の言語相互作用の問題を解決しようとします（つまり、パフォーマンスの低下はありません） C ++）およびOS用の最新のAPIを提供します。 これは、生命、宇宙、その他すべての主要な質問に対する答えですか？ そうでもない。  WinRTの場合、彼らは偉大なことにつながる可能性のあるテクノロジーの明確な収束に向けたコースを選択しましたが、今のところ正しい道を選択する確実性はありません。 しかし、この「正しい方法」は何でしょうか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Going Native 2.0-みんなのパフォーマンス </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     セキュリティチェックはパフォーマンスに悪影響を与える可能性がありますが、マネージコードは遅いJITでその寿命を実行する運命にありません（たとえば、MonoはiOS / LinuxでLLVMを介してネイティブにコンパイルされたC＃コードを実行できます）。安全でない命令でバイトコードを拡張するのは非常に簡単です制御されたパフォーマンスの改善を提供します（配列境界チェックのオーバーライドなど）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、現在最も明白な問題は、言語間コンパイラ用の強力なインフラストラクチャの欠如です。  IE 10 JavaScript JIT、.NET JIT、NGENコンパイラ、およびVisual C ++コンパイラ（および他の多く）で使用されるコンパイラから始まります-それらはすべて、ほぼ同じ時間のかかる複雑なタスクのために異なるコードを使用し、効率的なマシンコードを生成します。 単一のコンパイラを自由に使用できるようにすることは、すべての言語で利用可能な高性能コードを提供する上で非常に重要なステップです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Channel9のFelix9 <a href="http://channel9.msdn.com/Forums/Coffeehouse/MS-working-on-a-same-compiler-for-C-AND-C--Not-in-incubation-but-for-production-">は</a> 、Microsoftがこの問題に実際に取り組むことができることを<a href="http://channel9.msdn.com/Forums/Coffeehouse/MS-working-on-a-same-compiler-for-C-AND-C--Not-in-incubation-but-for-production-">発見</a>しました。 これは間違いなく朗報ですが、「すべての人のためのパフォーマンス」の問題は全体像のほんの一部です。 実際、前述の「正しい方法」は、 <a href="http://llvm.org/">LLVM</a>スタックの改善だけでなく、Microsoftのさまざまな分野（C ++コンパイラ、JIT、ガベージコレクタ、メタデータなど）システムでの長年の経験によってサポートされる、より広範な統合アーキテクチャです。以下で構成される<b>完全に拡張可能なモジュラー「CLR」</b>を提供します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> <b>中級中間言語</b> 。  LLVM IRまたは.NETバイトコードによく似た反射型で、一般的なデータ型（プリミティブ、文字列、配列など）を定義します。  System.Reflection.Emitに似たAPIが利用可能になります。 ベクトル化型（SIMD）は、intおよびdoubleと同じくらい基本的でなければなりません。  ILコードはCPUのみに限定されるべきではなく、GPUコンピューティングも許可する必要があります（C ++のAMP拡張機能が行うように）。 このILを使用して、単一のコンパイラインフラストラクチャを利用してHLSLバイトコードを表すことができるはずです（以下を参照）。 動的プログラミング言語を移植しやすくするために、タイプレスILも利用できるようにする必要があります。 </li><li>  <b>メタデータを提供する.NETアセンブリ、</b>リフレクションをサポートする<b>ILコードなど、動的にリンクされたライブラリと実行可能ファイル</b> 。 設計時には、コードはレガシーC / C ++ヘッダーファイルではなく、アセンブリ（ILコード）と通信する必要があります。 </li><li>  <b>ILから</b> JIT、デスクトップアプリケーション、クラウドコンパイラ、またはこれらすべての組み合わせに統合できる<b>マシンコード</b>へのコンパイラ。 このコンパイラは、ターゲットプラットフォームがサポートする限りのベクトル化を提供する必要があります。  ILコードは、インストールまたは展開中にシステムアーキテクチャに関する情報を使用してマシンコードにコンパイルする必要があります（開発中、これはILへのコンパイル後すぐに実行できます）。 コンパイル手順はAPIを介してアクセス可能であり、可能な限り拡張ポイントを提供する必要があります（ILへのアクセスの提供、ILの最適化、またはILからマシンコードへのネイティブ変換の埋め込み）。 最適化設定は、高速コンパイル（JITなど）から積極的な最適化（事前にコンパイルされたアプリケーション、または生産性を高めるためにJITでホットスワップするコード）に及ぶ必要があります。 アプリケーションプロファイルを使用して、ローカライズされた最適化を自動的に微調整することもできます。 このコンパイラは、動的コード分析、On Stack Replacement（複雑な計算のコードを実行時に最適なコードに置き換えることができるOSR）などの高度なJIT使用シナリオをサポートする必要があります。最初の起動時。 この種の最適化は、（Javascriptの場合のように）コンパイル後に型推論が発生する動的シナリオで非常に重要です。 </li><li>  <b>並列メモリ割り当てを可能にする、メモリ割り当て用の拡張可能なコンポーネント。</b>  <b>ガベージコレクターは、可能な実装の1つになります</b> 。 ほとんどのアプリケーションはほとんどのオブジェクトに使用しますが、最もパフォーマンスが重要なオブジェクトは他のメモリ割り当て戦略（COM / WinRTで使用されるリンクカウントなど）を使用します。  1つのアプリケーションでの複数のメモリ割り当て戦略の使用に制限はありません（これは、アプリケーションがネイティブ関数呼び出しを使用してCLRの外部にオブジェクトを作成することに頼らなければならないときに.NETでまさに発生します）。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアイデアはCLRスタックに非常に近いですが、アプリケーションをJITコンパイラーの上で実行することを強制しません（はい、.NETにはNGENがありますが、全体の作業をスピードアップするのではなく、ロードをスピードアップするように設計されました。さらに、ブラックボックスであり、アセンブリでのみ動作しますGACにインストールされます）、メモリを割り当てるための混合戦略を可能にします：ガベージコレクターを使用して、それなしで 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そのようなシステムでは、単純化のためにパフォーマンスを犠牲にすることなく、言語間相互作用がより単純になり、逆もまた同様です。 理想的には、OS自体を同様のアーキテクチャに基づいて構築する必要があります。 おそらく、この考えは（そこにあるのでしょうか？） <a href="http://www.zdnet.com/blog/microsoft/microsoft-codename-redhawk-lives-in-windows-8/9233">Redhawk</a> （これはコンパイラー向け）や<a href="http://www.zdnet.com/blog/microsoft/goodbye-xp-hello-midori/1466">Midori</a> （OS向け）などのプロジェクトの基礎でした。 このような統合システムでは、おそらくドライバーのみがハードウェアへの直接アクセスを必要とします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Felix9は、MDILと呼ばれるMSIL（.NETバイトコード）よりも低いレベルの中間バイトコードが既に使用可能であり、前述の中間バイトコードである可能性があることも<a href="http://channel9.msdn.com/Forums/Coffeehouse/MS-patent-Optimizer-as-an-AppStore-Service-Cloud-JIT-/c539c486cf914d3ab718a0a700fb473e">発見</a>しました。 ただし、対応する特許「 <a href="http://www.freepatentsonline.com/y2011/0258616.html">変更耐性のための中間言語サポート</a> 」を見ると、仕様には、アーキテクチャに依存しないバイトコードの定義に完全には適合しないx86命令があります。 おそらく、MSILは変更せずに、MDILをより低いレベルで使用します。 すぐにわかります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     では、WinRTはこの観点からどのような問題を解決しますか？ メタデータ、サンドボックスをサポートするAPIの一部、および初期の言語間相互作用（一般的なデータ型とメタデータがありますが）。 ご覧のように、多くではなく、一種のCOM ++です。  <b>APIを使用する場合</b> 、 <b>WinRTが高度な最適化を提供しないこと</b>も明らかです。 たとえば、メソッドが埋め込まれた構造を持つことは許可されていません。  WinRTの各メソッド呼び出しは、仮想メソッドのテーブルを通過する仮想呼び出しです（場合によっては、静的メソッドを使用する場合など、いくつかの仮想呼び出しが必要になります）。 最も単純な読み取り/書き込みプロパティには、仮想呼び出しが必要です。 これは明らかに非効率的です。 どうやらWinRTは高レベルのAPIのみに焦点を当てており、可能な限り高性能なコードを使用したいシナリオを許可せず、仮想呼び出しと非埋め込みコードのレイヤーをバイパスします。 その結果、拡張されたCOMモデルがあります。これは、まさに「未来の構築」と呼ばれるものではありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  C＃5.0の生産性とパフォーマンス </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      C＃のような言語は、このようなモジュラーCLRシステムの理想的な候補であり、既存の中間バイトコードに簡単に移植できます。 しかし、そのようなシステムを効果的に使用するには、C＃をいくつかの面で改善する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>より安全ではない構造</b> 、配列の境界をチェックするような「制御された」動作をオフにできるとき（「スーパー安全モード」など、CPUでキャッシュ命令を使用して配列の要素にアクセスできるとき）、この種の「高度な」ことは今では不可能です文書化されていないトリックを使用しないマネージドアレイ）。 </li><li> さまざまなメモリ割り当てスキームをサポート<b>する構成可能な新しい演算子</b> 。 </li><li>  <b>ベクトル型</b> （HLSLのfloat4など）を基本型に追加する必要があります。 これは長い間求められてきました（XNA WPにこの問題を「解決」するためのひどいパッチがあります）。 </li><li>  <b>ネイティブコードとの軽量な対話</b> ：現在の状態では、マネージコードからアンマネージコードへの移行は、パラメーターを渡さなくても非常にコストがかかります。 現在、.NET JITで生成されているx86 / x64 prolog / epilog命令がなくても、アンマネージコードにアクセスできます。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     パフォーマンスに加えて、他にも同様に重要な領域があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>ジェネリックはどこにでもあります</b> -コンストラクターおよび暗黙的な型変換では、より高度な構造（演算子のコントラクトなど）を使用し、C ++テンプレートの柔軟性に近くなりますが、より安全で混乱が少なくなります。 </li><li>  <b>構造体の継承とファイナライザー</b> （try / finallyなどの扱いにくいパターンを使用せずにメソッドが終了したときに軽量コードを実行できるようにするため）。 </li><li>  <b>より多くのメタプログラミング</b> 。 静的型、不純物（クラスの内容を別のクラス内に追加、数学関数などに便利）の拡張メソッド、コンパイル時にクラス/型/メソッドを変更（たとえば、他のメソッドまたはプロパティを追加するためにコンパイル時に呼び出されるメソッド） T4テンプレートを使用してコードを生成する代わりに<a href="http://stackoverflow.com/questions/1630815/why-isnt-the-eigenclass-equivalent-to-self-class-when-it-looks-so-similar">、Rubyのeigenclassに</a>似たクラス）。 </li><li>  <b>次の</b>ような単純な構造を使用<b>して、言語オブジェクト</b> （クラス、プロパティ、メソッド） <b>への参照を表す組み込みのリテラルまたは型</b> ：symbol LinkToMyMethod = <nobr>@ MyClass.MyMethod;</nobr>  Linq式を使用する代わりに。 これにより、INotifyPropertyChangedなどのコードの堅牢性が向上するか、WPF（現在の状態では重複コードが多く含まれる）などのすべてのプロパティベースのシステムが簡素化されます。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     主なアイデアは、 <b>C ++から削除するよりもC＃に追加する必要が少ないため、このような統合システムの機能を完全に活用し、開発者の生産性を向上させ、関連するパフォーマンスの低下を招くこと</b>です。  C ++がこれ以上のすべてをすでに提供していると主張する人もいるかもしれませんが、それがC ++が（構文の点で）乱雑であり、ほとんどの開発者にとって危険な理由です。 すべてのアプリケーションで安全でないコードを絶対に許可しますが、すべてのアプリケーションには本当に必要な場所が明確に定義されています（これは、キーで行われるように、これらの場所がコードで明示的に示されている場合、修正しやすいメモリの問題につながります） asm）。 コード内のそのような領域を追跡する方が、どこにでもあるよりもずっと簡単で安全です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 次は？ </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Microsoftが一般から特定への道を選択し、WinRTのリリースから始めて、すべての言語とシンプルな言語間相互作用のためのユニバーサルAPIを提供することを願っています。 そして、彼らは彼らのOSの次のバージョンでこれらすべてのより高度な機能を提示します。 しかし、これは理想的な状況であり、Microsoftがこれを処理できるかどうかを確認することは興味深いでしょう。  WP8の.NETアプリケーションにはクラウドでのコンパイルの利点があると最近発表したとしても、それについてはまだほとんどわかりません。それは、適応されたNGENだけです（これは、パフォーマンス指向ではなく、コードに非常に似ていますJITを生成します）またはRedHawkコンパイラはまだ導入されていませんか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      C ++コンパイラ、JIT、ガベージコレクタ、および関連するすべてのR＆Dプロジェクトの長年の開発を考えると、Microsoftにはおそらく空白のものがあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     要約すると、.NETは消滅し、管理された（セキュリティと生産性）と管理されていない（パフォーマンス）が密接に接続された、より統合されたパフォーマンス指向の共有環境に道を譲る必要があります。 そして、これはWinRT開発の次のラウンドの構造的な部分でなければなりません。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J149861/index.html">時計以上：Sony SmartWatchレビュー</a></li>
<li><a href="../J149862/index.html">エクアドル側のラテンアメリカ諸国</a></li>
<li><a href="../J149863/index.html">フロントエンド開発を簡素化するCSS3ジェネレーターの選択</a></li>
<li><a href="../J149864/index.html">スムーズな色反転のメニュー</a></li>
<li><a href="../J149865/index.html">AdvoCam FD3 DVR、詳細レビュー</a></li>
<li><a href="../J149867/index.html">iOS 5のコアデータ：既存のデータをロードおよびインポートする方法</a></li>
<li><a href="../J149868/index.html">Ubuntu One、20GBを無料で入手</a></li>
<li><a href="../J149869/index.html">Androidスマートフォンを参照したNavigonの1つの「ハック」または「強制」復元のストーリー</a></li>
<li><a href="../J149870/index.html">Googleは、メーカーの参加なしにAndroidアップデートの可能性に取り組んでいます</a></li>
<li><a href="../J149871/index.html">Xperia SL。 ソニーの次世代スマートフォン</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>