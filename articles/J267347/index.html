<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔗 🏗️ 👆 ロシアコードカップ2015の結果と決勝戦の分析 🦗 💅🏼 🧑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="9月19日土曜日、RCC 2015の最終ラウンドが開催され、2011年と2013年にRCCカップで2回優勝したPeter Mitrichevが300,000ルーブルの主賞の勝者および勝者になりました。 2位と賞金150,000ルーブルは、昨年のRCCの優勝者であるGennady Korotkevic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>ロシアコードカップ2015の結果と決勝戦の分析</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/267347/"><img src="https://habrastorage.org/files/045/2b8/962/0452b89625da47e2a99e06b3615f3ed1.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      9月19日土曜日、RCC 2015の最終ラウンドが開催され、2011年と2013年にRCCカップで2回優勝したPeter Mitrichevが300,000ルーブルの主賞の勝者および勝者になりました。  2位と賞金150,000ルーブルは、昨年のRCCの優勝者であるGennady Korotkevichが受賞しました。 昨年と同様、3位はイゴールクリコフが獲得しました。 彼の賞金は90,000ルーブルでした。 また、パベル・マリン、ウラジスラフ・エピファノフ、セルゲイ・コペリオヴィッチ、ユーリ・ピサルキク、コンスタンチン・セメノフ、ミハイル・チホミロフ、ニコライ・カリーニンの4〜10か所に参加した参加者から賞金30,000ルーブルが授与されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ラウンドのヒーロー： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 問題A（リボンベンディング）Gennady Korotkevich（ツーリスト）を解決する6分8秒で最初に、彼は45分29秒でタスクD（The Right Garden）を最初に完了しました。 </li><li> 日本からのファイナリストであるカワイ・リュウタ（アンタ）は、16分20秒で誰よりも先に問題B（コインの収集）を解決しました。 </li><li>  Petr Mitrichev（Petr）は、問題C（トポロジカルソートと子）を最初に解決したのは45分29秒でした。 </li><li> 問題F（木の上のロボット）は、ファイナリストの誰によっても解決できませんでした。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     先ほど申し上げました<a href="http://habrahabr.ru/company/mailru/blog/266509/">ように</a> 、今年のファイナルはITチャンピオンシップ独自の形式で開催されました。4時間のオンラインショーがWebサイトで放送されました。 このイベントは、ロシアの人気ショーマン、アントン・コモロフ（モスクワバウマン工科大学の卒業生）とサラトフ州立大学のプログラマートレーニングセンター、ミハイルミルザヤノフが生中継しました。 スタジオのゲストは、ロシア連邦のテレコムおよびマスコミュニケーションの大臣であるニコライニキフォロフ、大手IT企業の代表者、主要な業界専門家でした。 放送記録は<a href="https://it.mail.ru/rcc/">https://it.mail.ru/rcc/</a>で見ることができ<a href="https://it.mail.ru/rcc/">ます</a> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それでは、タスクの分析に移りましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> タスクA. <a href="http://www.russiancodecup.ru/championship/round/40/problem/A/">リボンの曲げ</a> </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>アイデア：</b>ウラジミールスミカロフ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>実装：</b> Dmitry Filippov 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>分析：</b>ドミトリーフィリッポフ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題では、1×2 <sup>nの</sup>ストリップが与えられます。最初に<i>n</i>が正確に半分に折り畳まれ、次に折り返されました。 折り畳みには2つの方法があります。左半分を右に置くか、右半分を左に置くかです。 リクエストに応答するために必要：ベンドの数によって、それが上向きか下向きかを調べます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      O（log 2 <sup>n</sup> ）、つまりO（ <i>n</i> ）の要求に応答する方法を学習します。 リクエストの総数は10 <sup>5を</sup>超えないため、これで十分です。 各リクエストの曲げプロセスをエミュレートします。 現在のリボンの長さと曲げ番号がわかれば、この番号がどちらの半分にあるかが簡単にわかります。次に、どちら側で半分に曲げが行われるかがわかり、2回切断されたリボンの新しい曲げ位置を見つけることもできます。 リクエストに答えるために、折り目が現在どの方向に向いているのかを同時にサポートします。 合計、O（ <i>qn</i> ）で解を取得します。ここで、 <i>q</i>はクエリの合計数です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> タスクB. <a href="http://www.russiancodecup.ru/championship/round/40/problem/B/">コインの収集</a> </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>アイデア：</b> Vitaly Aksenov 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>実装：</b> Boris Minaev 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>分析：</b>ボリス・ミナエフ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     タスクには、プレイヤーが歩くためのセルに分割されたテープが与えられます。 毎秒、各セルには、各セルに固定された一定数のコインが表示されます。 プレーヤーは、次のセルにすぐに移動するか、現在のセルにとどまることができます。 プレイヤーが特定のセルにいるたびに、その中にあるすべてのコインを収集します。 プレーヤーが<i>t</i>秒以内に収集できるコインの最大数を計算する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各セルについて、プレイヤーがそのセルにいた最後の瞬間のみを知ることが重要であることに注意してください。 プレイヤーの最後からの道を考えてください。 セルの特定の連続したセグメントについての各瞬間に、彼らの訪問の最後の瞬間はすでに知られていますが、他のセルについてはそうではありません。 したがって、動的プログラミング方法を使用できます。この方法の状態は、訪問したセルのセグメントと現在の時刻になります。 さらに、プレーヤーの現在の位置を保存する必要があります。 プレーヤーが訪問済みセルのセグメントの一端に立っている場合にのみ、これらの位置を保存できることに注意してください。 各状態からの遷移は2つまでです。プレーヤーは、既に訪れたセルの左または右のセルに訪れることができます。 したがって、アルゴリズムの実行時間はO（ <i>n <sup>2</sup> t</i> ）です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> 問題C. <a href="http://www.russiancodecup.ru/championship/round/40/problem/C/">トポロジカルソートと子</a> </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>アイデア：</b> Artem Vasiliev 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>実現：</b> Vitaliy Aksyonov 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>分析：</b>ヴィタリー・アクショノフ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     問題では、いくつかの要素が削除されたグラフとそのトポロジカルソートが与えられます。 トポロジカルソートを正しく復元する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最初にアルゴリズムを検討し、次にその正当性を証明します。 順序が与えられる頂点はラベル付き、残りはラベルなしと呼ばれます。 トポロジカルソートで使用されなかった数字はわかっていますが、最大の頂点から最小の頂点まで1つずつ公開します。 別の歪みのない数値があります。 まず、すでにマークされているすべての排水管を削除します。 次に、ラベルなしの各流出について、逆エッジから到達可能なラベル付き頂点の最大値を見つけます。 各頂点について、この数は事前に計算できます。グラフのトポロジカルな並べ替えを見つけて、動的プログラミングの問題を解決します。 歪みのない数値の対応する頂点として、計算された最大の数値を持つシンクを選択し、グラフから削除します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     数値の事前計算はO（ <i>V + E</i> ）で実行されます。 各反復は可能な限り迅速に実行する必要があります。したがって、各頂点には、そこから残っている出力エッジの数を格納します。 シンク、そこにエッジがあるすべての頂点を削除すると、出力次数は減少し、この次数がゼロになったら、この頂点をセットの計算値に配置します。 したがって、すべてのストックはセットに保存され、必要なものを選択するには、セットから最後の頂点を取得するだけです。 各頂点はセットに入れられ、一度だけ引き出されます。 アルゴリズムの合計実行時間：O（ <i>V</i>・log（ <i>V</i> ）+ <i>E</i> ）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここで、アルゴリズムの正確性を証明します。 アルゴリズムの最初のステップが正しいことを証明するだけで十分であることに注意してください。その後、数学的帰納法を使用します。 マークされたすべてのシンクを以前に破棄した、正しく設定されたトポロジカルソート<i>pを</i>考えます。 次に、最大数のアルゴリズムで選択したシンク<i>s</i>と、トポロジーソート<i>p</i>でそれに対応するシンクを検討します。 順列の大きな<i>p（s）の</i>すべての数を1つ減らし、選択した最大数<i>s</i>を与えると、順列は正しいままです。 操作は正しく行われました：ラベル付けされていない頂点のトポロジカルソートプロパティを保持し、ラベル付けされた頂点については、頂点選択プロパティ<i>sp（s）が</i>ラベル付けされた頂点のトポロジカルソート値よりも大きいため、トポロジカルソートの値は変更されませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> タスクD. <a href="http://www.russiancodecup.ru/championship/round/40/problem/D/">右の庭</a> </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>アイデア：</b> Artem Vasiliev 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>実装：</b> Artem Vasiliev 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>分析：</b>アルチョム・ヴァシリエフ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題では、平面上の点のセットが与えられ、 <b>適切な</b>点のセットの概念が導入されます。  <b>優れた</b>点のセットは、座標軸に平行で、与えられた点で角度が反対の非縮退長方形に、このセットからの少なくとも1つの他の点が境界内または境界に含まれる点のセットです。 特定のポイントセットにこのプロパティがあるかどうかを確認する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、同等のプロパティを証明します。ポイントのセットは、このような長方形の各コーナーにこの角度に隣接する辺にポイントがある場合にのみ適切です。 明らかに、このプロパティが満たされると、タスクの条件に記述されたプロパティも満たされます。 ただし、反対方向の結果も同様です<i>。</i>点<i>A</i>と<i>Bに</i>角度を持つ任意の長方形を考えます<i>。</i> 仮定により、この長方形の内側または境界にセット内に別のポイントがあります<i>。</i>これを<i>C</i>と呼びましょう<i>。</i> この点が既に<i>A</i>に隣接する側にある場合、ステートメントはtrueです。 それ以外の場合は、ポイント<i>A</i>とCで構築された長方形を考えてください。その面積は元の長方形の面積よりも厳密に小さく、セットには有限数のポイントがあります。いつか<i>A</i>に隣接する側にあるポイントを選択します<i>。</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     定式化されたプロパティは解に到達するのに役立ちます。点（ <i>x <sub>i</sub> 、y <sub>i</sub></i> ）について、与えられた集合に点（ <i>x、y <sub>i</sub></i> ）が存在するように、 <i>左<sub>i</sub></i>に最大<i>x &lt;x <sub>iを</sub></i>示します。 この値が定義されていない場合、マイナスの無限大に等しいと見なします。 同様に、値<i><sub>i</sub></i> 、 <i>down <sub>i</sub></i> 、 <i>up <sub>i</sub></i>を導入します。 領域（ <i>左<sub>i</sub></i> 、 <i>右<sub>i</sub></i> ）×（ <i>下<sub>i</sub> 、上<sub>i</sub></i> ）を考えます。 この領域に指定されたセットから別のポイントがある場合、構築された長方形がプロパティに違反する2つのポイントを見つけることができます。 この領域のすべてのポイントが適切であるわけではないことに注意してください。  2番目のポイントは常に適切です。たとえば、ユークリッド距離またはマンハッタン距離に最も近い点です。 この領域にポイント（ <i>x <sub>i</sub> 、y <sub>i</sub></i> ）のみがある場合、すべての長方形には、それに隣接する側に別のポイントが含まれます。 したがって、解決策は、内部に複数のポイントが存在するかどうかを<i>n個の</i>長方形でチェックすることに要約されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     平面上の長方形内のポイント数をカウントできるデータ構造を使用して、このようなチェックを実装できます：セグメントの2次元ツリー（オンラインソリューション）またはスキャン直線とセグメントの1次元ツリーを使用したオフラインソリューション。 このようなソリューションは、O（ <i>n</i> log（ <i>n</i> ））で実装できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> タスクE. <a href="http://www.russiancodecup.ru/championship/round/40/problem/E/">Interfluve</a> </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>アイデア：</b> Vitaly Aksyonov 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>実装：</b>イリヤ・ズバン 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>分析：</b>イリヤ・ズバン 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題には、 <i>n個の</i>単調な破線と凸多角形が含まれています。 各ポリラインに、適用されたポリゴンのいずれか（境界上またはポリゴン内）との共通点が少なくとも1つあるように、ポリゴンをアタッチする必要のある最小回数を調べる必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     多角形は凸であり、破線は単調で交差しないので、次の事実が真であることに注意してください：多角形が破線<i>i、kと</i>交差する場合、i≤j≤kのような<i>jについて</i> 、この多角形は<i>j番目の</i>破線とも交差します。 この事実を使用して、問題を熱心に解決します：1番目から<i>i <sub>1</sub></i>番目までのすべての破線と交差するポリゴンが存在する最大<i>i <sub>1を</sub></i>見つけ、それを答えに追加し、続けます：ポリゴンが存在する最大<i>i <sub>2を</sub></i>見つけます<i>i <sub>1</sub></i> + 1からi <sub>2</sub>までの破線をカバーします。 使用する必要があったポリゴンの数が答えになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     破線<i>i <sub>k</sub></i>について学習し、値<i>i <sub>k + 1</sub></i> <i><sub>を</sub></i>見つけます。 これは、 <i>i <sub>k</sub></i> + 1番目と<i>i <sub>k +</sub></i> 1番目のポリラインをカバーするポリゴンが存在する最大インデックスです。 まず、より単純な問題を解決します。ポイントAとセグメントBCがあります。このポイントとセグメントのいくつかのポイントの両方を含むポリゴンが存在するかどうかを確認する必要があります。 これを行うには、このポリゴンとそれ自体のミンコフスキー和を、（0、0）に関して反転します（つまり、符号が反対のすべての点の座標を使用）。 これはいくつかの新しいポリゴンです。O（ <i>n</i> ）頂点を持ち、その中にポイント（0、0）を含むPと呼びましょう。 ポイント（0、0）がポイントAに移動するようにシフトし、セグメントBCがシフトされたポリゴンPと交差することを確認します。これが必要十分条件であることを確認するのは簡単です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ポイントとセグメントを交差するポリゴンが存在するかどうかを確認するために、2つのポリゴンで同じことを確認することは難しくありません：1本の折れ線上のセグメントを反復し、ポリゴンPでミンコフスキー和を作成し、新しい凸ポリゴンが2番目の折れ線の一部と交差するかどうかを確認します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>k</i>をすべての破線上の頂点の総数とします。 使用する操作の漸近的挙動を見つけます-O（ <i>n</i> ）でポリゴンPを構築し、O（ <i>n</i> ）でミンコフスキー和Pおよび折れ線のセグメントを構築し、O（log <i>n</i> ）で凸ポリゴンとセグメントの交差を確認します。 ポリゴンは最大<i>k</i>で構築する必要があり、最悪の場合、各ポリゴンは各セグメントと交差する必要があるため、実行時の結果の漸近的な動作はO（ <i>nk + k <sup>2</sup></i> log <i>n</i> ）です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> 問題F. <a href="http://www.russiancodecup.ru/championship/round/40/problem/F/">木の上のロボット</a> </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>アイデア：</b> Boris Minaev 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>実装：</b> Boris Minaev 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>分析：</b>ボリス・ミナエフ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題では、n≤10頂点の無向木が与えられます。 各rib骨は、その強度<i>wi</i>が15を超えないことが知られています。ロボットは、最初はランダムな頂点にある木の周りを動きます。 毎回、ロボットは同様に、通過できるエッジからエッジを選択し、それに沿って移動します。 ロボットがエッジに沿って通過するたびに、その強度は1つ減少します。 強度がゼロになると、rib骨は除去されます。 ロボットに追従できるrib骨がない場合、停止します。 ロボットの経路長の数学的期待値を計算する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、より簡単な問題を解決します。 経路の長さの数学的期待値ではなく、ロボットが進むことができる異なる経路の数を計算する必要があると仮定します。 ロボットがそのパスを開始および終了するピークと、ロボットが各エッジを通過した回数を記録したとします。 これらの数量の制限を考慮してください。 まず、ロボットが正の回数通過したエッジは、ソースツリーの接続されたサブグラフを形成する必要があります。 次に、特定の頂点と、ロボットがこの頂点に隣接するすべてのエッジを通過した回数を考慮します。 この頂点がパスの終点である場合、それに隣接する各エッジは正確に<i>wi</i>回使用する必要があります。 頂点に隣接する最大2つのエッジを奇数回使用する必要があります。 さらに、この頂点が開始から終了までのパス上にある場合、正確に2つのエッジを奇数回使用する必要があります。 開始頂点と終了頂点（一致しない場合）には、奇数回使用されるエッジが1つだけ存在する必要があります。頂点が一致する場合はゼロになります。 他のすべての頂点の場合、隣接するすべてのエッジを偶数回使用する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらすべての条件が満たされた場合、問題の条件を満たすパスの数をカウントし、エッジを固定回数使用する方法を学習します。 各頂点について、それに隣接するすべてのエッジを考慮します。 ロボットがそれぞれを通過した回数を知っています。 ロボットが指定された頂点からの方向にエッジに沿った回数を簡単に計算できます。 ロボットはどの順序でこれらのwhat骨に沿って歩くことができますか？ まず、ロボットが旅を終えた最上部への道にある端に沿って、ロボットは最後に行く必要があります。 他のすべてのrib骨では、彼は任意の順序で行くことができます。 このようなメソッドの数を数えることは標準的なタスクです。 ロボットが移動できるパスの総数を計算するには、各頂点の計算値を乗算する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     動的計画法を使用して、パスの総数を計算できることに注意してください。 特定のエッジを指定された回数だけ通過し、何らかの方法でこのツリーによって制限されるサブツリーを通過するパスの数を計算してみましょう。 さらに、パスがエッジを上るたびに、彼はすぐにそれに沿って戻ると考えられています。 動的計画法の値を計算するには、サブツリーに入る各エッジに沿ってロボットが歩いた回数を修正し、サブツリーで既に計算された値を乗算するだけでなく、サブツリーに遷移を配置する方法の数を修正する必要があります。 頂点のサブツリーを順番に検討し、ロボットが合計で検討されたすべてのサブツリーに行く回数を修正します。 次のサブツリーを考慮して、ロボットがこのサブツリーに入る回数をソートします。 サブツリーからの動的プログラミングの価値に対する答えと、他のトランジションの中でサブツリーへのトランジションを配置する方法の数を掛けます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     元のタスクに戻りましょう。 ここで、メソッドの数の代わりに、そのようなパスを選択する確率とその長さの期待値を保存します。 確率の計算は、メソッドの数の計算とは異なり、エッジに沿った各遷移で、この頂点に入射するエッジの数で値を除算する必要があります。 この場合に発生する唯一の問題は、ロボットの移動中にエッジが削除されるため、頂点の次数が一定でないことです。 エッジの動的プログラミング値を計算するには、次のアイデアを使用します。 エッジが削除されるすべてのサブツリーと、ロボットがエッジに沿って上から移動する合計回数を修正します。 最後からパスを復元します。 区別する必要がある可能性のある2つのオプションがあります。 または、ロボットが削除されないエッジに沿って移動する場合、ロボットがさらに小さなタスクに移動する必要があるエッジの数を減らす必要があります。 または、ロボットは削除されるエッジに沿って移動し、ロボットが移動する必要があるエッジの合計数まで、このエッジに沿って移動する回数を追加し、既存の入射エッジの数を1つ増やす必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     合計で、特定のエッジの動的計画法にはO（2つの子<i>wi wi</i> ）状態があり、それらの間の遷移はO（1）で実行されます。 エッジが使用された回数ごとに動的プログラミングの値を計算する必要があるため、アルゴリズムの合計実行時間はO（2 <sup>n</sup> （∑ <i>wi</i> ） <sup>2</sup> ）になります。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J267325/index.html">3D学校の新しいセット、カラシニコフ突撃ライフル、北極の温室、および過去のコースの卒業生の他のエンジニアリングプロジェクトについて</a></li>
<li><a href="../J267337/index.html">iOS 9の新機能、Androidマシュマロに期待すること、ゲームデザイナーが避けるべきこと-モバイル開発者にとっての今週のその他のニュース</a></li>
<li><a href="../J267339/index.html">Iproute2ポリシールーティングとアップリンク間のトラフィックバランシング-接続ドロップの問題</a></li>
<li><a href="../J267343/index.html">DHCPサーバーのスケジューリング</a></li>
<li><a href="../J267345/index.html">STLアルゴリズムを選択するためのフローチャート</a></li>
<li><a href="../J267349/index.html">WebアプリケーションでのJSON Webトークンとスライド式の有効期限</a></li>
<li><a href="../J26735/index.html">カルマ</a></li>
<li><a href="../J267351/index.html">icecast + icesを使用したローカルインターネットラジオ局</a></li>
<li><a href="../J267355/index.html">ミクロティック。 動的IPクライアントを使用したVPN ipsecトンネルの構築</a></li>
<li><a href="../J267357/index.html">ZerodiumがiOS 9に100万ドルのエクスプロイトを提供</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>