<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏾 ✊ 🧙🏽 ネストセットツリー管理モジュール 🍹 🍌 🙆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="挑戦する  
  
 ええ、あなたはボートに乗って水に乗って人生を楽しみます。 私は休息するために次の湖に行きました、そして彼らは犬やボートは許可されていないと言っているとあなたに話します、そして一般的に私たちの湖はいつも凍っています、ここであなたはスケートを持っています-お楽しみください。 「仮想...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>ネストセットツリー管理モジュール</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/65495/"><h4> 挑戦する </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ええ、あなたはボートに乗って水に乗って人生を楽しみます。 私は休息するために次の湖に行きました、そして彼らは犬やボートは許可されていないと言っているとあなたに話します、そして一般的に私たちの湖はいつも凍っています、ここであなたはスケートを持っています-お楽しみください。  <i>「仮想ホスティング湖へようこそ。」</i> <a name="habracut"></a> どういうわけか、 <i>スーパー</i>ユーザーのみが<i>MySQL</i>でトリガーを作成できるという事実に注意を払っていませんでしたが、これはやや驚くべきことですが、開発者の良心に任せましょう。 基本的にPerlのソリューションはありますが、作成した時点では完全に異なるタスクと要件がありました。 したがって、この記事は以前の開発をキャンセルするのではなく、追加のソリューションを提供するだけです。 データベースを操作するための特定のオブジェクトセットと特定の「ラッパー」があります。 この「ラッパー」には、このモジュールを機能の拡張として含めます。 ラッパーは自己記述型です。  <i>DBIx :: Class</i>やその他の既成のソリューションの反対者ではないので、事前に予約します。仕事でそれらを使用して満足しています。 質問は<i>仮想ホスティングと</i>それに似た他のものにかかっています：mod_perlの欠如と追加モジュールのインストールのhemo。 同じ<i>DBIx :: Class</i>のソリューションは開発中ですが、必要がないのであまり高速ではないので、十分なトリガーがあるため、 <i>挿入</i> 、 <i>更新</i> 、 <i>削除の</i> 3つの手順だけが必要です。 これはプロシージャであり、「ラッパー」のオブジェクトのメソッドとして継承されます。 ただし、この記事では、ほぼ自給自足にします。 このモジュールにはトランザクションを含めませんでした。1レベル上で使用しているため、自分でコードに含めることは難しくないと思います。 、機能の少しのテストが実行されましたが。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 基本的な手順と変数 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     もちろん、データベースに接続するための手順ですが、外部から定義されているパッケージ$ dbhのオブジェクトがあります。 また、普遍性を確保するために、ツリーの構造を担当する独自のフィールドセットを各テーブルに定義する配列を作成します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perlコード（1） <pre>パッケージMY :: NestedSets;
 ＃妥協のない大人としてのすべて;-)
厳格な使用;
警告を使用します。
 $ VERSION = '0.0.1';
 ＃パッケージ内で使用する変数を定義します
 $ dbh = undef;
 $テーブル= {
                デフォルト=&gt; {＃テーブル名
                    フィールド=&gt; {＃テーブルフィールド
                         id =&gt; 'id'、＃実際にID、だれもがどのように電話するかわかりません
                         left_key =&gt; 'left_key'、＃左キー
                         right_key =&gt; 'right_key'、＃右キー
                         level =&gt; 'level'、＃レベル
                         parent_id =&gt; 'parent_id'、＃親ID
                         tree =&gt; 'tree'＃ツリー識別子
                                 }、
                     multi =&gt; 1、＃テーブルに複数のツリーがあることを示します
                             }、
                };

 sub dbh {
 ＃まだ作成している場合、最初の値はパッケージの名前またはパッケージのクラスになります
 ＃それで、私たちは時々それを断ち切り、クラスを持っていません。
     shift if $ _ [0] &amp;&amp;（$ _ [0] eq __PACKAGE__ ||（ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__））;
     $ dbh = $ _ [0] if $ _ [0];
     return $ dbh;
 }

 sub set_table_params {
     shift if $ _ [0] &amp;&amp;（$ _ [0] eq __PACKAGE__ ||（ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__））;
 ＃特定のテーブルのフィールドを設定する
     my（$ table_name、$ params）= @_;
     $ tables-&gt; {$ table_name} = $ params;
     $テーブルを返します。
 }
    </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     並行して、useスクリプト自体を記述しますが、これもテスト用です。 そのため、モジュールを使用して、そのメインデータを決定します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perlコード（2） <pre> ＃！/ usr / bin / perl
厳格な使用; 警告を使用します。
 lib '../lib'を使用します。
 MY :: NestedSetsを使用します。
 DBIを使用します。
 Data :: Dumperを使用します。

 ＃------------------------------------------------- -------------------------------------------------- -----
 ＃INIT

 my $ dbh = DBI-&gt; connect（ 'dbi：mysql：database = test; host = localhost; port = 3306'、 'user'、 'pass'）;
私の$ table_name = 'test_nested_sets';
 my％f =（
         id =&gt; 'ids'、
         left_key =&gt; 'lk'、
         right_key =&gt; 'rk'、
        レベル=&gt; 'lv'、
         parent_id =&gt; 'pi'、
        ツリー=&gt; 'tr'、
         ）;
 $ dbh-&gt; do（ "DROP TABLE` $ table_name`;"）;
 my $ query = "CREATE TABLE` $ table_name`（
     `$ f {id}` int（11）NOT NULL auto_increment、
     `$ f {left_key}` int（11）NOT NULLデフォルト '0'、
     `$ f {right_key}` int（11）NOT NULLデフォルト '0'、
     `$ f {level}` int（11）NOT NULLデフォルト '0'、
     `$ f {parent_id}` int（11）NOT NULLデフォルト '0'、
     `$ f {tree}` int（11）NOT NULLデフォルト '1'、
     `field1` VARCHAR（100）、
    主キー（ `$ f {id}`）
 ）エンジン= MyISAM; ";
 $ dbh-&gt; do（$ query）;

 MY :: NestedSets-&gt; dbh（$ dbh）;
 MY :: NestedSets-&gt; set_table_params（$ table_name =&gt; {fields =&gt; \％f、multi =&gt; 1}）;
 ...
    </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> ノードを挿入 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     作業のロジックは、トリガーのロジックと同じです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perlコード（3） <pre>サブ挿入{
 ＃着信データを適切に場所に配布し、それに応じて十分なデータがあるかどうかを確認します
     shift if $ _ [0] &amp;&amp;（$ _ [0] eq __PACKAGE__ ||（ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__））;
     my（$ table_name、$ new）= @_;
     return {success =&gt; 0、error =&gt; 'Bad Income data！'} $ dbh &amp;&amp; $ table_name &amp;&amp; $ new &amp;&amp; ref $ new &amp;&amp; ref $ new eq 'HASH';
 ＃どんな種類のテーブルを見つけて、追加の属性とフィールドシノニムを取得します
    私の$ table = $ tables-&gt; {$ table_name} ||  $ tables-&gt; {default};
    私の$ f = $ table-&gt; {fields};
    私の$ result_flags = {is_last_unit =&gt; undef};
 ＃ツリーキーの初期データを決定する
     $ new-&gt; {$ f-&gt; {left_key}} || = 0;
     $ new-&gt; {$ f-&gt; {right_key}} = undef;
     $ new-&gt; {$ f-&gt; {level}} = undef;
     $ new-&gt; {$ f-&gt; {parent_id}} || = 0;
 ＃親ノードを指定または変更した場合、キーを決定します
     if（$ new-&gt; {$ f-&gt; {parent_id}}）{
        私の$ sql = 'SELECT'。
                         （$テーブル-&gt; {multi}？$ f-&gt; {tree}。「ASツリー」： ''）。
                         $ f-&gt; {right_key}。 '  AS left_key、 '。
                         $ f-&gt; {レベル}。 '  + 1 ASレベル '。
                  「FROM」$ Table_name。
                  'WHERE'。$ F-&gt; {id}。 '  = '。$ new-&gt; {$ f-&gt; {parent_id}};
 ＃明確にするために、これはクエリです（角括弧はオプションの式です）：
 ＃SELECT [tree AS tree、] right_key AS left_key、level + 1 AS level FROM $ table_name WHERE id = $ parent_id;
        私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
        私の$ row = $ sth-&gt; fetchrow_hashref（）;
         $ sth-&gt; finish;
 ＃親ノードが見つかったため、キー値を再定義します
         if（$ row）{
             $ new-&gt; {$ f-&gt; {tree}} = $ row-&gt; {tree} || 未定義
             $ new-&gt; {$ f-&gt; {left_key}} = $ row-&gt; {left_key};
             $ new-&gt; {$ f-&gt; {level}} = $ row-&gt; {level};
         } else {
 ＃親ノードが見つからないため、parent_idが残っているため、リセットします
             $ new-&gt; {$ f-&gt; {parent_id}} = 0;
             $ new-&gt; {$ f-&gt; {level}} = 0;
         }
     }
 ＃左キーが指定されている場合、キーを決定しますが、同時に、親ノードが指定されていないか、見つかりません
     if（！$ new-&gt; {$ f-&gt; {parent_id}} &amp;&amp; $ new-&gt; {$ f-&gt; {left_key}}）{
 ＃これは重要です！ マルチツリーの場合、$ treeパラメーターが必要です
         $ new-&gt; {$ f-&gt; {tree}} &amp;&amp; $ table-&gt; {multi};でない限り、{success =&gt; 0、error =&gt; 'No tree value！'}
 ＃最初はSQLを使用したかった::抽象的だが、気に入らなかった。複雑なクエリを記述するのは難しくて長い
 ＃左右のキーでノードを見つける
        私の$ sql = 'SELECT'。
                         $ f-&gt; {id}。 '  AS id、 '。
                         $ f-&gt; {left_key}。 '  AS left_key、 '。
                         $ f-&gt; {right_key}。 '  AS right_key、 '。
                         $ f-&gt; {レベル}。 '  ASレベル、 '。
                         $ f-&gt; {parent_id}。 '  AS parent_id '。
                  「FROM」$ Table_name。
                  「どこ」。
                  （$テーブル-&gt; {multi}？$ f-&gt; {tree}。 '='。$ new-&gt; {$ f-&gt; {tree}}。 'AND'： ''）。
                  '（'。$ f-&gt; {left_key}。 '='。$ new-&gt; {$ f-&gt; {left_key}}。 'OR'。
                  $ f-&gt; {right_key}。 '  = '。$ new-&gt; {$ f-&gt; {left_key}}。'）LIMIT 1 ';
 ＃読み取り可能なリクエスト：
 ＃選択
 ＃id AS id、
 ＃left_key AS left_key、
 ＃right_key AS right_key、
 ＃レベルASレベル、
 ＃parent_id AS parent_id
 ＃FROM $ table_name
 ＃どこ
 ＃[tree = $ tree AND]
 ＃（left_key = $ left_keyまたはright_key = $ left_key）
 ＃LIMIT 1;
        私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
        私の$ row = $ sth-&gt; fetchrow_hashref（）;
         $ sth-&gt; finish;
 ＃左キーでノードが見つかったため、見つかった新しいノード
         if（$ row &amp;&amp; $ row-&gt; {left_key} == $ new-&gt; {$ f-&gt; {left_key}}）{
             $ new-&gt; {$ f-&gt; {parent_id}} = $ row-&gt; {parent_id};
             $ new-&gt; {$ f-&gt; {level}} = $ row-&gt; {level};
 ＃ノードは正しいキーで検出されたため、新しいノードは検出されたノードの下にあります
         } elsif（$行）{
             $ new-&gt; {$ f-&gt; {parent_id}} = $ row-&gt; {id};
             $ new-&gt; {$ f-&gt; {level}} = $ row-&gt; {level} + 1;
         } else {
 ＃繰り返しますが、そのようながらくたは、完全に残ったデータを示しています。 誓うのは良いことですが、今のところ、これらの群れを無視してください。
 ＃このデータがなくても処理できるため
             $ new-&gt; {$ f-&gt; {left_key}} = undef;
         }
     }
 ＃実際に、挿入ポイントを取得できなかったか、単に示されていませんでした。
 ＃ツリーの最後に挿入するため、既存のノードを更新する必要はありません。したがって、対応するフラグを作成します。
     （$ new-&gt; {$ f-&gt; {left_key}}）{
         $ result_flags-&gt; {is_last_unit} = 1;
 ＃これもまた重要です！ 複数ツリーの場合は、$ treeパラメーターが必要です。
 ＃一般に、最初にこれを確認できますが、parent_idを指定した場合、このパラメーターは不要です。
 ＃次に、ツリーキーの値が決定されます。
         $ new-&gt; {$ f-&gt; {tree}} &amp;&amp; $ table-&gt; {multi};でない限り、{success =&gt; 0、error =&gt; 'No tree value！'}
 ＃それは簡単です、最大の正しいキーを決定して喜ぶ
        私の$ sql = 'SELECT MAX（'。$ f-&gt; {right_key}。 '）+ 1 AS left_key
             FROM '。$ Table_name。
             （$ table-&gt; {multi}？ 'WHERE'。$ f-&gt; {tree}。 '='。$ new-&gt; {$ f-&gt; {tree}}： ''）;
 ＃読み取り可能なリクエスト：
 ＃SELECT MAX（right_key）+ 1 AS left_key、
 ＃FROM $ table_name
 ＃[WHERE tree = $ tree];
        私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
        私の$ row = $ sth-&gt; fetchrow_hashref（）;
         $ sth-&gt; finish;
 ＃しかし、ノードがまったくない可能性があるため、喜びは完全ではない可能性があります
         $ new-&gt; {$ f-&gt; {left_key}} = $ row-&gt; {left_key} ||  1;
         $ new-&gt; {$ f-&gt; {parent_id}} = 0;
         $ new-&gt; {$ f-&gt; {level}} = 0;
     }
 ＃さて、場所で、ツリーのキーを壊すことができると決めました：
     （$ result_flags-&gt; {is_last_unit}）{
         my $ query = 'UPDATE'。$ table_name。
                        'SET'。$ F-&gt; {left_key}。 '  =ケース
                                     '。$ F-&gt; {left_key}の場合。  &gt; = '。$ new-&gt; {$ f-&gt; {left_key}}。
                                    それから '。$ F-&gt; {left_key}'。  + 2 ELSE '。$ F-&gt; {left_key}'。  END、
                             '。$ f-&gt; {right_key}'。  = '。$ f-&gt; {right_key}。'  + 2
                      WHERE '。
                      （$テーブル-&gt; {multi}？$ f-&gt; {tree}。 '='。$ new-&gt; {$ f-&gt; {tree}}。 'AND'： ''）。
                       $ f-&gt; {right_key}。 '  &gt; = '。$ new-&gt; {$ f-&gt; {left_key}};
 ＃読み取り可能なリクエスト：
 ＃UPDATE $ table_name
 ＃セット
 ＃left_key = left_key&gt; = $ left_keyの場合 
 ＃THEN left_key + 2 
 ＃ELSE left_key
 ＃END、
 ＃right_key = right_key + 2
 ＃WHERE [tree = $ tree AND] right_key&gt; = $ left_key;
         $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
     }
 ＃実際、なぜここに来たのか：
 ＃正しいキーが計算されます
     $ new-&gt; {$ f-&gt; {right_key}} = $ new-&gt; {$ f-&gt; {left_key}} + 1;
 ＃キーを置きます
     $ new-&gt; {$ f-&gt; {tree}} = $ new-&gt; {$ f-&gt; {tree}} if if table-&gt; {multi};
 ＃フィールドを特定の順序で表示する必要がある
    私の@fields = keys％{$ new};
 ＃ここで、非数値の空の行を引用して@fieldsの順に詰めるには
 ＃そしてはい、少なくとも二重引用符については、ここに来る前にチェックする必要があります
    私の@values = map {defined $ new-&gt; {$ _} &amp;&amp; $ new-&gt; {$ _} =〜/ ^ \ d + $ /？  $ new-&gt; {$ _}： '"'。$ new-&gt; {$ _}。 '"'} @fields;
 ＃実際に挿入
     my $ query = 'INSERT INTO'。$ table_name。 '  （ '。（join'、 '、@fields）'）VALUES（ '。（join'、 '、@values）。'） ';
     $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
 ＃しかし、返すべきものは別の質問です。残念ながら、フェッチせずに挿入された行を返すことはできません。
 ＃テーブルにはデフォルトのフィールド値がありますが、INSERTでそれらを指定しなかったため。
 ＃同じSELECTをしましょう
    私の$ sql = 'SELECT * FROM'。$ table_name。 '  ORDER BY '。$ F-&gt; {id}。'  DESC LIMIT 1 ';
    私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
    私の$ row = $ sth-&gt; fetchrow_hashref;
     $ sth-&gt; finish;
     return {success =&gt; 1、row =&gt; $ row};
 }
    </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     はい、たくさんのコードが判明しました...しかし、コメントを削除すると、行数が半分になります;-)が、はっきりしていると思います。 基本的に：繰り返しますが、親の設定が優先されます。 親が指定され、左のキーが指定されている場合、有効なツリーでは後者が無視されます。 したがって、何かに従属するノードを作成すると同時に、子のリスト内でその場所を指定する場合は、parent_idを渡す必要がないことに注意してください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perlコード（4） <pre> ...私の$ツリー= 1;  ＃------------------------------------------------- -------------------------------------------------- --------------------＃INSERT＃座標なしで記録my $ insert = MY :: NestedSets-&gt; insert（$ table_name、{field1 =&gt; 'row1-'。 $ tree、tr =&gt; $ tree}）;  Dumper $ insertに警告します。  ＃親のあるレコード$ insert = MY :: NestedSets-&gt; insert（$ table_name、{field1 =&gt; 'row2-'。$ Tree、pi =&gt; $ insert-&gt; {row}-&gt; {ids}、tr =&gt; $ツリー}）;  Dumper $ insertに警告します。  ＃left_keyのエントリ$ insert = MY :: NestedSets-&gt; insert（$ table_name、{field1 =&gt; 'row3-'。$ Tree、lk =&gt; 1、tr =&gt; $ tree}）;  Dumper $ insertに警告します。  $ insert = MY :: NestedSets-&gt; insert（$ table_name、{field1 =&gt; 'row4-'。$ tree、lk =&gt; 4、tr =&gt; $ tree}）;  Dumper $ insertに警告します。  ＃間違ったパラメーター$ insert = MY :: NestedSets-&gt; insert（$ table_name、{field1 =&gt; 'row5-'。$ Tree、pi =&gt; 1000、tr =&gt; $ tree}）;  Dumper $ insertに警告します。  $ insert = MY :: NestedSets-&gt; insert（$ table_name、{field1 =&gt; 'row6-'。$ tree、lk =&gt; 100、tr =&gt; $ tree}）;  Dumper $ insertに警告します。  ... </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> ノード変更 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ツリー構造を（必要に応じて）直接変更することに加えて、変更は必要に応じて他のフィールドにも適用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perlコード（5） <pre>サブアップデート{
 ＃受信データを場所に配布し、それに応じて、十分なデータがあるかどうかを確認します
    シフトif $ _ [0] &amp;&amp;（$ _ [0] eq __PACKAGE__ ||（ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__））;
     my（$ table_name、$ new）= @_;
     return {success =&gt; 0、error =&gt; 'Bad Income data！'} $ dbh &amp;&amp; $ table_name &amp;&amp; $ new &amp;&amp; ref $ new &amp;&amp; ref $ new eq 'HASH';
 ＃どんな種類のテーブルを見つけて、追加の属性とフィールドシノニムを取得します
    私の$ table = $ tables-&gt; {$ table_name} ||  $ tables-&gt; {default};
    私の$ f = $ table-&gt; {fields};
    リターン{成功=&gt; 0、エラー=&gt; '悪い収入データ！'} $ new-&gt; {$ f-&gt; {id}};
 ＃個別に変更できないフィールドは削除します
    削除$ new-&gt; {$ f-&gt; {right_key}};
    削除$ new-&gt; {$ f-&gt; {tree}};
    削除$ new-&gt; {$ f-&gt; {level}};
    私の$ tmp_left_key = $ new-&gt; {$ f-&gt; {left_key}};
    私の$ result_flags = {it_is_moving =&gt; undef};
 ＃さらにジレンマ。 変更を受け入れるには、ソースデータが必要です
 ＃この場合、どの初期データがあり、どのフィールドが実際に変更されたかはわかりませんが、
 ＃可変ノードをサンプリングする
    私の$ sql = 'SELECT * FROM'。$ table_name。 '  WHERE '。$ F-&gt; {id}。'  = '。$ new-&gt; {$ f-&gt; {id}};
    私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
     $ old = $ sth-&gt; fetchrow_hashref;
     $ sth-&gt; finish;
     return {success =&gt; 0、error =&gt; 'No old unit！'}が$ oldでない限り;
 ＃新しいノード座標を計算する
 ＃親ノードを変更した場合、キーを決定します
     if（定義済み$ new-&gt; {$ f-&gt; {parent_id}} &amp;&amp; $ new-&gt; {$ f-&gt; {parent_id}}！= $ old-&gt; {$ f-&gt; {parent_id}}）{
         if（$ new-&gt; {$ f-&gt; {parent_id}}&gt; 0）{
            私の$ sql = 'SELECT'。
                             （$テーブル-&gt; {multi}？$ f-&gt; {tree}。「ASツリー」： ''）。
                             $ f-&gt; {right_key}。 '  AS left_key、 '。
                             $ f-&gt; {レベル}。 '  + 1 ASレベル '。
                      「FROM」$ Table_name。
                      'WHERE'。$ F-&gt; {id}。 '  = '。$ new-&gt; {$ f-&gt; {parent_id}};
 ＃明確にするために、これはクエリです（角括弧はオプションの式です）：
 ＃SELECT [tree AS tree、] right_key AS left_key、level + 1 AS level FROM $ table_name WHERE id = $ parent_id;
            私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
            私の$ row = $ sth-&gt; fetchrow_hashref（）;
             $ sth-&gt; finish;
 ＃親ノードが見つかった後、キー値を再定義します
             if（$ row）{
                 $ new-&gt; {$ f-&gt; {tree}} = $ row-&gt; {tree} if if table-&gt; {multi};
                 $ new-&gt; {$ f-&gt; {left_key}} = $ row-&gt; {left_key};
                 $ new-&gt; {$ f-&gt; {level}} = $ row-&gt; {level};
                 $ result_flags-&gt; {it_is_moving} = 1;
             } else {
 ＃親ノードが見つからないため、parent_idが残っているため、リセットします
                 $ new-&gt; {$ f-&gt; {parent_id}} = $ old-&gt; {$ f-&gt; {parent_id}};
             }
         } else {
 ＃最高レベルに移行
 ＃それは簡単です、最大の正しいキーを決定して喜ぶ
            私の$ sql = 'SELECT MAX（'。$ f-&gt; {right_key}。 '）+ 1 AS left_key
                 FROM '。$ Table_name。
                 （$ table-&gt; {multi}？ 'WHERE'。$ f-&gt; {tree}。 '='。$ old-&gt; {$ f-&gt; {tree}}： ''）;
 ＃読み取り可能なリクエスト：
 ＃SELECT MAX（right_key）+ 1 AS left_key、
 ＃FROM $ table_name
 ＃[WHERE tree = $ tree];
            私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
            私の$ row = $ sth-&gt; fetchrow_hashref（）;
             $ sth-&gt; finish;
             $ new-&gt; {$ f-&gt; {left_key}} = $ row-&gt; {left_key};
             $ new-&gt; {$ f-&gt; {parent_id}} = 0;
             $ new-&gt; {$ f-&gt; {level}} = 0;
         }
     }
 ＃左キーが設定されているが、親ノードが指定されていないか見つからない場合、キーを決定します
     if（$ tmp_left_key &amp;&amp; $ new-&gt; {$ f-&gt; {left_key}} &amp;&amp;＃left_keyが指定された
          $ new-&gt; {$ f-&gt; {left_key}} == $ tmp_left_key &amp;&amp;＃parent_idは変更されていません
          $ tmp_left_key！= $ old-&gt; {$ f-&gt; {left_key}}）{＃left_key changed
 ＃最初はSQLを使用したかった::抽象的だが、気に入らなかった。複雑なクエリを記述するのは難しくて長い
 ＃左右のキーでノードを見つける
        私の$ sql = 'SELECT'。
                         $ f-&gt; {id}。 '  AS id、 '。
                         $ f-&gt; {left_key}。 '  AS left_key、 '。
                         $ f-&gt; {right_key}。 '  AS right_key、 '。
                         $ f-&gt; {レベル}。 '  ASレベル、 '。
                         $ f-&gt; {parent_id}。 '  AS parent_id '。
                  「FROM」$ Table_name。
                  「どこ」。
                  （$ table-&gt; {multi}？$ f-&gt; {tree}。 '='。$ old-&gt; {$ f-&gt; {tree}}。 'AND'： ''）。
                  '（'。$ f-&gt; {left_key}。 '='。$ new-&gt; {$ f-&gt; {left_key}}。 'OR'。
                  $ f-&gt; {right_key}。 '  = '。$ new-&gt; {$ f-&gt; {left_key}}。'）LIMIT 1 ';
 ＃読み取り可能なリクエスト：
 ＃選択
 ＃id AS id、
 ＃left_key AS left_key、
 ＃right_key AS right_key、
 ＃レベルASレベル、
 ＃parent_id AS parent_id
 ＃FROM $ table_name
 ＃どこ
 ＃[tree = $ tree AND]
 ＃（left_key = $ left_keyまたはright_key = $ left_key）
 ＃LIMIT 1;
        私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
        私の$ row = $ sth-&gt; fetchrow_hashref（）;
         $ sth-&gt; finish;
 ＃左キーでノードが見つかったため、見つかった新しいノード
         if（$ row &amp;&amp; $ row-&gt; {left_key} == $ new-&gt; {$ f-&gt; {left_key}}）{
             $ new-&gt; {$ f-&gt; {parent_id}} = $ row-&gt; {parent_id};
             $ new-&gt; {$ f-&gt; {level}} = $ row-&gt; {level};
 ＃ノードは正しいキーで検出されたため、新しいノードは検出されたノードの下にあります
         } elsif（$行）{
             $ new-&gt; {$ f-&gt; {parent_id}} = $ row-&gt; {id};
             $ new-&gt; {$ f-&gt; {level}} = $ row-&gt; {level} + 1;
         } else {
 ＃繰り返しますが、そのようながらくたは、完全に残ったデータを示しています。 ノードを最初に置くオプションがありますが、
 ＃次に、これは間違いではありません。 しかし、他の場合には、移動を無視してください
             $ new-&gt; {$ f-&gt; {left_key}} = $ new-&gt; {$ f-&gt; {left_key}} &amp;&amp; $ new-&gt; {$ f-&gt; {left_key}} == 1？  1：$ old-&gt; {$ f-&gt; {left_key}};
         }
     }
 ＃これで、左のキーが何であるかがわかったので、内側に送信しているかどうかを確認できます
     if（$ new-&gt; {$ f-&gt; {left_key}}&gt; $ old-&gt; {$ f-&gt; {left_key}} &amp;&amp; $ new-&gt; {$ f-&gt; {left_key}} &lt;$ old-&gt; {$ f-&gt; {right_key}}）{
         return {success =&gt; 0、error =&gt; 'ユニットを内部に移動できません'};
     }
 ＃座標を計算しましたが、唯一のものは、見て、ツリーに変更があったかどうかです
     if（$ new-&gt; {$ f-&gt; {left_key}} &amp;&amp; $ new-&gt; {$ f-&gt; {left_key}}！= $ old-&gt; {$ f-&gt; {left_key}}）{
 ＃レベルとツリーのオフセットを定義する
        私の$ skew_level = $ new-&gt; {$ f-&gt; {level}}-$ old-&gt; {$ f-&gt; {level}};
        私の$ skew_tree = $ old-&gt; {$ f-&gt; {right_key}}-$ old-&gt; {$ f-&gt; {left_key}} + 1;
 ＃ツリーを下に移動する
         if（$ new-&gt; {$ f-&gt; {left_key}}&gt; $ old-&gt; {$ f-&gt; {left_key}}）{
            私の$ skew_edit = $ new-&gt; {$ f-&gt; {left_key}}-$ old-&gt; {$ f-&gt; {left_key}}-$ skew_tree;
             my $ query = 'UPDATE'。$ table_name。
                            'SET'。$ F-&gt; {left_key}。 '  = '。$ F-&gt; {right_key}の場合。  &lt;= '。$ old-&gt; {$ f-&gt; {right_key}}。'
                                     それから '。$ F-&gt; {left_key}'。  + '。$ skew_edit。'
                                      「。$ F-&gt; {left_key}」の場合のその他の場合。  &gt; '。$ old-&gt; {$ f-&gt; {right_key}}。'
                                               それから '。$ F-&gt; {left_key}'。  -'。$ skew_tree。'
                                                ELSE '。$ F-&gt; {left_key}'。
                                          終了
                                END、
                     '。$ f-&gt; {レベル}。'  = '。$ F-&gt; {right_key}の場合。  &lt;= '。$ old-&gt; {$ f-&gt; {right_key}}。'
                                     THEN '。$ F-&gt; {レベル}。  + '。$ skew_level。'
                                     ELSE '。$ F-&gt; {レベル}'。
                                END、
                     '。$ f-&gt; {right_key}'。  = '。$ F-&gt; {right_key}の場合。  &lt;= '。$ old-&gt; {$ f-&gt; {right_key}}。'
                                      THEN '。$ F-&gt; {right_key}'。  + '。$ skew_edit。'
                                      「。$ F-&gt; {right_key}」の場合のその他の場合。  &lt;'。$ new-&gt; {$ f-&gt; {left_key}}'。
                                                THEN '。$ F-&gt; {right_key}'。  -'。$ skew_tree。'
                                                ELSE '。$ F-&gt; {right_key}。
                                          終了
                                終了
                どこ
                     '。（$ table-&gt; {multi}？$ f-&gt; {tree}。' = '。$ old-&gt; {$ f-&gt; {tree}}。' AND '：' '）。
                      $ f-&gt; {right_key}。 '  &gt; '。$ old-&gt; {$ f-&gt; {left_key}}。'  AND '。
                      $ f-&gt; {left_key}。 '  &lt;'。$ new-&gt; {$ f-&gt; {left_key}}。'; ';
             $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
             $ new-&gt; {$ f-&gt; {left_key}} = $ new-&gt; {$ f-&gt; {left_key}}-$ skew_tree;
         } else {
 ＃ツリーを上に移動する
            私の$ skew_edit = $ new-&gt; {$ f-&gt; {left_key}}-$ old-&gt; {$ f-&gt; {left_key}};
             my $ query = 'UPDATE'。$ table_name。 '
                セット
                     '。$ f-&gt; {right_key}'。  =「。$ F-&gt; {left_key}」の場合。  &gt; = '。$ old-&gt; {$ f-&gt; {left_key}}'。
                                      THEN '。$ F-&gt; {right_key}'。  + '。$ skew_edit。'
                                      「。$ F-&gt; {right_key}」の場合のその他の場合。  &lt;'。$ old-&gt; {$ f-&gt; {left_key}}'。
                                                THEN '。$ F-&gt; {right_key}'。  + '。$ skew_tree。'
                                                ELSE '。$ F-&gt; {right_key}。
                                          終了
                                 END、
                     '。$ f-&gt; {レベル}。'  =「。$ F-&gt; {left_key}」の場合。  &gt; = '。$ old-&gt; {$ f-&gt; {left_key}}'。
                                      THEN '。$ F-&gt; {レベル}。  + '。$ skew_level。'
                                      ELSE '。$ F-&gt; {レベル}'。
                                 END、
                     '。$ f-&gt; {left_key}'。  =「。$ F-&gt; {left_key}」の場合。  &gt; = '。$ old-&gt; {$ f-&gt; {left_key}}'。
                                     それから '。$ F-&gt; {left_key}'。  + '。$ skew_edit。'
                                      「。$ F-&gt; {left_key}」の場合のその他の場合。  &gt; = '。$ new-&gt; {$ f-&gt; {left_key}}。
                                               それから '。$ F-&gt; {left_key}'。  + '。$ skew_tree。'
                                                ELSE '。$ F-&gt; {left_key}'。
                                          終了
                                終了
                どこ
                     '。（$ table-&gt; {multi}？$ f-&gt; {tree}。' = '。$ old-&gt; {$ f-&gt; {tree}}。' AND '：' '）。
                     $ f-&gt; {right_key}。 '  &gt; = '。$ new-&gt; {$ f-&gt; {left_key}}。  AND '。
                     $ f-&gt; {left_key}。 '  &lt;'。$ old-&gt; {$ f-&gt; {right_key}}。'; ';
             $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
         }
     }
 ＃まず最初に、実際に変更されたフィールドのみを$ newのままにします。
    私の@sets =（）;
     $キーをforeach（keys％{$ new}）{
         ＃そのようなフィールドはまったくありません
        削除$ new-&gt; {$ key}、次に存在しない限り$ old-&gt; {$ key};
         ＃コンテンツフィールドは変更されていません
         $ new-&gt; {$ key}を削除、$ old-&gt; {$ key} &amp;&amp; $ new-&gt; {$ key} &amp;&amp; $ new-&gt; {$ key} eq $ old-&gt; {$ key};
         ＃コンテンツのないフィールドは変更されていません
        削除$ new-&gt; {$ key}、next if！$ old-&gt; {$ key} &amp;&amp;！$ new-&gt; {$ key};
         ＃IDは変更しませんが、念のため削除します
        削除$ new-&gt; {$ key}、次に$ key eq $ f-&gt; {id};
 ＃同じこと、値チェックなし
         @ sets、$キーを押します。  「=」。  （定義された$ new-&gt; {$ key} &amp;&amp; $ new-&gt; {$ key} =〜/ ^ \ d + $ /？$ new-&gt; {$ key}： '"'。$ new-&gt; {$ key}。 '"'）;
     }
 ＃変更されたフィールドを更新
     my $ query = 'UPDATE'。$ table_name。
                    「SET」（「、」、@ setsに参加）。
                    'WHERE'。$ F-&gt; {id}。 '  = '。$ old-&gt; {$ f-&gt; {id}};
     $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
 ＃繰り返しますが、UPDATE後に行をリクエストします。どのトリガーが更新されたかはわかりません
     $ sql = 'SELECT * FROM'。$ table_name。 '  WHERE '。$ F-&gt; {id}。'  = '。$ old-&gt; {$ f-&gt; {id}}'  LIMIT 1 ';
     $ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
    私の$ row = $ sth-&gt; fetchrow_hashref;
     $ sth-&gt; finish;
     return {success =&gt; 1、row =&gt; $ row};
 }
    </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     挿入時と同じ優先順位。 送信されるデータの妥当性もチェックされないという事実は、覚えておいてください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perlコード（6） <pre> ＃------------------------------------------------- -------------------------------------------------- --------------------
 ＃更新
    
     ＃ツリーを下に移動する
     my $ update = MY :: NestedSets-&gt; update（$ table_name、{field1 =&gt; 'row-u-1-'。$ tree、ids =&gt; 1、lk =&gt; 10、tr =&gt; $ tree}）;
         Dumper $の更新を警告します。
     ＃ツリーを上に移動する
     $ update = MY :: NestedSets-&gt; update（$ table_name、{field1 =&gt; 'row-u-4-'。$ tree、ids =&gt; 6、lk =&gt; 1、tr =&gt; $ tree}）;
         Dumper $の更新を警告します。
     ＃親を変更
     $ update = MY :: NestedSets-&gt; update（$ table_name、{field1 =&gt; 'row-u-8-'。$ tree、ids =&gt; 2、pi =&gt; 5、tr =&gt; $ tree}）;
         Dumper $の更新を警告します。
    </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> ノードを削除 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     すぐにコーディング、内部のコメント： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perlコード（7） <pre>サブ削除{
 ＃着信データを適切に場所に配布し、それに応じて十分なデータがあるかどうかをチェック
    シフトif $ _ [0] &amp;&amp;（$ _ [0] eq __PACKAGE__ ||（ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__））;
     my（$ table_name、$ id、$ flag）= @_;
     return {success =&gt; 0、error =&gt; 'Bad Income data！'} $ dbh &amp;&amp; $ table_name &amp;&amp; $ id;
 ＃どんな種類のテーブルを見つけて、追加の属性とフィールドシノニムを取得します
    私の$ table = $ tables-&gt; {$ table_name} ||  $ tables-&gt; {default};
    私の$ f = $ table-&gt; {fields};
 ＃渡されるパラメーターの数と量のトリガーのように制限されていないため、
 ＃削除の実装は二重になります：ブランチ全体を削除し、ツリーの1つのノードを削除します
 ＃デフォルトでは、ブランチ全体を削除します
     $ flag = {cascade =&gt; 'cascade'、one =&gt; 'one'}-&gt; {$ flag ||  'カスケード'} ||  'カスケード';
 ＃削除するノードを選択します。必要なフィールドは、tree、left_key、right_keyの3つだけです
 ＃それをパラメーターとして渡すことはできますが、何がわからないのか、その前にキーを変更することもできますが、
 ＃これでツリーが崩れます。
    私の$ sql = 'SELECT'。
             （$テーブル-&gt; {multi}？$ f-&gt; {tree}。「ASツリー」： ''）。
             $ f-&gt; {parent_id}。 '  AS parent_id、 '。
             $ f-&gt; {レベル}。 '  ASレベル、 '。
             $ f-&gt; {left_key}。 '  AS left_key、 '。
             $ f-&gt; {right_key}。 '  AS right_key '。
              「FROM」$ Table_name。
              'WHERE'。$ F-&gt; {id}。 '  = '。$ id;
    私の$ sth = $ dbh-&gt; prepare（$ sql）;  $ sth-&gt;実行||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
    私の古い$ $ sth-&gt; fetchrow_hashref（）;
     $ sth-&gt; finish;
     return {success =&gt; 0、error =&gt; 'No old unit！'}} $ oldでない限り;
     if（$ flag eq 'cascade'）{
 ＃ブランチを削除
         my $ query = 'DELETE FROM'。$ table_name。
                    「どこ」。
                         （$ table-&gt; {multi}？$ f-&gt; {tree}。 '='。$ old-&gt; {tree}。 'AND'： ''）。
                         $ f-&gt; {left_key}。 '  &gt; = '。$ old-&gt; {left_key}。'  AND '。
                         $ f-&gt; {right_key}。 '  &lt;= '。$ old-&gt; {right_key};
         $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
 ＃キーギャップを削除します。
        私の$ skew_tree = $ old-&gt; {right_key}-$ old-&gt; {left_key} + 1;
         $ query = 'UPDATE' $ table_name。
                     'SET'。$ F-&gt; {left_key}。 '  =「。$ F-&gt; {left_key}」の場合。  &gt; '。$ old-&gt; {left_key}。'
                                                    それから '。$ F-&gt; {left_key}'。  -'。$ skew_tree。'
                                                     ELSE '。$ F-&gt; {left_key}'。
                                                END、 '。
                             $ f-&gt; {right_key}。 '  = '。$ f-&gt; {right_key}。'  -'。$ skew_tree。
                     「どこ」。
                         （$ table-&gt; {multi}？$ f-&gt; {tree}。 '='。$ old-&gt; {tree}。 'AND'： ''）。
                         $ f-&gt; {right_key}。 '  &gt; '。$ old-&gt; {right_key}。'; ';
 ＃読み取り可能な形式のリクエスト：
 ＃UPDATE $ table_name
 ＃SET left_key = left_key&gt; OLD.left_keyの場合
 ＃THEN left_key-$ skew_tree
 ＃ELSE left_key
 ＃END、
 ＃right_key = right_key-$ skew_tree
 ＃どこ
 ＃[tree = OLD.tree AND]
 ＃right_key&gt; OLD.right_key;
         $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
     } else {
 ＃ノードを削除
         my $ query = 'DELETE FROM'。$ table_name。 '  WHERE '。$ F-&gt; {id}。'  = '。$ id。'  LIMIT 1 ';  ＃知らない
         $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
 ＃ギャップを削除し、下位ブランチを再構築します
         $ query = 'UPDATE' $ table_name。
                     'SET'。$ F-&gt; {left_key}。 '  =「。$ F-&gt; {left_key}」の場合。  &lt;'。$ old-&gt; {left_key}。'
                                                    それから '。$ F-&gt; {left_key}'。
                                                     「。$ F-&gt; {right_key}」の場合のその他の場合。  &lt;'。$ old-&gt; {right_key}。'
                                                              それから '。$ F-&gt; {left_key}'。  -1 
                                                               ELSE '。$ F-&gt; {left_key}'。  -2
                                                         終了
                                                END、 '。
                             $ f-&gt; {parent_id}。 '  = '。$ F-&gt; {right_key}の場合。  &lt;'。$ old-&gt; {right_key}。
                                                           「AND」。$ F-&gt; {レベル}。  = '。$ old-&gt; {level}。'  + 1
                                                      THEN '。$ Old-&gt; {parent_id}'
                                                      ELSE '。$ F-&gt; {parent_id}'。
                                                 END、 '。
                             $ f-&gt; {レベル}。 '  = '。$ F-&gt; {right_key}の場合。  &lt;'。$ old-&gt; {right_key}。'
                                                  THEN '。$ F-&gt; {レベル}。  -1
                                                  ELSE '。$ F-&gt; {レベル}'。
                                             END、 '。
                             $ f-&gt; {right_key}。 '  = '。$ F-&gt; {right_key}の場合。  &lt;'。$ old-&gt; {right_key}。'
                                                      THEN '。$ F-&gt; {right_key}'。  -1 
                                                      ELSE '。$ F-&gt; {right_key}。  -2
                                                終了
                       WHERE '。
                             （$ table-&gt; {multi}？$ f-&gt; {tree}。 '='。$ old-&gt; {tree}。 'AND'： ''）。
                            '（'。$ f-&gt; {right_key}。 '&gt;'。$ old-&gt; {right_key}。 'OR
                             （ '。$ f-&gt; {left_key}。'&gt; '。$ old-&gt; {left_key}。' AND '。$ f-&gt; {right_key}。' &lt;'。$ old-&gt; {right_key}。'）） ; ';
 ＃読み取り可能な形式のリクエスト：
 ＃UPDATE $ table_name
 ＃SET left_key = left_key &lt;OLD.left_keyの場合
 ＃THEN left_key
 ＃その他の場合right_key &lt;OLD.right_key
 ＃THEN left_key-1 
 ＃ELSE left_key-2
 ＃END
 ＃END、
 ＃parent_id = right_key &lt;OLD.right_key AND `level` = OLD.level + 1の場合
 ＃THEN OLD.parent_id
 ＃ELSE parent_id
 ＃END、
 ＃ `level` = right_key &lt;OLD.right_keyの場合
 ＃THEN `レベル`-1 
 ＃ELSE `レベル`
 ＃END、
 ＃right_key = right_key &lt;OLD.right_keyの場合
 ＃THEN right_key-1 
 ＃ELSE right_key-2
 ＃END
 ＃どこ
 ＃[tree = OLD.tree AND]
 ＃（right_key&gt; OLD.right_key OR
 ＃（left_key&gt; OLD.left_key AND right_key &lt;OLD.right_key））;
         $ dbh-&gt; do（$ query）||  return {success =&gt; 0、error =&gt; $ dbh-&gt; errstr};
     }
     return {成功=&gt; 1};
 }
    </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     正直に言うと、結果として返すのに何が正しいかはまだわかりませんが、成功したというフラグだけで十分なようです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perlコード（8） <pre>     my $ delete = MY :: NestedSets-&gt; delete（$ table_name、2）;
     $ delete = MY :: NestedSets-&gt; delete（$ table_name、3、 'one'）;
     $ delete = MY :: NestedSets-&gt; delete（$ table_name、4）;
    </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     実際にはそれだけです。 輝くフランネルの布で拭いて、行ってください。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J65482/index.html">FBIは1日あたり200,000の指紋を分析します</a></li>
<li><a href="../J65483/index.html">42枚のフロッピーディスク</a></li>
<li><a href="../J65487/index.html">Yandexは、アルゴリズムの次のアップデートであるArzamas 1.2のテストを発表しました</a></li>
<li><a href="../J65492/index.html">好きではなかった</a></li>
<li><a href="../J65493/index.html">Habrアップデート</a></li>
<li><a href="../J65498/index.html">ロシアでの電子マネーの引き出し方法の概要</a></li>
<li><a href="../J65499/index.html">ASUS Eee PC 1004DN-DVDドライブを搭載した最初のネットブックの販売が開始されました</a></li>
<li><a href="../J65503/index.html">Pythonで2メガバイトのメモリで100万個の32ビット整数をソートする</a></li>
<li><a href="../J65504/index.html">トランスヘッドセット</a></li>
<li><a href="../J65512/index.html">dNaNoとは何ですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>