<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🌾 ⏩ ✂️ オプティカルフローについて知りたいが、聞いて恥ずかしかったこと 👩🏻‍🤝‍👨🏽 🤓 🤜🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="オプティカルフロー（オプティカルフロー）-シフト、セグメンテーション、オブジェクトの選択、ビデオ圧縮を決定するためにコンピュータービジョンのさまざまな分野で使用される技術。 しかし、ウィキペディアまたは他の場所で読んでプロジェクトにすばやく実装したい場合は、非常にうまく機能せず、すでに1〜2のオーダ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>オプティカルフローについて知りたいが、聞いて恥ずかしかったこと</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/6e7/202/488/6e7202488554327be02a3b211df4647a.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     オプティカルフロー（オプティカルフロー）-シフト、セグメンテーション、オブジェクトの選択、ビデオ圧縮を決定するためにコンピュータービジョンのさまざまな分野で使用される技術。 しかし、ウィキペディアまたは他の場所で読んでプロジェクトにすばやく実装したい場合は、非常にうまく機能せず、すでに1〜2のオーダーのシフトを決定するときに失敗するという事実につまずくでしょうピクセル（少なくとも私と一緒に）。 次に、たとえばOpenCVでの既製の実装を使用します。 そこではさまざまな方法で実装されており、略語PyrLKがFarnebackまたはそのようなものよりも優れているか悪いのかは完全に理解不能であり、いくつかの実装では非常に多くのパラメーターの意味を処理する必要があります。 そして、興味深いことに、これらのアルゴリズムは、私たち自身が書いたものとは対照的に、何らかの形で機能します。 その秘密は何ですか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> オプティカルフローとは何ですか？ </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     オプティカルフロー（OP）は、目に見える動きの画像であり、2つの画像間の各ポイントのシフトです。 実際、これは速度フィールドです（スケールに対して正確なシフトは瞬間速度に等しいため）。  OPの本質は、画像の各ポイントに対して <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DI_%7B1%7D(x,y)"><img src="https://habrastorage.org/getpro/habr/post_images/f71/612/3c2/f716123c2f39bc49d6918609b906d32d.gif" title="I_ {1}（x、y）"></a> このようなシフト（dx、dy）は、2番目の画像上の点が開始点に対応することがわかります <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DI_%7B2%7D(x%26plus%3Bdx,y%26plus%3Bdy)"><img src="https://habrastorage.org/getpro/habr/post_images/2b4/c10/d02/2b4c10d02e21c2ac9f51f206f53d85ac.gif" title="I_ {2}（x + dx、y + dy）"></a>  。 ポイントの対応を判断する方法は別の問題です。 これを行うには、変位の結果として変化しない点の何らかの関数を取る必要があります。 一般に、ポイントは強度（つまり、カラー画像の明るさまたは色）を保持すると考えられていますが、同じ勾配値、ヘッセ行列、その値またはその行列式、ラプラシアン、およびその他の特性を持つポイントは同一と見なすことができます。 明らかに、照明または光の入射角が変化すると、強度の維持は失敗します。 それでも、ビデオストリームについて話している場合、2つのフレーム間で照明があまり変化しないのは、それらの間に短い時間が経過した場合だけです。 したがって、強度は多くの場合、そのポイントに残る関数として使用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このような記述によれば、OPは特徴点の検索および比較と混同される可能性があります。 しかし、これらは異なるものであり、光学ストリームの本質は、特別なポイントを探すのではなく、任意のポイントがシフトした画像のパラメーターによって決定しようとすることです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     光束の計算には、高密度と選択的（疎）の2つのオプションがあります。 スパースストリームは、個々の特定のポイント（たとえば、いくつかの特徴検出器によって選択されたポイント）のシフトを計算し、高密度ストリームは画像内のすべてのポイントのシフトを考慮します。 当然、サンプルストリームはより高速に計算されますが、一部のアルゴリズムでは差はそれほど大きくなく、一部のタスクでは画像のすべてのポイントでストリームを見つける必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     縮退した場合には、シフトを決定するためのより単純な方法を適用できます。 特に、画像のすべてのポイントに同じシフトがある場合（画像全体がシフトする場合）、位相相関法を適用できます：両方の画像のフーリエ変換を計算し、位相の畳み込みを見つけ、そのシフトを決定します（ <a href="http://en.wikipedia.org/wiki/Phase_correlation">en.wikipedia.orgを</a>参照） <a href="http://en.wikipedia.org/wiki/Phase_correlation">/ wiki / Phase_correlation</a> ）。 ブロックマッチングを使用することもできます。ウィンドウ内の画像の差の標準を最小化するシフトを見つけます。 純粋な形では、このようなアルゴリズムは長時間機能し、曲げやその他の歪みに対して不安定です。  <a href="http://en.wikipedia.org/wiki/Optical_flow">英語版ウィキペディアに</a>は、これらのアルゴリズムがオプティカルフローを計算するための異なるオプションとしてリストされていますが、これらのアルゴリズムは他の目的に使用でき、この問題を完全には解決しないため、あまり正確ではないようです。 画像の局所的な特性に基づいてオプティカルフローメソッド（英語版ウィキペディアでは差分法と呼ばれます）を呼び出します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 標準アプローチ（ルーカス-カナダ法） </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズムの数学的な説明は<a href="http://habrahabr.ru/post/169055/">この記事</a>で十分詳細に説明され<a href="http://habrahabr.ru/post/169055/">ていますが</a> 、理論的な側面のみが影響を受けます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     変位の結果としてのポイントの強度が変化していないと仮定して、オプティカルフローの数学モデルを検討します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     させて <img src="https://habrastorage.org/getpro/habr/post_images/fd3/055/cea/fd3055ceaa3ac999993187efe591cc42.gif"> 最初の画像（つまり、時間t）のある点（x、y）の強度です。  2番目の画像では、この点は（dx、dy）にシフトしますが、dtは通過し、 <img src="https://habrastorage.org/getpro/habr/post_images/d80/ad7/750/d80ad77501aec2e45d1b199cabe7db55.gif">  -テイラーに従って強度関数を第1項に分解しました（理由は第1項のみです） <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DI_%7Bx%7D,I_%7By%7D,I_%7Bt%7D"><img src="https://habrastorage.org/getpro/habr/post_images/f99/825/2f4/f998252f474a4343e85c303adf28373e.gif" title="I_ {x}、I_ {y}、I_ {t}"></a>  -座標と時間に関する、つまり本質的に偏微分 <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DI_%7Bt%7Ddt"><img src="https://habrastorage.org/getpro/habr/post_images/fa2/480/f49/fa2480f4986572e0094d9e2872b7812d.gif" title="I_ {t} dt"></a>  -2つのフレーム間のポイント（x、y）の輝度の変化。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ポイントは強度を保持していると考えています。つまり、 <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DI_%7B1%7D%3DI_%7B2%7D%5CRightarrow"><img src="https://habrastorage.org/getpro/habr/post_images/fd6/d01/d16/fd6d01d1619a38b1dadb04280c84f7f5.gif" title="I_ {1} = I_ {2} \右矢印"></a> <img src="https://habrastorage.org/getpro/habr/post_images/240/a53/130/240a531308dcc6d61a797f29f0d09b7d.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2つの未知数（dxとdy）を持つ1つの方程式が得られます。つまり、解くのに十分ではありません。つまり、この方程式を理解することはできません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題の最も簡単な解決策は、ルーカスカナダアルゴリズムです。 画像オブジェクトには1ピクセルより大きいので、現在のポイントの近くでは、他のポイントもほぼ同じシフトを持っている可能性が高いことを意味します。 したがって、この点の周りにウィンドウを取り、ガウスに従って分布した重み係数を使用して、つまり、調査中のピクセルに最も近いピクセルの重みが最大になるように、（最小二乗法に従って）合計誤差を最小化します。 最も単純な変換の後、2つの未知数を持つ2つの方程式のシステムを取得します。 <img src="https://habrastorage.org/getpro/habr/post_images/0ce/761/7f0/0ce7617f00672f62bc3b8819af66f72d.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/f56/644/5aa/f566445aa7c1524c856f73396a28dea5.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ご存じのように、このシステムには常に一意の解があるわけではありません（非常に頻繁ですが）。システムの行列式がゼロの場合、解がないか無限数になります。 この問題は、開口の問題として知られています-周期的な画像の視野が限られている変位のあいまいさ。 これは、ある程度の周期性がある画像の断片が視野に入る場合に対応します。 ここでも、写真がどこに移動したかを人が明確に判断することはできません。 問題は、このようなあいまいな状況でのノイズのために、ゼロの行列式ではなく、非常に小さな値が得られ、シフトの値が非常に大きくなる可能性があり、実際には特に相関しないことです。 そのため、特定の段階で、システムの行列式が十分に小さくないかどうかを確認する必要があります。もしそうであれば、そのような点を考慮したり、エラーとしてマークしないでください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> なぜ機能しないのですか？ </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この段階で停止してこのアルゴリズムを実装すると、正常に機能します。 しかし、隣接する画像間のシフトが非常に小さく、1ピクセルのオーダーである場合にのみ、常にではありません。  （品質分析のために異なる相対オフセットを持つ合成シーケンスが生成され、このシフトは非整数のピクセル数で表すことができ、結果のイメージはそれに応じて補間されます）2ピクセルのシフトではすでにエラーが大きくなり、3以上の場合、結果は一般に不十分になります。 問題は何ですか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     その後、数学が用意されました。 彼女は、周囲のすべての機能が何度も連続的で微分可能であるという感覚を私たちに植え付けました。 一般に、研究所では、テイラーの式を使用して、点の近傍に関数の近似を書くように教えられました。 ここで、この場所で派生物の物理的な意味は何ですか？ それらを使用して、点の有限近傍で関数の値の変化を決定し、導関数は無限に小さい近傍のアイデアを与えます。 この近傍を拡大するには、テーラー展開に高次の導関数を追加できますが、これはシステムの非線形性につながり、解決がはるかに困難になり、特に実際には連続的で微分可能な微分を扱っていないため、利点は疑わしいです関数であり、一般的にどの離散関数かは明確ではありません。 したがって、関数g（x）を探す方が論理的です。この場合、離散ケースでは、f（x）+ g（x）= f（x + 1）、f（x）+ 2g（x）= f（x +2）、f（x）-g（x）= f（x-1）などしたがって、この場合、導関数は必要ありませんが、元の関数の点に最も近い線形関数が必要です。 簡単な数学的計算が解決につながる <img src="https://habrastorage.org/getpro/habr/post_images/873/fc4/f2e/873fc4f2ef7f7bc8cc586734f2e1eeb6.gif"> どこで <img src="https://habrastorage.org/getpro/habr/post_images/5e3/400/fb2/5e3400fb2e1b01aad1ad4c61fc1f286a.gif">  。 各辺の1つの隣接点に導関数を構築した場合、幸運でした：この場合、式は導関数の近似計算の式と一致します：g（x）=（f（x + 1）-f（x-1））/ 2。 OpenCVで典型的なことは、ルーカスカナダの光束を計算するとき、この式が使用されます。これについては後で説明します。 しかし、より多くのポイントを取得すると、式はすでに一次導関数の古典的な差分スキームとは完全に異なります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     明らかに、たとえば元のポイントの左右の3つの隣接するポイントからこの関数を構築する場合、それはより遠くにあるポイントにまったく依存せず、したがって、3つ以上のポイントをシフトすると、不適切な結果が得られることがよくあります。 また、この関数を作成するポイントの数が多いほど、使用されるポイントからの結果の線の平均偏差が大きくなります-再び、線形に変化する画像はないが、悪魔はどの画像を知っているかという事実によります。 実際には、2ピクセルを超えるシフトでは、ポイント数に関係なく、すでに十分に大きなエラーが発生していません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズムのもう1つの弱点は、ここでも滑らかな連続関数ではなく、任意の、さらには離散的な関数を扱っていることです。 そのため、画像の一部の断片では、強度が明白な規則性なしで、たとえばオブジェクトの境界で、またはノイズのために「スキップ」する可能性があります。 この場合、関数g（x）は、点の近くでの画像の変化を正確に記述できません。 これを（少なくとも部分的に）解決するには、元の画像を汚すことをお勧めします。非常に強く汚すのが便利です。つまり、全員のお気に入りのガウスぼかし（重み係数による平均化）ではなく、同じボックスフィルター（ウィンドウ全体の均一な平均​​化） ）、さらには数回続けて。 画像の滑らかさは、細部よりも重要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ただし、これらの手段によって、検出された2〜3ピクセルのシフトを制限することもできません。 ところで、OpenCV 1.0では、このような光学ストリームの実装があり、非常に小さなシフトでの理想的な条件でのみ機能しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> どうする？ </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     全体で普通のルーカス・カナダは、小さなシフトを明確に定義しており、その中の写真はその線形近似に似ています。 これを克服するために、標準のCVテクニック-マルチスケーリングを使用します。異なるスケールの画像の「ピラミッド」を構築し（ほとんどの場合、各軸で2倍にスケーリングされ、カウントしやすくなります）、小さな画像から大きな画像への光学ストリームでそれらを通過しますその後、小さな画像で検出された小さなシフトは、大きな画像での大きなシフトに対応します。 最小の画像では、1-2ピクセル以下のシフトが見つかり、小さいスケールから大きいスケールに移動します。前のステップの結果を使用して、シフト値を調整します。 実際、OpenCVでは、calcOptFlowPyrLK関数によって実装されます。 このピラミッドアルゴリズムを使用すると、多くのポイントで線形近似を計算する必要がなくなります。ピラミッドのレベルを増やし、各レベルでこの関数のかなり大まかな近似をとる方が簡単です。 したがって、OpenCVでは、2つの隣接ポイントのみの計算があります。 したがって、このアルゴリズムの実装に関連して、導関数に対する近似関数の利点に関する結論は役に立たないことが判明しました。このような数の制御点では、導関数が最良の近似関数です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> そして、他に何がありますか？ </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムは、光束を計算するための唯一のオプションではありません。  OpenCVには、Lucas-Canadaストリームに加えて、FarnebackストリームとSimpleFlowもあります。これらは、しばしばHorn – Schunckアルゴリズムを指します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Horn – Schunckメソッド</b>は、Lucas-Canadaメソッドよりも多少グローバルです。 これは、画像全体の光束が非常に滑らかになるという仮定に基づいています。 同じ方程式から <img src="https://habrastorage.org/getpro/habr/post_images/240/a53/130/240a531308dcc6d61a797f29f0d09b7d.gif"> 機能に行くことを提案 <img src="https://habrastorage.org/getpro/habr/post_images/408/f58/8d3/408f588d3cb05bc7382f837ecc8ecf20.gif">  、つまり、重み係数αでシフトの急激な変化がないという要件を追加します。 この関数を最小化すると、2つの方程式のシステムが得られます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/17e/fbc/79a/17efbc79aea908239ef99a47018bce6e.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/f38/e8c/b3a/f38e8cb3adc643694b4e08559e55d798.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらの方程式では、ラプラシアンはおよそ計算することを提案します： <img src="https://habrastorage.org/getpro/habr/post_images/e82/489/c96/e82489c96f4090512dfa656998a04c2f.gif">  -平均値との差。 各ピクセルに対して記述する方程式系を取得し、一般的なシステムを反復的に解きます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/a34/68c/2e9/a3468c2e91b7c7e4f44cdd51b13f170a.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/152/655/864/152655864a0daca7ecaf8baba9077b7a.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムでは、マルチスケーリングを使用することも提案されており、画像を2倍ではなく、0.65の係数でスケーリングすることをお勧めします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムは、OpenCVの最初のバージョンで実装されましたが、後に放棄されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Farneback</b>は、2次形式を使用して近傍の強度の変化を近似することを提案しました：I = xAx + bx + c with symmetric matrix A（実際、Taylor展開を第1項に考慮して、線形近似I = bx + cを採用しました近似の精度を上げることに決めた回数）画像がこの近傍内でシフトした場合、 <img src="https://habrastorage.org/getpro/habr/post_images/cef/f63/791/ceff6379139b144d6d2c290118c7c8d5.gif">  、二次展開に置き換えて、括弧を開きます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/090/fa5/838/090fa58384ab43497db73237eb3a988e.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/030/eba/ae7/030ebaae7c37805e0be02defef7b4244.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/9d4/449/ebb/9d4449ebb384df15ef0853676772cdc9.gif">  。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これで、両方の写真のA、b、cの値を計算でき、このシステムはdに関して冗長になり（特に最初の式はわかりにくい）、一般にdは2番目の式から得られます： <img src="https://habrastorage.org/getpro/habr/post_images/ef8/7cf/c7d/ef87cfc7d6261d21a899cf835ab7df3a.gif">  。 次の近似に頼らなければなりません： <img src="https://habrastorage.org/getpro/habr/post_images/203/301/bf3/203301bf395673df883b82488e29ca14.gif">  。 簡単にするために示す <img src="https://habrastorage.org/getpro/habr/post_images/b37/4b0/d2f/b374b0d2f529418ef08c5def9fe659b7.gif"> それから私達はちょうど得る <img src="https://habrastorage.org/getpro/habr/post_images/b43/4e2/d0c/b434e2d0c3ae8e29e4249dc5c9aed27d.gif">  。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     計算のノイズを補正するために、検討中のポイントの近くでは、すべてのポイントがほぼ同じシフトを持っているという仮定に再び戻ります。 したがって、エラーを再度統合します <img src="https://habrastorage.org/getpro/habr/post_images/a7e/62d/483/a7e62d48343e482228cf72e68de75445.gif"> ガウスの重み係数<i>w</i>を使用してウィンドウ上で、この合計誤差を最小化するベクトルdを見つけます。 次に、最適な値を取得します <img src="https://habrastorage.org/getpro/habr/post_images/771/272/648/77127264820430245399b7c058413ed9.gif"> および対応する最小誤差 <img src="https://habrastorage.org/getpro/habr/post_images/202/f32/3c0/202f323c016171111b818ae08b97ef6f.gif">  。 つまり、各ポイントについて計算する必要があります <img src="https://habrastorage.org/getpro/habr/post_images/98d/eec/6dd/98deec6ddd703117053247522a2da8af.gif">  、ウィンドウ全体で平均し、行列を反転して結果を取得します。 したがって、これらの積は画像全体について計算でき、異なるポイントに対して事前に計算された値を使用できます。つまり、これは、高密度ストリームを考慮することが理にかなっている場合にのみ当てはまります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     いつものように、このアルゴリズムには多くの修正と改善があり、主に既知のアプリオリ情報（フローの所定の初期近似）の使用を可能にし、再びマルチスケーリングを可能にします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>SimpleFlow</b>メソッドは、次の考え方に<b>基づい</b>ています。導関数を検索したウィンドウのサイズ以上のシフトを決定する方法がまだわからない場合、なぜ導関数の計算に煩わされるのでしょうか。 ウィンドウ内で最も類似したポイントを見つけましょう！ また、あいまいさを解決し、ノイズを補正するために、流れが連続的であり、このポイントの近くではすべてのポイントがほぼ同じシフトを持つことを考慮します。 また、ウィンドウサイズの問題は、マルチスケーリングによって再び解決されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     より厳密には、アルゴリズムは次のとおりです。ウィンドウ内のすべてのポイントに対して、開始ポイントからこのポイントへの遷移の確率に（逆対数依存性で）対応する「エネルギー」の関数があります。 <img src="https://habrastorage.org/getpro/habr/post_images/95a/5bb/1f2/95a5bb1f2de9ef34b6c376a4e85c3003.gif">  。 さらに、このエネルギーとガウスウィンドウの畳み込みが考慮されます <img src="https://habrastorage.org/getpro/habr/post_images/829/bd8/f54/829bd8f541609108d50d8bd269f146de.gif"> この関数を最小化する値（dx、dy）が見つかりました。 サブピクセルの精度を得るには、見つかった最適点（dx、dy）の小さな近傍を考慮し、その中のエネルギー関数のピークを放物面のピークとして探します。 また、前述のように、この手順はスケーリングされた画像のピラミッドに対して実行されます。 また、計算を高速化するためのcな方法もありますが、誰もが自分でそれを理解するのは興味深いことです。 このため、このアルゴリズムは（理論的に）非常に高速で、精度が高いことが重要です。 そして、彼は以前のものほど問題がなく、シフトが大きければ大きいほど、それはより悪く検出されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> そして、あなたが強さではない場合？ </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     上記では、ポイント間の対応は異なる値で決定できると言われましたが、なぜ強度だけを考慮するのですか？ そして、他の数量を減らすことができるため、適切なフィルターで画像をフィルター処理し、フィルター処理された画像を上記のアルゴリズムの入力に送ります。 したがって、光ストリームを使用する場合は、まず、どの画像特性が条件の下で最も安定するかを考え、適切なフィルタリングを実行して、この特性がアルゴリズムの入力での強度にならないようにします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 練習する </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      OpenCVが提供するアルゴリズムを実際に試してみましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここでは、さまざまなシフト、回転、射影変換、セグメント、さまざまなノイズなどを使用して、パラメータを変更し、入力シーケンスを変更して、各アルゴリズムのさまざまな研究を行うことができます。これには時間がかかり、現在の記事のサイズを超えますしたがって、ここでは、固定距離の小さな画像シフトと小さなノイズの単純な平行移動に限定することを提案します。 これにより、一般的な用語でアルゴリズムの実行方法とそれらのどれがよりクールであるかを理解できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     手順の構文は、 <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html">マニュアル</a>ページで詳細に説明されています。ここでは、コメントとともにsqueeze-translationを示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     従来のLucas-Canadaは、calcOpticalFlowPyrLKプロシージャにピラミッドを実装しています。 アルゴリズムは、スパースストリームを計算します。つまり、最初の画像の特定のポイントセットについて、2番目の画像の位置を推定します。 入力パラメーターは非常に明白です：2つの入力画像、ポイントの入力および出力セット、status-対応するポイントが正常に検出されたかどうかを示す出力ベクトル、err-対応するポイントの推定誤差の出力ベクトル、WinSize-ガウス平均が発生するウィンドウのサイズ、 21x21、それはうまく機能しました、maxLevel-ピラミッドのレイヤー数-1、つまり最後のレイヤーの数、私は5つの基準を取りました-シフトを決定する反復プロセスを終了するための条件（エラーを反復的に最小化する）-これ パラメータIはデフォルト、フラグを左 - 追加フラグは、初期の近似法または選択フロー推定誤差、minEigThresholdとして使用することができる - 勾配閾値、縮退行列と考えられるの下、私はデフォルトで左。  OpenCV 2.4.1以降では、事前に計算されたスケーリング画像のピラミッドを使用してストリームを計算できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     作業の結果、小規模および大規模なシフトの両方が正常に安定して検出され、かなり大きなノイズに耐えることができます。動作時間は5層ピラミッド（コアi7 950）で400ポイントで約10 msです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ちなみに、このアルゴリズムは、高密度バージョンと疎バージョンの両方のGpu（CUDA）にも実装されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      FarnebackストリームはcalcOpticalFlowFarnebackプロシージャによって実装され、高密度ストリーム、つまり各ポイントのシフトが計算されます。 パラメーター：入力画像、フロートの2チャネルマトリックス形式の出力ストリーム、pyr_scaleはピラミッドのレイヤー間のスケールの比率を決定します。levels-ピラミッドのレベル数、winsize-平均化されるウィンドウのサイズ、iterations-各レベルでの反復数、poly_n- Aおよびbの値を推定する多項式のサイズ、poly_sigmaは微分を平滑化するときのガウスぼかしのシグマ、推奨パラメーター値はマニュアルに示され、フラグは追加フラグです。たとえば、初期近似を使用できます  IX流れまたはその他のウィンドウ上で平均。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムは（私の観察によれば）安定性がはるかに低く、かなり均一な画像を見逃しやすく（明らかに、問題は失敗したポイントのフィルタリングの欠如です）、大きなシフトを適切に判断できません。  512x512の画像で600ミリ秒働いた。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      SimpleFlowストリームはcalcOpticalFlowSFプロシージャを実装し（再び、高密度ストリームが計算されます）、デフォルト値のない多くの神秘的なパラメーターを持ち、一般的に、現時点ではページの情報は非常に簡潔に提供されます。 それを理解してみましょう。 最初の3つは入力画像で、出力2チャンネルです。 レイヤー-ピラミッド内のレイヤーの数、つまり、元の画像がスケーリングされる回数。  averageing_block_size-ピクセルエネルギー関数を計算したウィンドウのサイズ。  max_flow-各ステップで決定できるようにする最大シフト。実際、ウィンドウのサイズによって決定されます（intである理由は完全には明らかではありません）。 ここで停止するか、さらにいくつかのパラメーターを設定することができますが、それらのいくつかの意味は私を惑わしています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このサイトは<a href="">、</a> calcOpticalFlowSF（frame1、frame2、flow、3、2、4、4.1、25.5、18、55.0、25.5、0.35、18、55.0、25.5、10）で始まる使用<a href="">例を</a>提供<a href="">し</a>ます。 ; 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私のアルゴリズムは他のアルゴリズムよりもずっと遅く、512x512の画像につき約9〜12秒です。 作業の結果は、ファーンバックよりももっともらしいようです。少なくとも、均一な画像の変化はより明確に判断され、大きな変化の場合ははるかにうまく機能します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 結論 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     オプティカルストリームをどこかで使用する場合は、まずそれが必要かどうかを考えます。多くの場合、より簡単な方法で実行できます。 自分でフローを実装することは、数回考えられているだけです。各アルゴリズムには、多くのトリック、微妙さ、最適化があります。     ,  ,  OpenCV     (,  ,    ).              SSE , ,    CUDA  OpenCL  . .         (. . sparse ),      calcOpticalFlowPyrLK,   ,    .   dense-    calcOpticalFlowSF,     .   ,  calcOpticalFlowFarneback,    ,      . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 文学 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html">docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     Pyramidal Implementation of the Lucas Kanade Feature Tracker. Description of the algorithm — Jean-Yves Bouguet 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     Two-Frame Motion Estimation Based on Polynomial Expansion — Gunnar Farneback 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     SimpleFlow: A Non-iterative, Sublinear Optical Flow Algorithm — Michael Tao, Jiamin Bai, Pushmeet Kohli, and Sylvain Paris 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     Horn-Schunck Optical Flow with a Multi-Scale Strategy — Enric Meinhardt-Llopis, Javier Sanchez 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href="http://en.wikipedia.org/wiki/Optical_flow">en.wikipedia.org/wiki/Optical_flow</a> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J201390/index.html">象の配布：Beelineは、サブスクライバーにEAP-SIM経由でBeeline WI-FIネットワークへの無料アクセスを提供しました</a></li>
<li><a href="../J201396/index.html">知らないかもしれない便利な属性</a></li>
<li><a href="../J201398/index.html">ユーザーのセキュリティ：OAuth、SSL、RSAとのP2Pチャット、i2pのゲート</a></li>
<li><a href="../J201402/index.html">残業とはどういう意味ですか？</a></li>
<li><a href="../J201404/index.html">Age of Empires 2には拡張機能があります（13年で最初）</a></li>
<li><a href="../J201408/index.html">コミュニティがTrueCrypt Open Independent Auditで60,000ドル以上を調達</a></li>
<li><a href="../J20141/index.html">ロゴの進化</a></li>
<li><a href="../J201410/index.html">Gentooの美しさとは：神話と現実</a></li>
<li><a href="../J201412/index.html">Yandexが検索で言語学を使用する方法</a></li>
<li><a href="../J201414/index.html">静的変数の使用と実行可能モジュールの静的リンク</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>