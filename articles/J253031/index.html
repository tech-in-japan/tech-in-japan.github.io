<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛰️ 🛣️ 🙌 CPUとGPUを使用したMSTアルゴリズムのハイブリッド実装 💋 🏌️ 🛁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="はじめに  
  
 最小全域木（MST-最小全域木）の検索の問題を解決することは、さまざまな研究分野における一般的なタスクです：さまざまなオブジェクトの認識、コンピュータービジョン、ネットワークの分析と構築（電話、電気、コンピューター、道路など）、化学そして生物学と他の多くの。 この問題を解決する...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>CPUとGPUを使用したMSTアルゴリズムのハイブリッド実装</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"><h2> はじめに </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最小全域木（MST-最小全域木）の検索の問題を解決することは、さまざまな研究分野における一般的なタスクです：さまざまなオブジェクトの認識、コンピュータービジョン、ネットワークの分析と構築（電話、電気、コンピューター、道路など）、化学そして生物学と他の多くの。 この問題を解決する少なくとも3つの有名なアルゴリズムがあります：Boruvki、KruskalおよびPrima。 大きなグラフ（数GBを占める）の処理は、中央処理装置（CPU）にとってかなり時間がかかるタスクであり、現時点では需要があります。  CPUよりもはるかに優れたパフォーマンスを発揮できるグラフィックアクセラレータ（GPU）が普及しています。 しかし、多くのグラフ処理タスクと同様に、MSTタスクはGPUアーキテクチャにうまく適合しません。 この記事では、GPUでのこのアルゴリズムの実装について説明します。 また、CPUを使用して、1つのノード（GPUと複数のCPUで構成される）の共有メモリ上でこのアルゴリズムのハイブリッド実装を構築する方法も示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> グラフ表示形式の説明 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     将来的に言及され、変換されるため、無向加重グラフのストレージ構造を簡単に検討します。 グラフは、圧縮CSR（圧縮スパース行） <a href="http://en.wikipedia.org/wiki/Sparse_matrix">[1]</a>形式で設定されます。 この形式は、疎行列とグラフの保存に広く使用されています。  N個の頂点とM個のエッジを持つグラフの場合、X、A、およびWの3つの配列が必要です。サイズN + 1の配列X、他の2つは2 * Mです。頂点の任意のペアの無向グラフでは、直接アークと逆アークを保存する必要があるためです。 配列Xは、配列Aに格納されているネイバーのリストの最初と最後を格納します。つまり、頂点Jのネイバーのリスト全体は、インデックスX [J]からX [J + 1]までの配列Aにあります。 頂点Jからの各エッジの重みは、同様のインデックスによって保存されます。説明のために、下の図は、隣接行列と右側のCSR形式を使用して記述された6つの頂点のグラフを示しています（簡単にするため、各エッジの重みは示していません）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/95d/51b/322/95d51b32296c4c4f81735cbb8d69a8c0.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> テスト済みグラフ </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     変換アルゴリズムとMSTアルゴリズムの説明には問題のグラフの構造の知識が必要になるため、テストが行​​われたグラフについてすぐに説明します。 実装パフォーマンスを評価するために、RMATグラフとSSCA2グラフの2種類の合成グラフが使用されます。  R-MAT-グラフは、ソーシャルネットワーク、インターネット<a href="http://www.dislab.org/GraphHPC-2014/rmat-siam04.pdf">[2]</a>からの実際のグラフをうまくモデル化します。 この場合、頂点32の平均連結度を持つRMATグラフを検討し、頂点の数は2のべき乗です。 このようなRMATグラフには、1つの大きな連結コンポーネントと、多数の小さな連結コンポーネントまたは垂れ下がった頂点があります。  SSCA2-graphは、エッジで互いに接続された独立したコンポーネントの大きなセットです<a href="http://dislab.org/GraphHPC-2015/SSCA2-TechReport.pdf">[3]</a> 。  SSCA2グラフは、頂点の平均接続度が32に近く、その頂点の数も2のべき乗になるように生成されます。 したがって、2つの完全に異なるグラフが考慮されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 入力変換 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズムのテストは、ジェネレーターを使用して取得されたグラフRMATおよびSSCA2で実行されるため、アルゴリズムのパフォーマンスを改善するにはいくつかの変換が必要です。 すべてのコンバージョンはパフォーマンス計算に含​​まれません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <b>頂点のリストをローカルで並べ替える</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各頂点について、重みの隣接リストを昇順で並べ替えます。 これにより、アルゴリズムの各反復での最小エッジの選択が部分的に簡素化されます。 このソートはローカルであるため、問題の完全な解決策を提供しません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  <b>グラフのすべての頂点の番号を付け直す</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最も接続された頂点が最も近い番号を持つように、グラフの頂点に番号を付けます。 この操作の結果、接続された各コンポーネントで、最大頂点数と最小頂点数の差が最小になり、小さなグラフィックスプロセスキャッシュを最大限に活用できます。  RMATグラフの場合、この最適化を適用した後でもこのグラフにはキャッシュに収まらない非常に大きなコンポーネントがあるため、RMATグラフの場合、この番号付けの変更は大きな影響を与えません。  SSCA2グラフの場合、このグラフには小さなコンポーネントが多数あるため、この変換の効果はより顕著です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  <b>グラフの重みを整数にマッピングする</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題では、グラフの重みに対して操作を実行する必要はありません。  2つのrib骨の重量を比較できる必要があります。 これらの目的には、GPUでの単精度数値の処理速度が2倍よりはるかに速いため、倍精度数値の代わりに整数を使用できます。 この変換は、一意のエッジの数が2 ^ 32（符号なしintに収まる異なる数の最大数）を超えないグラフに対して実行できます。 各頂点の平均接続度が32 mの場合、この変換を使用して処理できる最大のグラフは2 ^ 28個の頂点を持ち、メモリで64 GBを占有します。 現在まで、アクセラレータNVidia Tesla k40 <a href="http://www.nvidia.ru/object/tesla-supercomputer-workstations-ru.html">[4]</a> / NVidia Titan X <a href="http://www.nvidia.ru/object/geforce-gtx-titan-x-ru.html">[5]</a>およびAMD FirePro w9100 <a href="http://www.amd.com/ru-ru/products/graphics/workstation/firepro-3d/9100">[6]</a>の最大メモリ量は、それぞれ12GBおよび16GBです。 したがって、この変換を使用する単一のGPUで、非常に大きなグラフを処理できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  <b>頂点圧縮</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この変換は、構造が原因でSSCA2グラフにのみ適用されます。 このタスクでは、すべてのレベルのメモリパフォーマンスが決定的な役割を果たします。グローバルメモリから1次キャッシュまでです。 グローバルメモリとL2キャッシュ間のトラフィックを減らすために、頂点情報を圧縮形式で保存できます。 最初に、頂点に関する情報は2つの配列の形式で表示されます。配列Xは、配列Aの隣接リストの開始と終了を格納します（1つの頂点のみの例）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/7a5/165/4d6/7a51654d67ba4b989010a70c820d4562.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     頂点Jには10個のネイバー頂点があり、各ネイバーの数がunsigned int型を使用して格納される場合、J頂点のネイバーのリストを格納するには10 * sizeof（unsigned int）バイトが必要で、2 * M * sizeof（グラフ全体に対して符号なし） int）バイト。  sizeof（unsigned int）= 4バイト、sizeof（unsigned short）= 2バイト、sizeof（unsigned char）= 1バイトと仮定します。 次に、この頂点について、隣接リストを保存するために40バイトが必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このリストの頂点の最大数と最小数の差が8であり、この数を格納するために必要なのは4ビットだけであることに気付くのは難しくありません。 頂点の最大数と最小数の差がunsigned intより小さい可能性があるという考慮事項に基づいて、次のように各頂点の数を表すことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      base_J + 256 * k + short_endV、 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>base_J</b>は、たとえば、隣接リスト全体の最小頂点番号です。 この例では、1になります。この変数はunsigned int型であり、グラフ内の頂点と同じ数の変数があります。 次に、頂点番号と選択したベースの差を計算します。 最小のピークをベースとして選択したため、この差は常に正になります。  SSCA2の場合、この差は符号なしショートに置かれます。  <b>short_endV</b>は、256で除算した残りの部分です。この変数を格納するには、unsigned char型を使用します。  <b>kは</b> 256で割っ<b>た整数部分</b>です。kの場合、2ビットを選択します（つまり、kは0〜3の範囲にあります）。 問題のグラフには、選択した表現で十分です。 ビット表現では、次のようになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/0c2/444/751/0c2444751d1042598d40a17bb63642db.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、頂点のリストを格納するには、この例では、40バイトではなく（1 + 0.25）* 10 + 4 = 16.5バイトが必要であり、グラフ全体では（2 * M + 4 * N + 2 * M / 4 ）の代わりに2 * M *4。N= 2 * M / 32の場合、合計音量は 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <u>（8 * M）/（2 * M + 8 * M / 32 + 2 * M / 4）</u> = <b>2.9回</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> アルゴリズムの一般的な説明 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      MSTアルゴリズムを実装するために、Boruwkaアルゴリズムが選択されました。  Boruwkaアルゴリズムの基本的な説明とその反復の説明は、ここ<a href="http://en.wikipedia.org/wiki/Bor%25C5%25AFvka%27s_algorithm">[7]で</a>十分に説明されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズムによれば、すべての頂点は最初に最小ツリーに含まれます。 次に、次の手順を完了する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 後続の結合のために、すべてのツリー間の最小エッジを見つけます。 このステップでエッジが選択されていない場合、問題に対する答えが受け取られます </li><li> 一致するツリーをマージします。 このステップは2つの段階に分かれています。2つのツリーがマージの候補として相互に示すことができるため、サイクルを削除することと、結合されたサブツリーを含むツリーの数が選択された場合のマージステップです。 明確にするために、最小数を選択します。 マージ中にツリーが1つしか残っていない場合、問題に対する答えが返されます。 </li><li> 結果のツリーに番号を付け直して最初のステップに進みます（すべてのツリーに0からkまでの番号が付けられるように） </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> アルゴリズムの段階 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一般に、実装されるアルゴリズムは次のとおりです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/72b/511/774/72b5117741f549c98148d5af950ee770.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズム全体の抜け道は2つの場合に発生します：N回の反復後のすべての頂点が1つのツリーに結合される場合、または各ツリーから最小エッジを見つけることができない場合（この場合、最小スパニングツリーが検出されます）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  1.最小エッジを検索します。 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、グラフの各頂点が個別のツリーに配置されます。 次に、上記の4つの手順で構成されるツリーを結合する反復プロセスが発生します。 最小エッジを見つける手順により、最小スパニングツリーに含まれるエッジを正確に選択できます。 上記のように、この手順の入力時に、変換されたグラフはCSR形式で保存されます。 エッジは隣接リストの重みで部分的にソートされているため、最小頂点を選択すると、隣接リストを表示し、別のツリーに属する最初の頂点を選択することになります。 グラフにループがないと仮定した場合、アルゴリズムの最初のステップで、最小頂点を選択すると、考慮中の各頂点の隣接リストから最初の頂点が選択されます。これは、隣接頂点のリスト（グラフのエッジと考慮中の頂点を含む）が重みの増加によってソートされるためですエッジと各頂点は別々のツリーに入ります。 他のステップでは、隣接するすべての頂点のリストを順番に表示し、別のツリーに属する頂点を選択する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     隣接する頂点のリストから2番目の頂点を選択し、このエッジを最小にすることができないのはなぜですか？ ツリーを結合する手順（後で検討します）の後に、隣接するもののリストからいくつかの頂点が検討中の頂点と同じツリーに表示される場合があります。これにより、このエッジはこのツリーのループになり、アルゴリズムの条件により、最小エッジを選択する必要があります他の木に。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Union Implement <a href="http://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf">[8]は</a> 、頂点処理を実装し、検索、マージ、およびマージリストを実行するのに適しています。 残念ながら、すべての構造がGPUで最適に処理されるわけではありません。 このタスクで最も有益なのは（他のほとんどの場合と同様）、リンクリストの代わりにGPUメモリで連続配列を使用することです。 以下では、グラフ内の最小エッジを見つけ、セグメントを結合し、サイクルを削除するための同様のアルゴリズムを検討します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最小エッジを見つけるアルゴリズムを検討してください。 次の2つの手順で表すことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 問題のグラフの各頂点（セグメントに含まれる）から出る最小エッジの選択。 </li><li> 各ツリーの最小重みのエッジの選択。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      CSR形式で記録された頂点情報を移動しないようにするために、2つの補助配列を使用して、隣接リストの配列Aの最初と最後のインデックスを保存します。 指定された2つの配列は、1つのツリーに属する頂点リストのセグメントを示します。 たとえば、最初のステップでは、開始値または下限値の配列の値は配列Xの0..Nになり、終了値の配列または上限値の値は配列Xの1..N + 1になります。そして、ツリーを結合する手順の後）、これらのセグメントは混合されますが、メモリ内のネイバーAの配列は変更されません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     両方のステップを並行して実行できます。 最初のステップを完了するには、各頂点（または各セグメント）の隣接リストを見て、別のツリーに属する最初のエッジを選択する必要があります。  1つのワープ（32スレッドで構成される）を選択して、各頂点の隣接リストを表示できます。 隣接するピークAの配列のいくつかのセグメントが行になく、1つのツリーに属していることを覚えておく価値があります（ツリー0に属するセグメントは赤で強調表示され、ツリー1は緑で強調表示されます）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/e61/20b/2fd/e6120b2fd05a471491b1c5831da4a2b5.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     隣接リストの各セグメントはソートされているため、すべての頂点を表示する必要はありません。  1つのワープは32のスレッドで構成されるため、表示は32の頂点の部分で行われます。  32個の頂点を表示した後、結果を結合する必要があり、何も見つからない場合は、次の32個の頂点を表示します。 結果を組み合わせるには、スキャンアルゴリズムを使用できます<a href="http://habrahabr.ru/company/epam_systems/blog/247805/">[9]</a> 。 共有メモリまたは新しいshfl命令<a href="http://on-demand.gputechconf.com/gtc/2013/presentations/S3174-Kepler-Shuffle-Tips-Tricks.pdf">[10]</a> （Keplerアーキテクチャから入手可能）を使用して、1つのワープ内にこのアルゴリズムを実装できます。これにより、1つの命令で1つのワープのスレッド間でデータを交換できます。 実験の結果、shfl命令はアルゴリズム全体の作業を約2倍高速化できることが判明しました。 したがって、この操作は、たとえば次のようにshfl命令を使用して実行できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs pgsql">unsigned idx = blockIdx.x * blockDim.x + threadIdx.x; //    unsigned lidx = idx % <span class="hljs-number"><span class="hljs-number">32</span></span>; #pragma unroll <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> *= <span class="hljs-number"><span class="hljs-number">2</span></span>) { tmpv = __shfl_up(val, (unsigned)<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lidx &gt;= <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) val += tmpv; } tmpv = __shfl(val, <span class="hljs-number"><span class="hljs-number">31</span></span>); //     .    <span class="hljs-number"><span class="hljs-number">1</span></span>,  -   //  ,    .</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このステップの結果、各セグメントについて次の情報が記録されます。最小重みのエッジに含まれる配列Aの頂点の数とエッジ自体の重み。 何も見つからない場合は、たとえば、頂点番号にN + 2の数を書き込むことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2番目のステップは、選択した情報、つまり各ツリーの最小重みを持つエッジの選択を減らすために必要です。 同じツリーに属するセグメントは、並行して独立してスキャンされ、各セグメントに対して最小重みエッジが選択されるため、このステップが実行されます。 このステップでは、1つのワープで各ツリーの情報を（複数のセグメントについて）削減でき、shfl命令も削減に使用できます。 この手順を完了すると、各ツリーが最小エッジ（存在する場合）によってどのツリーに接続されているかがわかります。 この情報を記録するために、さらに2つの補助配列を導入します。1つは、最小エッジが存在するまでのツリーの数を格納します。2つ目は、元のグラフの頂点の数で、ツリーに入る頂点のルートです。 この手順の結果を以下に示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/5fd/77b/9b0/5fd77b9b0c2d4160822fbb5be11f0949.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     インデックスを操作するには、さらに2つの配列が必要です。これは、元のインデックスを新しいインデックスに変換し、新しいインデックスを使用して元のインデックスを取得するのに役立ちます。 これらのいわゆるインデックス変換テーブルは、アルゴリズムの各反復で更新されます。 初期インデックスによって新しいインデックスを取得するためのテーブルのサイズはN-グラフ内の頂点の数であり、初期インデックスを取得するためのテーブルは各反復で新しい方法で縮小され、アルゴリズムの選択された反復でのツリーの数に等しいサイズを持ちます（アルゴリズムの最初の反復では、このテーブルもサイズN）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  2.サイクルを削除します。 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この手順は、2つのツリー間のループを削除するために必要です。 この状況は、ツリーN1の最小エッジがツリーN2にあり、ツリーN2の最小エッジがツリーN1にある場合に発生します。 上の図では、番号2と4の2つのツリー間にのみサイクルがあります。各反復でツリーが少ないため、サイクルを構成する2つのツリーの最小数を選択します。 この場合、2は2を指し、4は2を指し続けます。これらのチェックを使用して、このようなサイクルを決定し、最小数を優先して排除することができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs matlab"> unsigned <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = blockIdx.x * blockDim.x + threadIdx.x; unsigned local_f = F[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (F[local_f] == <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; local_f) { F[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; . . . . . . . } }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この手順は、各頂点を独立して処理でき、サイクルのない頂点の新しい配列のレコードが交差しないため、並行して実行できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  3.木の結合。 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この手順では、ツリーをより大きなツリーに結合します。  2つのツリー間のループを削除する手順は、基本的にこの手順の前の前処理です。 ツリーをマージするときのループを回避します。 ツリーの結合は、リンクを変更して新しいルートを選択するプロセスです。 たとえば、ツリー0がツリー1を指し、ツリー1がツリー3を指している場合、ツリー0のリンクをツリー1からツリー3に変更できます。このリンクの変更は、リンクを変更しても2つのツリー間のループが発生しない場合に価値があります。 上記の例を考慮すると、サイクルの削除とツリーの結合後、2番のツリーが1つだけ残ります。結合プロセスは次のように表すことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/466/d3a/ea5/466d3aea51f1478cbf8189b22ed3c643.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     グラフの構造とその処理の原理は、プロシージャがループする状況がなく、並行して実行できるようなものです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  4.ピーク（ツリー）の番号を付け直します。 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     マージ手順を実行した後、結果のツリーに番号を付け直して番号が0からPになるようにする必要があります。構築により、新しい番号は条件F [i] == iを満たす配列要素を受け取る必要があります（上記の例では、要素のみがこの条件を満たすインデックス2）。 したがって、アトミック操作を使用すると、1 ...（P + 1）の新しい値で配列全体をマークできます。 次に、新しいインデックスの初期インデックスと初期インデックスの新しいインデックスを取得するための表を完成させます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/9cc/db6/145/9ccdb6145c93496381d5d06b812fd88d.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらのテーブルの操作については、最小エッジを見つける手順で説明しています。 テーブルデータを更新しないと、次の反復を正しく実行できません。 説明されているすべての操作は、GPU上で並行して実行されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <u>短い要約を要約する</u> 。  4つの手順はすべて、並行してグラフィックアクセラレータで実行されます。 作業は1次元配列で行われています。 唯一の難点は、これらのすべての手順に間接的なインデックス付けがあることです。 また、このような配列の処理によるキャッシュミスを減らすために、最初に説明したグラフのさまざまな順列が使用されました。 しかし、残念なことに、すべてのグラフが間接インデックス作成による損失を削減するわけではありません。 後で示すように、このアプローチでは、RMATグラフは非常に高いパフォーマンスを達成しません。 最小エッジを見つけるには、アルゴリズム全体が機能する時間の80％までかかり、残りは残りの20％を占めます。 これは、ループの結合、削除、および番号の付け直しの手順で、長さが絶えず減少する配列（反復から反復へ）で作業が行われるという事実によるものです。 考慮されるグラフでは、約7〜8回の反復を行う必要があります。 これは、最初のステップですでに処理される頂点の数がN / 2よりはるかに少なくなることを意味します。最小エッジを見つけるためのメイン手順では、頂点Aの配列と重みWの配列で作業が行われます（特定の要素が選択されます）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     グラフの保存に加えて、長さNの配列がさらにいくつか使用されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 低い値の配列と高い値の配列。 配列Aのセグメントを操作するために使用されます。 </li><li> 新しいインデックスの元のインデックスを取得する配列テーブル。 </li><li> オリジナルの新しいインデックスを取得する配列テーブル。 </li><li> 頂点番号の配列とそれらに対応する重みの配列。これらは最小エッジ検索手順の2番目のステップで使用されます。 </li><li> 手順の最初のステップで、このツリーまたはそのセグメントが属するツリーの最小エッジを見つけるための補助配列。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 最小エッジ検索手順のハイブリッド実装。 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     上記のアルゴリズムは、最終的に単一のGPUでパフォーマンスが低下することはありません。 この問題の解決策は、CPU上でもこの手順を並列化できるように編成されています。 もちろん、これは共有メモリでのみ行うことができ、このためにOpenMP標準を使用し、PCIeバスを介してCPUとGPUの間でデータを転送しました。 タイムラインでの1回の繰り返しでのプロシージャの実行を想像すると、1つのGPUを使用するときの図は次のようになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/b95/56c/9f0/b9556c9f01b84b8d8eab052a4ac8f110.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最初は、すべてのグラフデータがCPUとGPUの両方に保存されます。  CPUが読み取れるようにするには、ツリーのマージ中に移動したセグメントに関する情報を送信する必要があります。 また、GPUがアルゴリズムの反復を継続するには、計算されたデータを返す必要があります。 ホストとアクセラレータ間で非同期コピーを使用することは論理的です： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/905/79f/34d/90579f34d8e640d59c35f01361d3b303.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      CPUのアルゴリズムはGPUで使用されるアルゴリズムを繰り返し、OpenMPのみがループの並列化に使用されます<a href="http://openmp.org/wp/">[11]</a> 。 予想どおり、CPUはGPUほど速くカウントされず、コピーのオーバーヘッドも干渉します。  CPUがその部分を計算するには、計算データを1：5の比率で分割する必要があります。つまり、CPUに転送されるのは20％〜25％のみで、残りはGPUで計算する必要があります。 残りの手順は、時間がかからず、オーバーヘッドとCPU速度の低下がアルゴリズム時間を増加させるだけなので、あちこちを読むのに有利ではありません。  CPUとGPU間のコピー速度も非常に重要です。 テストされたプラットフォームは、PCIe 3.0をサポートしており、12GB / sに到達できました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これまでのところ、GPUとCPUのRAMの量は大きく異なり、後者の方が有利です。 テストプラットフォームでは、6 GB GDDR5がインストールされましたが、CPUでは48 GBもありました。  GPUのメモリ制限により、大きなグラフを計算できません。 そして、CPUとユニファイドメモリテクノロジー<a href="http://devblogs.nvidia.com/parallelforall/unified-memory-in-cuda-6/">[12]</a>は、CPUメモリからGPUにアクセスすることを可能にします。 グラフに関する情報は最小エッジを見つけるための手順でのみ必要であるため、大きなグラフの場合、最初にすべての補助配列をGPUメモリに配置し、次にグラフ配列の一部（隣接配列A、配列Xおよび重みWの配列）をメモリに配置できますGPU、しかし適合しなかったもの-CPUのメモリ内。 さらに、計算中に、GPUに適合しなかった部分がCPUで処理されるようにデータを分割することができ、GPUはCPUメモリへのアクセスを最小限に使用します（グラフィックアクセラレータからCPUメモリへのアクセスはPCIeバスを介して、 15 GB /秒）。 データがどの割合で分割されているかは事前にわかっているため、GPUまたはCPUでアクセスするメモリを決定するには、配列が分離されるポイントを示す定数を入力するだけで十分で、GPUのアルゴリズムを1回チェックするだけでどこで実行するかを決定できますアピール。 これらの配列のメモリ内の場所は、おおよそ次のように表すことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/be0/be8/42d/be0be842d8ee4470a99b7a7abaff2881.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、記載されている圧縮アルゴリズムを使用しても、GPUに最初は収まらないグラフを処理できますが、PCIeのスループットは非常に限られているため、より低い速度で処理できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 試験結果 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     テストは、192個のcudaコア（合計2688）を備えた14個のSMXと、3.7 GHzの周波数を備えた6個のコア（12番目）のIntel Xeon E5 v1660プロセッサを備えたNVidia GTX Titan GPUで実行されました。 テストが実行されたグラフは上記のとおりです。 いくつかの特徴のみを示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><th> スケール（2 ^ N） </th><th> 頂点の数 </th><th colspan="2"> リブの数（2 * M） </th><th> グラフサイズ、GB </th></tr><tr><td></td><td></td><td>  RMAT </td><td>  SSCA2 </td><td></td></tr><tr><td>  16 </td><td>  65,536 </td><td>  2,097 152 </td><td>  〜2 100 000 </td><td>  〜0.023 </td></tr><tr><td>  21 </td><td>  2,097 152 </td><td>  67 108 864 </td><td>  〜67,200,000 </td><td>  〜0.760 </td></tr><tr><td>  24 </td><td>  16 777 216 </td><td>  536 870 912 </td><td>  〜537百万 </td><td>  〜6.3 </td></tr><tr><td>  25 </td><td>  33554432 </td><td>  1,073,741,824 </td><td>  〜1,075,000,000 </td><td>  〜12.5 </td></tr><tr><td>  26 </td><td>  67108864 </td><td>  2 147 483 648 </td><td>  〜2 150 000 000 </td><td>  〜25.2 </td></tr><tr><td>  27 </td><td>  134 217 728 </td><td>  4,294,967,296 </td><td>  〜4,300,000,000 </td><td>  〜51.2 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スケール16のグラフは非常に小さく（約25 MB）、変換なしでも1つの最新のIntel Xeonプロセッサのキャッシュに簡単に収まることがわかります。 グラフの重みは合計の2/3を占めるため、実際には約8 MBを処理する必要がありますが、これはL2 GPUキャッシュの約5倍にすぎません。 ただし、大きなグラフには十分な量のメモリが必要であり、スケール24のグラフでさえ、圧縮せずにテスト済みGPUのメモリに収まらなくなります。 グラフ表現に基づいて、26番目のスケールは最後のスケールで、エッジの数が符号なし整数に配置されます。これは、さらにスケーリングするためのアルゴリズムの制限です。 この制限は、データ型を拡張することで簡単に回避できます。 これは、単精度（unsigned int）の処理がdouble（unsigned long long）よりも何倍も高速であり、メモリの量がまだ非常に少ないため、これまでのところそれほど関連していないようです。 パフォーマンスは、1秒あたりに処理されるエッジの数で測定されます（1秒あたりの通過エッジ-TEPS）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     コンパイルは、オプション-O3 -arch = sm_35のNVidia CUDA Toolkit 7.0を使用して、オプション-O3のIntel Composer 2015を使用して実行されました。 実装されたアルゴリズムの最大パフォーマンスは、以下のグラフで見ることができます： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/189/b43/f99/189b43f99a5d486a92177a262b3a5960.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     グラフは、すべてのSSCA2最適化を使用して、グラフが良好なパフォーマンスを示していることを示しています。グラフが大きいほど、パフォーマンスが向上しています。 この成長は、すべてのデータがGPUのメモリに配置されるまで維持されます。  25スケールと26スケールでは、Unified Memoryメカニズムが使用されました。これにより、速度は低下しますが、結果を得ることができました（ただし、以下に示すように、CPUのみより高速です）。  12 GBのメモリを搭載し、ECCとIntel Xeon E5 V2 / V3プロセッサを無効にしたTesla k40で計算を実行した場合、スケール25のSSCA2グラフで約3000 MTEPSを達成でき、26スケールのグラフだけでなく、 27.このような実験は、その複雑な構造とアルゴリズムの不十分な適応のために、RMATグラフでは実施されませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> さまざまなアルゴリズムのパフォーマンスの比較 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題は、GraphHPC 2015カンファレンスの<a href="http://contest.dislab.org/problem/mst">コンペティションの</a>枠組みで解決されましたが、著者によると、このコンペティションで1位になったAlexander Daryinによって書かれたプログラムと比較したいと思います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一般的な表には、作成者が提供したテストプラットフォームの結果が含まれているため、説明したプラットフォーム（GTX Titan + Xeon E5 v2）のCPUおよびGPUにグラフィックスを配置するのは適切です。 以下は、2つのグラフの結果です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/b31/661/297/b316612976c847ad850105476c3f60ad.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/c12/626/ebe/c12626ebebd0462aa4878192fb479b37.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     グラフから、この記事で説明したアルゴリズムはSSCA2グラフに対してより最適化されているのに対し、Alexander Daryinによって実装されたアルゴリズムはRMATグラフに対して最適化されていることがわかります。 この場合、どの実装が最良であるかを明確に言うことは不可能です。それぞれに独自の長所と短所があるためです。 また、アルゴリズムを評価する基準は明確ではありません。 大きなグラフの処理について話す場合、アルゴリズムが24〜26スケールのグラフを処理できるという事実は大きなプラスであり、利点です。 任意のサイズのグラフの平均処理速度について話す場合、どの平均値を考慮するかは明確ではありません。 明確なことは1つだけです。1つのアルゴリズムはSSCA2グラフを適切に処理し、2番目はRMATです。 これら2つの実装を組み合わせた場合、平均パフォーマンスは23スケールで約3200 MTEPSになります。  <a href="https://yadi.sk/d/O2QbohDChDKWR">ここで</a>アレクサンダーダリンアルゴリズムのいくつかの最適化の記述のプレゼンテーションを見つけることができ<a href="https://yadi.sk/d/O2QbohDChDKWR">ます</a> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     外国の記事から、次のものを区別することができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1） <a href="http://stanford.edu/~vibhavv/papers/old/Vibhav09Fast.pdf">[13]</a>この記事から、説明したアルゴリズムの実装にいくつかのアイデアが使用されました。 古いNVidia Tesla S1070でテストが行​​われたため、著者によって得られた結果を直接比較することはできません。 著者がGPUで達成したパフォーマンスは18〜36 MTEPSの範囲です。  2009年と2013年に公開。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2） <a href="http%253A%252F%252Fieeexplore.ieee.org%252Fxpls%252Fabs_all.jsp%253Farnumber%253D5678261">[14]</a> GPUでのPrimアルゴリズムの実装。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3） <a href="http://link.springer.com/chapter/10.1007%252F978-3-642-31125-3_6">[15]</a> GPUでのk NN-Boruvkaの実装。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      CPUにはいくつかの並列実装もあります。 しかし、外国の記事では高いパフォーマンスを見つけることができませんでした。 たぶん、読者の一人が私が何かを見逃したかどうかを知ることができるでしょう。 また、ロシアではこのトピックに関する出版物がほとんどないことも注目に値します（ <a href="http://2014.nscf.ru/TesisAll/8_Stendovaya/04_190_ZaycevVE.pdf">Vadim Zaitsevを</a>除く）。これは非常に悲しいことです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 競争について、そして結論ではなく </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私は、過去について述べ、MSTの最良の実装のための競争について言及したいと思います。 これらのメモを読んで、私の個人的な意見を述べる必要はありません。 誰かが非常に異なった考え方をしている可能性があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     すべての参加者についてこの問題を解決するための基礎は、実際には同じBoruvkaアルゴリズムに基づいていました。 他のアルゴリズム（KruskalaおよびPrima）の計算は非常に複雑で、GPUなどの並列アーキテクチャにマッピングが遅いか不十分であるため、タスクは少し簡略化されています。 会議の名前から論理的には、メモリ内で1 GB以上を占めるようなグラフ（22以上のスケールを持つグラフなど）のような大きなグラフを適切に処理するアルゴリズムを記述する必要があるということです。 残念なことに、何らかの理由で著者はこの事実を考慮せず、テストプラットフォームには合計50 MBの2つのCPU（最大17スケール&lt;= 50 MBのグラフ）が含まれていたため、競合全体がキャッシュでうまく機能するアルゴリズムを書くことになりました。 受け入れ可能な結果を​​示したのは参加者の1人だけでした-Vadim Zaitsevは、スケールのグラフ22で2つのCPUでかなり高い平均値を受け取りました。 しかし、会議中に判明したように、この参加者はかなり長い間MSTタスクに従事していました。 他の実装されたアルゴリズムの大きなグラフの処理速度は大きくない可能性が高く、コンテストWebサイトで公開されているそれらの数値（さらに悪いことに）とは大きく異なる可能性があります。 また、グラフ構造が非常に異なるという事実、および算術平均も完全に明確ではないため、生産性の平均値を突然考慮する必要がある理由にも注意を払う価値があります。 処理されたグラフのサイズも考慮されませんでした。 提供されたシステムのもう1つの不快な「機能」（2x Intel Xeon E5-2690およびNVidia Tesla K20xを含む）はPCIe 3.0で動作していません（ただし、GPUでサポートされ、サーバーボードに存在します）。 その結果、PCIe 2.0の速度はほぼ3倍低いため、Xeon E5よりも高速な（わずかではありますが）2つのプロセッサーを使用することはできませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     グラフ処理はアーキテクチャ上の機能のためにGPUで並列化するのが難しいため、GPUでこのような問題を解決するのは簡単ではないことに注意してください。 そしておそらく、これらのコンテストは、グラフィックプロセッサ用の非構造グリッドを使用して、アルゴリズムを記述する分野の専門家の開発に貢献するはずです。 しかし、今年の結果と前回の結果から判断すると、残念ながら、そのようなタスクでのGPUの使用は非常に限られています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> 参照： </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [1] <a href="http://en.wikipedia.org/wiki/Sparse_matrix">en.wikipedia.org/wiki/Sparse_matrix</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [2] <a href="http://www.dislab.org/GraphHPC-2014/rmat-siam04.pdf">www.dislab.org/GraphHPC-2014/rmat-siam04.pdf</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [3] <a href="http://www.dislab.org/GraphHPC-2015/SSCA2-TechReport.pdf">www.dislab.org/GraphHPC-2015/SSCA2-TechReport.pdf</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [4] <a href="http://www.nvidia.ru/object/tesla-supercomputer-workstations-ru.html">www.nvidia.ru/object/tesla-supercomputer-workstations-ru.html</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [5] <a href="http://www.nvidia.ru/object/geforce-gtx-titan-x-ru.html">www.nvidia.ru/object/geforce-gtx-titan-x-ru.html#pdpContent=2</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [6] <a href="http://www.amd.com/ru-ru/products/graphics/workstation/firepro-3d/9100">www.amd.com/ru-ru/products/graphics/workstation/firepro-3d/9100</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [7] <a href="http://en.wikipedia.org/wiki/Bor%25C5%25AFvka">en.wikipedia.org/wiki/Bor%C5%AFvka</a> 's_algorithm 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [8] <a href="http://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf">www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [9] <a href="http://habrahabr.ru/company/epam_systems/blog/247805/">habrahabr.ru/company/epam_systems/blog/247805</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [10] <a href="http://on-demand.gputechconf.com/gtc/2013/presentations/S3174-Kepler-Shuffle-Tips-Tricks.pdf">on-demand.gputechconf.com/gtc/2013/presentations/S3174-Kepler-Shuffle-Tips-Tricks.pdf</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [11] <a href="http://openmp.org/wp/">openmp.org/wp</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [12] <a href="http://devblogs.nvidia.com/parallelforall/unified-memory-in-cuda-6/">devblogs.nvidia.com/parallelforall/unified-memory-in-cuda-6</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [13] <a href="http://stanford.edu/~vibhavv/papers/old/Vibhav09Fast.pdf">stanford.edu/~vibhavv/papers/old/Vibhav09Fast.pdf</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [14] <a href="http%253A%252F%252Fieeexplore.ieee.org%252Fxpls%252Fabs_all.jsp%253Farnumber%253D5678261">ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=5678261&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5678261</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [15] <a href="http://link.springer.com/chapter/10.1007%252F978-3-642-31125-3_6">link.springer.com/chapter/10.1007%2F978-3-642-31125-3_6</a> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J253017/index.html">特大のPostgres</a></li>
<li><a href="../J253025/index.html">磁気テープ-古い馬は溝を損ないません</a></li>
<li><a href="../J253027/index.html">第7回ITジャム「Meet＆Mix」2015年のニュース</a></li>
<li><a href="../J253029/index.html">Git、初心者、および初心者向けGit記事について</a></li>
<li><a href="../J25303/index.html">Powerset：新しい検索？</a></li>
<li><a href="../J253033/index.html">Javascriptインタビューの質問</a></li>
<li><a href="../J253035/index.html">CLRium＃2：ASP.NETおよびDNX（.Net実行環境）-最新のCoreCLRコア上。 ロズリンとエンタープライズでリラックス</a></li>
<li><a href="../J253039/index.html">システム管理者のために行きます。 実用的な例。 パート0</a></li>
<li><a href="../J253041/index.html">WebRTC、P2P、iOSおよびAndroidのビデオ通話をサポートするVoxImplantモバイルSDKの新しいバージョン</a></li>
<li><a href="../J253045/index.html">21世紀のステガノグラフィ。 目標。 実用的なアプリケーション。 関連性</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>