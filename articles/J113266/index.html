<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊ ☎️ 👩🏾‍🤝‍👨🏿 部分文字列検索と関連事項 👨🏿‍🤝‍👨🏽 🐩 🍪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちはコミュニティ！ 最近、Habréで、文字列内の部分文字列のさまざまな検索アルゴリズムに関する優れたレビュー記事が掲載されました。 残念ながら、前述のアルゴリズムの詳細な説明はありませんでした。 私はこのギャップを埋めて、潜在的に思い出すことができるものを少なくともいくつか説明することにしま...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>部分文字列検索と関連事項</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> こんにちはコミュニティ！ 最近、Habréで、文字列内の部分文字列のさまざまな検索アルゴリズムに関する優れたレビュー<a href="http://habrahabr.ru/blogs/algorithm/111449/">記事</a>が<a href="http://habrahabr.ru/blogs/algorithm/111449/">掲載さ</a>れました。 残念ながら、前述のアルゴリズムの詳細な説明はありませんでした。 私はこのギャップを埋めて、潜在的に思い出すことができるものを少なくともいくつか説明することにしました。 研究所からのアルゴリズムのコースをまだ覚えている人は、おそらく自分にとって新しいものを見つけることはないでしょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、「なぜこれが一体なのか」という質問を避けたいと思います。 すべてがすでに書かれています。」 はい、書かれています。 しかし、第一に、使用するツールがその制限をよりよく理解するために下位レベルでどのように機能するかを知ることは有用です。第二に、ボックスから機能するstrstr（）関数が十分でない隣接領域が十分に大きいです。 第三に、運が悪く、モバイルプラットフォーム用のランタイムを開発する必要がある場合があります。それを自分で補足する場合は、購読しているものを知る方が良いでしょう（これが真空中の球状の問題ではないことを確認するには、wcslenを試してください） Android NDKのwcsstr（））。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> しかし、検索することは本当に不可能ですか？ </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     事実は、すべてを「テイクアンドサーチ」として定式化する明白な方法が決して最も効果的ではないことであり、このような低レベルで比較的頻繁に呼び出される機能にとって、これは重要です。 したがって、計画は次のとおりです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 問題の説明：定義と規則をここにリストします。 </li><li>  「額に」の決定：ここでは、それをしない方法と理由を説明します。 </li><li>  Z関数：部分文字列検索の正しい実装の最も単純なバージョン。 </li><li>  Knuth-Morris-Prattアルゴリズム：別の正しい検索オプション。 </li><li> その他の検索タスク：詳細な説明なしで簡単に調べます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 問題の声明 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     問題の標準バージョンは次のようになります：行<b>A</b> （ <i>text</i> ）があります。 サブストリング<b>X</b> （ <i>パターン</i> ）が含まれているかどうかを確認する必要があります。ある場合は、どこから開始するかを確認します。 これは、Cでstrstr（）関数が行うこととまったく同じです。これに加えて、パターンのすべての出現を検索するように依頼することもできます。 明らかに、 <b>Xが</b> <b>A</b>より長くない場合にのみ、タスクは意味をなします<b>。</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     詳細な説明を簡単にするため、一度にいくつかの概念を紹介します。  <i>文字列</i>とは、誰もがおそらく理解している-これは<i>文字列で</i>あり、空の場合もあります。  <i>記号</i> 、または文字は、 <i>アルファベット</i>と呼ばれる特定のセットに属し<i>ます</i> （このアルファベットは、一般的に言えば、常識的にはアルファベットとは無関係かもしれません）。  <i>ストリングの長さ</i> |  <b>A</b> |  -これは明らかにその中の文字数です。  <i>ストリング</i> <b>A [</b> ..i <b>]</b> <i>のプレフィックスは、ストリング</i> <b>A</b>の最初のi文字のストリングです<b>。</b>  <i>ストリング</i> <b>A [</b> j .. <b>]</b> <i>のサフィックスは</i> 、|のストリングです。  <b>A</b> | -j +最後の1文字。  <b>A</b>の部分文字列は<b>A</b> <b>[</b> i..j <b>]</b>として示され、 <b>A [</b> i <b>]</b>は文字列のi番目の文字です。 空の接尾辞や接頭辞などに関する質問 触れないでください-ローカルで対処することは難しくありません。  <i>センチネルの</i>ようなものがまだあります-アルファベットには見られないユニークなシンボルです。  $記号で示され、そのような記号の付いた有効なアルファベットで補完されます（理論的には、実際には、入力行に表示されない記号を見つけるよりも、追加のチェックを適用する方が簡単です）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     計算では、文字列の最初の位置から文字を考慮します。 コードを書くのは伝統的にゼロから数えることで簡単です。 あるものから別のものへの移行は難しくありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 額ソリューション </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     直接検索、またはよく言われる「選択して検索する」は、経験の浅いプログラマーの頭に浮かぶ最初のソリューションです。 本質は簡単です。チェックする文字列<b>A</b>に沿って進み、その中の目的の文字列<b>Xの</b>最初の文字の出現を探します。 見つかったら、これが同じ望ましいエントリであるという仮説を立てます。 次に、テンプレートの後続のすべての文字を順番にチェックして、行<b>Aの</b>対応する文字と一致するかどうかを確認します<b>。</b> それらがすべて一致した場合、これがまさに目の前です。 しかし、文字の1つが一致しない場合、仮説をfalseとして認識する以外に何も残りません。これにより、 <b>X</b>からの最初の文字の出現に続く文字に戻ります<b>。</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     多くの人々はこの時点で間違えています。戻る必要はないと信じていますが、現在の位置から行<b>Aの</b>処理を続けることができます。  <b>A</b> = <i>“ AAAAB”</i>の検索<b>X</b> = <i>“ AAAB”</i>の例で示すのがそれほど簡単ではない理由。 最初の仮説は、4番目の文字<b>A</b> ： <i>"AAAAB"</i>に<i>つながり</i> 、そこでミスマッチが見つかります。 ロールバックしない場合、エントリは存在しますが、見つかりません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     間違った仮説は避けられません。悪い状況下でのこのようなロールバックのため、 <b>Aの</b>各文字を|  <b>X</b> | 回。 つまり、計算の複雑さはアルゴリズムO（| <b>X</b> || <b>A</b> |）の複雑さです。 したがって、段落内のフレーズの検索はドラッグアウトできます... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     公平に言うと、行が小さい場合、そのようなアルゴリズムは、プロセッサの観点から予測可能な動作により、「正しい」アルゴリズムよりも速く動作することに注意する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Z関数 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     文字列を検索する正しい方法のカテゴリの1つは、ある意味で2つの文字列の相関を計算することです。 まず、2行の先頭を比較するタスクは単純で簡単であることに注意してください。矛盾が見つかるか、行のいずれかが終わるまで、対応する文字を比較します。 ストリング<b>Aの</b>すべての接尾部のセットを検討してください。  <b>A</b> | .. <b>]</b> <b>A [</b> |  <b>A</b> | -1 .. <b>]</b> 、... <b>A [</b> 1 .. <b>]</b> 。 行の先頭自体とその接尾辞のそれぞれを比較します。 比較は、接尾辞の最後に達するか、不一致のために一部の記号で途切れることがあります。 一致する部分の長さは、特定の接尾辞の<a href="http://ru.wikipedia.org/wiki/Z-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">Z関数の</a>コンポーネントと呼ばれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     つまり、Z関数は、文字列の最大の共通プレフィックスとそのサフィックスの長さベクトルです。 うわー 誰かを混同したり主張したりする必要がある場合には素晴らしいフレーズですが、それが何であるかを理解するには、例を考えた方が良いでしょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     元の文字列は<i>"ababcaba"</i>です。 各接尾辞を文字列自体と比較すると、Z関数のプレートが得られます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><th> 接尾辞 </th><th> ひも </th><th></th><th>  Z </th></tr><tr><td> アババカバ </td><td> アババカバ </td><td>  -&gt; </td><td>  8 </td></tr><tr><td> ババカバ </td><td> アババカバ </td><td>  -&gt; </td><td>  0 </td></tr><tr><td> アブカバ </td><td> アババカバ </td><td>  -&gt; </td><td>  2 </td></tr><tr><td>  bcaba </td><td> アババカバ </td><td>  -&gt; </td><td>  0 </td></tr><tr><td> カバ </td><td> アババカバ </td><td>  -&gt; </td><td>  0 </td></tr><tr><td> あば </td><td> アババカバ </td><td>  -&gt; </td><td>  3 </td></tr><tr><td>  ba </td><td> アババカバ </td><td>  -&gt; </td><td>  0 </td></tr><tr><td>  a </td><td> アババカバ </td><td>  -&gt; </td><td>  1 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     接尾辞の接頭辞は部分文字列にすぎず、Z関数は先頭と中央で同時に発生する部分文字列の長さです。  Z関数のコンポーネントのすべての値を考慮すると、いくつかの規則性に気付くことができます。 まず、Z関数の値が文字列の長さを超えず、「完全な」接尾辞<b>A [</b> 1 .. <b>]</b>についてのみ一致することは明らかです（したがって、この値は私たちの興味を引くものではありません。推論では省略します）。 第二に、単一のコピーの文字列に単一の文字がある場合、それはそれ自体と一致するだけであるため、文字列を2つの部分に分割し、Z関数の値は短い部分の長さを超えることはできません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらの観察結果の使用は、次のように提案されています。  <i>「ababcabacab」</i>の行で<i>「abca」</i>を検索するとします。 これらの行を取り、それらの間に<i>センチネル</i>を挿入して連結します： <i>"abca $ababcabacab"</i> 。 このような行では、Z関数のベクトルは次のようになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td>  a b c a $ a a b a b c a b with a c a b </td></tr><tr><td>  17 0 0 1 0 2 0 4 0 0 4 0 0 1 0 2 0 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     完全なサフィックスの値を破棄する場合、センチネルの存在により、Z <sub>iが</sub>目的のフラグメントの長さに制限されます（問題の意味では行の半分未満です）。 しかし、この最大値に達すると、部分文字列の出現位置のみで発生します。 この例では、4で目的の行の<u>すべて</u>の発生位置をマークし<u>ます</u> （見つかったセクションは互いにオーバーラップしますが、推論はすべて同じであることに注意してください）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     つまり、Z関数のベクトルをすばやく作成し、それを使用して文字列のすべての出現箇所を検索できれば、その長さを見つけることになります。 しかし、各サフィックスのZ関数を計算する場合にのみ、これは明らかに「正面」のソリューションよりも高速ではありません。 ベクトルの次の要素の値は、前の要素に基づいて見つけることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     何らかの方法で、対応するi-1番目の文字までZ関数の値を計算したとします。  Z <sub>r</sub>をすでに知っている特定の位置r &lt;iを考えます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、この位置からのZ <sub>r</sub>文字は、行の先頭とまったく同じです。 それらは、いわゆるZブロックを形成します。 右端のZブロック、つまり、最も遠いZブロック（最初のブロックはカウントされません）に興味があります。 場合によっては、右端のブロックの長さをゼロにすることができます（空でないブロックがi-1をカバーしない場合、Z <sub>i-1</sub> = 0であってもi-1stが右端になります）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/habraeffect/e4/b6/e4b684fdf01d477d799715fc8a7c4ae2.png" alt="Zブロックレイアウト">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このZブロック内の後続の文字を考慮すると、このサフィックスの一部がすでに行の先頭にあるため、処理されているため、最初から次のサフィックスを比較することは意味がありません。  Zブロックの最後まで文字をすぐにスキップできます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/habraeffect/c9/9b/c99bad7e0f77757718763de8a853f4e7.png" alt="接尾辞スキップ">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/habraeffect/48/96/4896d7662002e343927b7bcf9c77a6a6.png" alt="前の結果">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     つまり、Z <sub>r</sub>ブロックにあるi番目の文字、つまり、位置k = i-r + 1の行の先頭にある対応する文字を考慮すると、 関数Z <sub>k</sub>はすでにわかっています。  Zブロックの最後までの距離Z <sub>r-</sub> （ir）より小さい場合、このシンボルの一致領域全体がr番目のZブロック内にあることをすぐに確認できます。つまり、結果は次のようになります。行の先頭：Z <sub>i</sub> = Z <sub>k</sub>  Z <sub>k</sub> &gt; = Z <sub>r-</sub> （ir）の場合、Z <sub>i</sub>もZ <sub>r-</sub> （ir）以上です。 それがどれだけあるかを知るには、Zブロックに続く文字をチェックする必要があります。 さらに、これらの文字のhが行の先頭の対応する文字と一致する場合、Z <sub>i</sub>はhずつ増加します。Zi = Z <sub>k</sub> + h。 その結果、新しい右端のZブロックがある場合があります（h&gt; 0の場合）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/habraeffect/14/a0/14a0d223bc40ece1d203aa4bcfb20945.png" alt="Zブロックの外側">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、右端のZブロックの右側でシンボルを比較するだけでよく、比較が成功したため、ブロックは右側に「移動」し、失敗したブロックはこの位置の計算が終了したことを報告します。 これにより、文字列の長さに沿って線形時間でZ関数のベクトル全体を構築できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムを適用して部分文字列を検索すると、時間の複雑さO（| <b>A</b> | + | <b>X</b> |）が得られます。これは、最初のバージョンの製品よりもはるかに優れています。 確かに、Z関数のベクトルを保存する必要がありました。これは、O（| <b>A</b> | + | <b>X</b> |）の追加メモリを必要とします。 実際、すべてのオカレンスを検索する必要はないが、1つだけで十分な場合、Zブロックの長さを||より大きくすることはできないため、O（| <b>X</b> |）メモリーを省くことができます。  <b>X</b> |、さらに、最初の発生を検出した後、行の処理を続行できません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後に、Z関数を計算する関数の例。 トリックのないモデルバージョンです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs vbscript">void z_preprocess(vector&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; &amp; Z, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; str) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size_t <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = str.size(); Z.clear(); Z.resize(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>) return; Z[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t curr = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">left</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; curr &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>; ++curr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curr &gt;= <span class="hljs-built_in"><span class="hljs-built_in">right</span></span>) { size_t off = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( curr + off &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &amp;&amp; str[curr + off] == str[off] ) ++off; Z[curr] = off; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> = curr + Z[curr]; <span class="hljs-built_in"><span class="hljs-built_in">left</span></span> = curr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size_t equiv = curr - <span class="hljs-built_in"><span class="hljs-built_in">left</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z[equiv] &lt; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> - curr) Z[curr] = Z[equiv]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { size_t off = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> + off &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &amp;&amp; str[<span class="hljs-built_in"><span class="hljs-built_in">right</span></span> - curr + off] == str[<span class="hljs-built_in"><span class="hljs-built_in">right</span></span> + off] ) ++off; Z[curr] = <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> - curr + off; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> += off; <span class="hljs-built_in"><span class="hljs-built_in">left</span></span> = curr; } } } } 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> <code>void z_preprocess(vector&lt;int&gt; &amp; Z, const string &amp; str) { const size_t len = str.size(); Z.clear(); Z.resize(len); if (0 == len) return; Z[0] = len; for (size_t curr = 1, left = 0, right = 1; curr &lt; len; ++curr) { if (curr &gt;= right) { size_t off = 0; while ( curr + off &lt; len &amp;&amp; str[curr + off] == str[off] ) ++off; Z[curr] = off; right = curr + Z[curr]; left = curr; } else { const size_t equiv = curr - left; if (Z[equiv] &lt; right - curr) Z[curr] = Z[equiv]; else { size_t off = 0; while ( right + off &lt; len &amp;&amp; str[right - curr + off] == str[right + off] ) ++off; Z[curr] = right - curr + off; right += off; left = curr; } } } } 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Knuth-Morris-Prattアルゴリズム（KMP） </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     前の方法の論理的な単純さにもかかわらず、別のアルゴリズムがより一般的であり、ある意味ではZ関数の逆です<a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D0%25BD%25D1%2583%25D1%2582%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D0%25BE%25D1%2580%25D1%2580%25D0%25B8%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D1%2580%25D0%25B0%25D1%2582%25D1%2582%25D0%25B0">-Knut-Morris-Pratt</a> （KMP） <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D0%25BD%25D1%2583%25D1%2582%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D0%25BE%25D1%2580%25D1%2580%25D0%25B8%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D1%2580%25D0%25B0%25D1%2582%25D1%2582%25D0%25B0">アルゴリズム</a> 。  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">接頭辞関数の</a>概念を紹介し<a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">ます</a> 。  i番目の位置の接頭辞関数は、iより短く、長さiの接頭辞の接尾辞と一致する最大行接頭辞の長さです。  Z関数の定義が対戦相手を完全に無効にしなかった場合、このコンボで間違いなくその場所に配置できます:)そして、人間の言語では次のようになります：考えられるすべての行接頭辞を取得し、接頭辞の末尾との最長開始一致を調べます（些細な偶然の一致は考慮しません）私自身と）。  <i>「ababcaba」の</i>例を次に示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><th> プレフィックス </th><th> プレフィックス </th><th>  p </th></tr><tr><td>  a </td><td>  a </td><td>  0 </td></tr><tr><td>  ab </td><td>  ab </td><td>  0 </td></tr><tr><td>  ab <b>a</b> </td><td> 学士 </td><td>  1 </td></tr><tr><td>  ab <b>ab</b> </td><td>  <b>ab</b> ab </td><td>  2 </td></tr><tr><td>  ababc </td><td>  ababc </td><td>  0 </td></tr><tr><td>  ababc <b>a</b> </td><td> ババカ </td><td>  1 </td></tr><tr><td>  ababc <b>ab</b> </td><td> アブキャブ </td><td>  2 </td></tr><tr><td>  ababc <b>aba</b> </td><td>  <b>アバ・</b>バカバ </td><td>  3 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     繰り返しますが、プレフィックス関数の多くのプロパティを観察します。 最初に、値は、定義から直接得られる番号によって上に制限されます-プレフィックスの長さは、プレフィックス関数よりも大きくなければなりません。 第二に、同様に一意の文字は文字列を2つの部分に分割し、プレフィックス関数の最大値を小さい方の部分の長さに制限します-長いものはすべて、他のものと等しくない一意の文字を含むためです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これから、興味のある結論が得られます。 この理論的上限のある要素で達成したと仮定します。 これは、最初の部分が最後の部分と一致し、そのうちの1つが「完全な」半分を表す、そのようなプレフィックスがここで終了したことを意味します。 接頭辞では、半分が完全に前にある必要があることは明らかです。つまり、この仮定では短い半分になるはずですが、長い半分では最大になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、前の部分のように、目的の行とセンチネルを調べている行を連結すると、プレフィックス関数のコンポーネント内の目的の部分文字列の長さのエントリポイントは、エントリが終了する場所に対応します。 たとえば、 <i>「ababcabcacab」</i>の行で<i>「abca」</i>を探します。  <i>「abca $ ababcabcacab」の</i>連結バージョン。 プレフィックス関数は次のようになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td>  a b c a $ a a b a b c a b with a c a b </td></tr><tr><td>  0 0 0 1 0 1 2 1 2 3 4 2 3 4 0 1 2 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     繰り返しますが、部分文字列のすべての出現が一気に見つかりました-それらは4で終わります。 このプレフィックス関数を効率的に計算する方法を理解する必要があります。 アルゴリズムの考え方は、Z関数を構築する考え方とは少し異なります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img alt="KMP" src="https://habrastorage.org/storage/habraeffect/2c/14/2c142d3ba02a29b5c925d855fbce49c4.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プレフィックス関数の最初の値は明らかに0です。i番目の位置までのプレフィックス関数をカウントします。  i + 1番目の文字を検討してください。  i番目の位置の接頭辞関数の値がPiの場合、接頭辞<b>A [</b> .. Pi <b>]</b>は部分文字列<b>A [</b> iP <sub>i</sub> + 1..i <b>]</b>と一致します。 シンボル<b>A [</b> P <sub>i</sub> +1 <b>]</b>が<b>A [</b> i + 1 <b>]</b>と一致する場合、P <sub>i + 1</sub> = P <sub>i</sub> +1と安全に書くことができます。 しかし、そうでない場合、値はそれより小さくても同じでもかまいません。 もちろん、Pi = 0の場合、あまり減少する場所はないため、この場合はPi <sub>+ 1</sub> = 0です。  P <sub>i</sub> &gt; 0と仮定します。 次に、文字列に接頭辞<b>A [</b> ..P <sub>i</sub> <b>]</b>があります。これは、部分文字列<b>A [</b> iP <sub>i</sub> + 1..i <b>]</b>と同等です。 必要なプレフィックス機能は、これらの同等のセクションと処理される文字内で形成されます。つまり、プレフィックスの後の行全体を忘れて、このプレフィックスとi + 1番目の文字だけを残すことができます。状況は同じです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img alt="KMP" src="https://habrastorage.org/storage/habraeffect/f8/86/f88603d37028316f1c8727d4abca1193.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このステップでのタスクは、中間が切り取られた行の問題に縮小されました： <b>A [</b> ..P <sub>i</sub> <b>] A [</b> i + 1 <b>]</b> 、これは同じ方法で再帰的に解決できます（ただし、末尾再帰はまったく再帰ではなく、ループです）。 つまり、 <b>A [</b> P <sub>P <sub>i</sub></sub> +1 <b>]</b>が<b>A [</b> i + 1 <b>]</b>に一致する場合、P <sub>i + 1</sub> = P <sub>P <sub>i</sub></sub> +1になります。 一致するか0になるまで、この手順を繰り返します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img alt="KMP" src="https://habrastorage.org/storage/habraeffect/97/25/9725ee29bae85d1861f0c1a339d5273a.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらの操作を繰り返すと警告が表示されます。ネストされた2つのサイクルが発生しているようです。 しかし、これはそうではありません。 実際、長さkのネストされたループは、i + 1番目の位置のプレフィックス関数を少なくともk-1削減し、プレフィックス関数をそのような値に増やすには、少なくともk-1倍以上成功する必要がありますk-1文字を処理して文字を一致させます。 つまり、サイクルの長さはそのようなサイクルの実行間隔に対応するため、アルゴリズムの複雑さは処理された文字列の長さに沿って線形になります。 ここでの状況は、メモリの場合とZ関数の場合と同じです-線の長さに沿って線形ですが、保存する方法があります。 さらに、文字が順番に処理されるという便利な事実があります。つまり、最初の出現をすでに受け取っている場合、行全体を処理する必要はありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さて、たとえば、コードの一部： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_prefix_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp; prefix_func, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> str_length = str.size(); prefix_func.clear(); prefix_func.resize(str_length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == str_length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; prefix_func[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> current = <span class="hljs-number"><span class="hljs-number">1</span></span>; current &lt; str_length; ++current) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> matched_prefix = current - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> candidate = prefix_func[matched_prefix]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (candidate != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[current] != str[candidate]) { matched_prefix = prefix_func[matched_prefix] - <span class="hljs-number"><span class="hljs-number">1</span></span>; candidate = prefix_func[matched_prefix]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate == <span class="hljs-number"><span class="hljs-number">0</span></span>) prefix_func[current] = str[current] == str[<span class="hljs-number"><span class="hljs-number">0</span></span>] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> prefix_func[current] = candidate + <span class="hljs-number"><span class="hljs-number">1</span></span>; } } 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> <code>void calc_prefix_function(vector&lt;int&gt; &amp; prefix_func, const string &amp; str) { const size_t str_length = str.size(); prefix_func.clear(); prefix_func.resize(str_length); if (0 == str_length) return; prefix_func[0] = 0; for (size_t current = 1; current &lt; str_length; ++current) { size_t matched_prefix = current - 1; size_t candidate = prefix_func[matched_prefix]; while (candidate != 0 &amp;&amp; str[current] != str[candidate]) { matched_prefix = prefix_func[matched_prefix] - 1; candidate = prefix_func[matched_prefix]; } if (candidate == 0) prefix_func[current] = str[current] == str[0] ? 1 : 0; else prefix_func[current] = candidate + 1; } } 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズムがより複雑であるという事実にもかかわらず、その実装はZ関数よりもさらに単純です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> その他の検索タスク </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     その後、文字列検索タスクはこれに限定されず、他のタスクおよび他のソリューションがあるため、興味がない場合はさらに読むことはできないという手紙がたくさんあります。 この情報は、単に慣れるためのものであり、必要に応じて、少なくとも「すべてが私たちの前に盗まれた」ことに注意し、車輪を再発明することはありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     上記のアルゴリズムは線形実行時間を保証しますが<a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25BE%25D0%25B9%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D1%2583%25D1%2580%25D0%25B0">、ボイヤー・ムーアアルゴリズム</a>は「デフォルト<a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25BE%25D0%25B9%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D1%2583%25D1%2580%25D0%25B0">アルゴリズム</a> 」というタイトルを受け取りました。 平均すると、線形時間も得られますが、この線形関数のより良い定数もありますが、これは平均です。  「悪い」データがありますが、そのデータは単純な「正面」の比較よりも優れています（まあ、qsortと同じように）。 それは非常に紛らわしいので、考慮しません-とにかく、もちろん。 自然言語のテキスト処理に焦点を当て、その最適化において単語の統計的特性に依存する多くのエキゾチックなアルゴリズムがあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さて、O（| <b>X</b> | + | <b>A</b> |）の何らかの方法で文字列内の部分文字列を検索するアルゴリズムがあります。 ここで、ゲストブックエンジンを作成しているとします。 禁止されているわいせつな単語のリストがあります（これは役に立たないことは明らかですが、タスクは単なる例です）。 メッセージをフィルタリングします。 メッセージ内の禁止されている各単語を検索し、... O（| <b>X <sub>1</sub></b> | + | <b>X <sub>2</sub></b> | + ... + | <b>X <sub>n</sub></b> | + n | <b>A</b> |）が必要です。 どういうわけか、特に「偉大で力強い」の「強大な表現」の辞書が非常に「強大」である場合。 この場合、検索文字列の辞書を前処理して、検索がO（| <b>X <sub>1</sub></b> | + | <b>X <sub>2</sub></b> | + ... + | <b>X <sub>n</sub></b> | + | <b>A</b> |）のみを占めるようにする方法があります。メッセージが長い場合。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このような前処理は、辞書からトライを構築することになります。ツリーはダミーのルートから始まり、ノードは辞書の単語の文字に対応し、ツリーノードの深さは単語の文字の数に対応します。 辞書から単語が終わるノードはターミナルと呼ばれ、何らかの方法でマークされます（図の赤）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img alt="トライ" src="https://habrastorage.org/storage/habraeffect/ed/54/ed54a3dfc08d2721c69533cb9c653873.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     結果のツリーは、KMPアルゴリズムのプレフィックス関数に類似しています。 これを使用すると、辞書句内のすべての単語の出現箇所をすべて検索できます。 ツリーを調べて、ツリーノードの形で次の文字の存在を確認し、同時に終端の頂点をマークする必要があります-これらは単語の出現です。 ツリーに対応するノードがない場合、ILCの場合と同様に、特別なリンクを使用してツリーの上位でロールバックが発生します。 このアルゴリズムは<a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2590%25D1%2585%25D0%25BE-%25D0%259A%25D0%25BE%25D1%2580%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BA">、Aho-Korasikアルゴリズム</a>と呼ばれ<a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2590%25D1%2585%25D0%25BE-%25D0%259A%25D0%25BE%25D1%2580%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BA">ます</a> 。 同じスキームを使用して、入力時に検索し、電子辞書の次の文字を予測できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この例では、ボロンの作成は簡単です。ボロンに順番に単語を追加するだけです（「キックバック」用の追加リンクのみのニュアンス）。 このツリーのメモリ使用量を減らすことを目的とした最適化がいくつかあります（いわゆるボロン圧縮-分岐せずにセクションをスキップする）。 実際には、これらの最適化はほぼ必須です。 このアルゴリズムの欠点は、アルファベット順の依存性です。ノードと占有メモリの処理時間は、潜在的な子の数に依存し、これはアルファベットのサイズに等しくなります。 大きなアルファベットの場合、これは深刻な問題です（Unicode文字のセットを想像できますか？）。 このすべてについて、この<a href="http://habrahabr.ru/blogs/algorithm/111874/">habratopikaで、</a>またはGoogleインデックスを使用して詳細を読むことができます-この問題に関する多くの情報があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次に、別のタスクを見てみましょう。 前のもので、後で来るデータで何を見つける必要があるかを事前に知っていた場合、ここではまったく逆です：事前に彼らが検索する行が与えられましたが、検索するものは不明ですが、彼らは多くを検索します 典型的な例は検索エンジンです。 単語が検索されるドキュメントは事前に知られていますが、そこで検索される単語は外出先に散らばっています。 ここでも、O（| <b>X <sub>1</sub></b> | + | <b>X <sub>2</sub></b> | + ... + | <b>X <sub>n</sub></b> | + n | <b>A</b> |）の代わりにO（| <b>X <sub>1</sub></b> | + | <b>X <sub>2</sub></b> | + ... + | <b>X <sub>n</sub></b> | + | <b>A</b> |）？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     既存の文字列のすべての可能な接尾辞が存在するホウ素を構築することが提案されています。 次に、テンプレートの検索は、目的のテンプレートに対応するツリー内のパスの存在をチェックすることになります。 すべての接尾辞を徹底的に検索してこのようなホウ素を作成する場合、この手順にはO（| <b>A</b> | <sup>2</sup> ）時間と大量のメモリが必要になります。 しかし、幸いなことに、圧縮ツリーでそのようなツリーをすぐに構築できるアルゴリズムがあります- <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">サフィックスツリー</a> 、そしてO（| <b>A</b> |）でそれを行います。 最近Habréでこれ<a href="http://habrahabr.ru/blogs/algorithm/111675/">に関する記事</a>がありまし<a href="http://habrahabr.ru/blogs/algorithm/111675/">た</a>ので、興味のある人はそこで<a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">Ukkonenアルゴリズム</a>について読むことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     通常、接尾辞ツリーには悪い点が2つあります。それはツリーであるということと、ツリーのノードがアルファベット順に依存しているということです。  <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D0%25B2">サフィックス配列は</a>これらの欠点を免れ<a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D0%25B2">てい</a>ます。 接尾辞配列の本質は、文字列のすべての接尾辞が並べ替えられている場合、部分文字列の検索は、目的のパターンの最初の文字で隣接する接尾辞のグループを検索し、後続のものの範囲をさらに絞り込むことになります。 同時に、サフィックス自体をソートされた形式で保存する必要はありません;ソースデータでサフィックスが始まる位置を保存するだけで十分です。 確かに、この構造の時間依存性はわずかに悪くなります。1回の検索では、考えてすべてを慎重に行うとO（| <b>X</b> | + log | <b>A</b> |）かかり、気にしない場合はO（| <b>X</b> | log | <b>A</b> |）です。 比較のために、固定アルファベットO（| <b>X</b> |）のツリーで。 ただし、これがツリーではなく配列であるという事実は、メモリキャッシングの状況を改善し、プロセッサ遷移予測のタスクを容易にします。 サフィックス配列は、Kärkkäinen-Sandersアルゴリズムを使用して線形時間で構築されます（すみませんが、ロシア語でどのように聞こえるかはほとんどわかりません）。 今日、これは最も人気のある行のインデックス付け方法の1つです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここでは、近似文字列検索と類似度の分析の質問には触れません。これは、この記事に詰め込むには広すぎる領域です。 私はただ人々がそこでパンを何もせずに食べず、多くの異なるアプローチを考え出したので、あなたが同様の問題に遭遇したら、見つけて読んでください。 おそらく、この問題はすでに解決されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     読んでくれた人に感謝します！ そして、これを読んだ人に、どうもありがとう！ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>UPD：</b>ホウ素に関する重要な記事への<a href="http://habrahabr.ru/blogs/algorithm/111874/">リンク</a>を追加しました（レイであり、プレフィックスツリーであり、ロードされたツリーであり、トライです）。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J113255/index.html">NDIS NET_BUFFERアーキテクチャ</a></li>
<li><a href="../J113256/index.html">ロシア語のLiveJournalでマスコミュニケーションが開始されてから10年。 また、ブロゴスフィアの親クレムリン監視の開始の可能性。</a></li>
<li><a href="../J113257/index.html">sjFilemanagerは無料のAJAXファイルマネージャーです。 ホイールまたはノウハウ？</a></li>
<li><a href="../J113263/index.html">CruiseControl.NETにコードカバレッジコレクションを埋め込む</a></li>
<li><a href="../J113265/index.html">電話からコンピューターへのライブブロードキャストを視聴するというアイデア（YouTubeLiveの例）</a></li>
<li><a href="../J113267/index.html">外国映画は課税される場合があります</a></li>
<li><a href="../J113268/index.html">言語が必要ですか？</a></li>
<li><a href="../J113269/index.html">古いゴミ、または彼が誤ってミニBPを組み立てた物語</a></li>
<li><a href="../J113270/index.html">Recens CP-自作のベータ版サーバーコントロールパネル</a></li>
<li><a href="../J113271/index.html">シンプルなWoWボットの作成：続き</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>