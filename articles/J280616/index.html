<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆓 🧑🏻 💅🏽 NetApp FASメモリの仕組み：NVRAM、キャッシュ、およびテトリス 〰️ 👍🏽 📄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、NetApp FASストレージの内部ストレージデバイスと、それがテトリスを組み立てる方法を検討したいと思います。 
  
 
  
  
  
  
  
  システムメモリ  
  
 NetApp FASコントローラのストレージメモリは、読み取り、書き込み、およびバッテリ駆動のキャ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>NetApp FASメモリの仕組み：NVRAM、キャッシュ、およびテトリス</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/280616/"> この記事では、NetApp FASストレージの内部ストレージデバイスと、それがテトリスを組み立てる方法を検討したいと思います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/e7b/bae/930/e7bbae9305fc4e5db5b05a5cd5aaf13e.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> システムメモリ </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      NetApp FASコントローラのストレージメモリは、読み取り、書き込み、およびバッテリ駆動のキャッシュに使用されるメモリモジュールで構成されているため、「NV」プレフィックス-不揮発性MEMory / RAM / LOGです。  RAMは、NVRAM、MBUFバッファー（またはシステムキャッシュ）の機能部分に分割されます。これらはより詳細です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/6ec/5d4/38a/6ec5d438a6ca472388c199391354b620.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      *ディスクへのデータ<a href="https://habr.com/ru/post/280616/">ダンプ</a>は、 <a href="https://habr.com/ru/post/280616/">NVRAM</a>自体ではなく、 <a href="https://habr.com/ru/post/280616/">NVRAMの満杯のイベントによってMBUFから</a>発生し<a href="https://habr.com/ru/post/280616/">ます</a> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  NVRAMとNVLOG </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      NVRAMでは、データベース内のLOGレコードと同様に、NVLOGレコードはホストから送信されたときに元の形式で収集されます。 ホストからのデータがNVRAMに入るとすぐに、ホストはレコード確認を受け取ります。  <u>MBUF</u>からディスクへのデータの<u>フラッシュ</u>を生成するCPイベントが発生し、その後確認が行われると、NVRAMはクリアされます。 したがって、正常に機能しているストレージシステムでは、NVRAMの内容は読み取られず、書き込まれるだけであり、そのスペースがなくなるとCPが発生し、NVRAMがクリアされます。  NVRAMの読み取りは、障害が発生した後にのみ発生します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  HAのNVRAM </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2つのNetApp FASコントローラーの高可用性（HA）ペアでは、NVRAMは常にミラーリングされ、各コントローラーにはその近隣のコピーがあります。 これにより、1つのコントローラーに障害が発生した場合、すべてのホストを生き残ったコントローラーに切り替えてさらにサービスを提供できます。  CPイベントの発生後（確認ディスクへのデータのフラッシュ）、NVRAMはクリアされます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     より正確には、これら2つの部分はそれぞれ2つの部分に分割され、HAペアの合計4つ（つまり2つのローカル）です。 これは、ローカルNVRAMの半分を埋めた後、データリセットによって新しい着信コマンドの速度が低下しないようにするためです。 つまり、データがローカルNVRAMの一部からリセットされている間、新しいデータはすでにローカルNVRAMの後半に到着しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/4b8/e15/9e3/4b8e159e34fe468aa19d9af6d7a0370f.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  MCCのNVRAM </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habrahabr.ru/post/279989/">MCCの</a> Split-Brainからデータを保護するために、書き込まれたデータは、1つのローカルコントローラー、そのネイバー、および1つのリモートネイバーのNVRAMに入った後にのみホストに確認されます（MCCが4つのノードで構成される場合） ローカルコントローラー間の同期はHAインターコネクトを介して実行され（これは2つの異なるシャーシのデュアルコントローラーシステムの外部接続です）、リモートノードへの同期はFC-IVアダプターを介して実行されます（これも外部接続です）。 このスキームにより、2番目のHAペアコントローラーが生き残った場合にサイト内で切り替えることができ、すべてのローカルストレージノードが故障した場合に2番目のサイトに切り替えることができます。  2番目のサイトへの切り替えは数秒で発生します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/488/35c/803/48835c803f2342b8aa9b1243e5178b10.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  NVRAMとパススルー </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      NVRAMは、一方ではNetAppで武装されているだけでなく、NetAppがログ（ジャーナリングファイルシステムのハードウェア実装）を保存するために使用する技術であり、他のほとんどのストレージメーカーは「ブロックレベル」でNVRAMを使用することに注意することが重要ですNVRAMにデータをキャッシュするための（ディスクドライバーレベルまたはディスクキャッシュ）-これは大きな違いです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      NVLOGの存在により、NetApp FASはHAペアで変換せず、パススルーモード（キャッシュなしでディスクに直接記録）の1つが死んだ場合、1つのコントローラーのみが生き残ります。 これについて少し掘り下げて、書き込みキャッシュが必要な理由から始めましょう。 キャッシュは、ホストのなりすましと記録の高速化に必要であり、データが実際にディスクに到達する前にデータの記録を確認します。 キャッシュにバッテリーがある場合、コントローラーをパススルーモードに切り替えるのはなぜですか？ストレージのすべてのAブランドのHAペアにはキャッシュミラーリングがありますか？ 答えは一見して簡単ではありません。まず、HAメカニズムは、HAペアの2つのコントローラーの1つが失敗し、クライアントがパートナーに透過的に切り替わるときに、データが破損せず、ディスクにフラッシュされることを保証します第二に、この場合の最も重要なことは、データがストレージシステム自体のデータ構造のレベルで破損しないようにするためです。これはさらに詳しく説明する価値があります。 メモリ内のRAIDのチェックサムを再計算することは、ディスクサブシステムを高速化するため、長い間目新しいものではありません。すべてのAブランドがこのトリックをマスターしているわけではありませんが、データ破損の可能性<u>を</u>残して<u>いるのはRAIDレベルで既に処理された形式で</u>のキャッシュからのデータのダンプ<i>2つのコントローラを</i>再起動した後に追跡して復元できません。 したがって、最初のコントローラー、次に2番目のコントローラーに障害が発生した場合、処理の結果として最初に受信したデータの整合性を追跡できないことがわかります。つまり、データが破損している可能性があります。他の状況では、損傷を追跡および修復することが可能ですが、ストレージのデータ構造のチェックを実行する必要があります 書き込みキャッシュは礎石であり、大きな問題になる可能性があるため、1つのコントローラーがONペアで故障した場合、ほとんどのストレージシステムはディスクへの直接書き込みを行うPassThroughモードに移行し、書き込みキャッシュをオフにしてファイル構造の損傷の可能性を排除する必要があります 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一方、これらのストレージシステムのほとんどでは、管理者が生き残ったコントローラーを手動でレコードキャッシュモードに手動で転送できますが、これは安全ではありません。2番目のコントローラーに障害が発生すると、ストレージシステムのストレージ構造のレベルのデータが破損し、復元する必要があるためです。時にはこれは悲劇的な結果につながる可能性があります。  FASシステムはデータをログの形式で保存し、 <i>WAFLまたはRAIDの後の</i>処理された形式ではなく、単一のトランザクションでCPシステムのスナップショットをローリングする形で既に処理されたデータがリセットされるため、データ破損の可能性を完全に回避できます。 したがって、多くの<u>最新の</u>競合ストレージシステムでは、HAペアの一方のコントローラーが停止すると、死亡したコントローラーからの負荷が2番目に低下するだけでなく、キャッシュを切断してレコードを最適化するため、このような状況での作業速度が大幅に低下します。 これは、書き込まれるデータが損傷のない形でディスクに正確に書き込まれるように行われ、最も重要なことは、ストレージシステムのファイル構造がそのまま残るようにすることです。 この問題をまったく気にせず、正直にこの「ニュアンス」についてドキュメントに書いている人もいます。 また、「松葉杖」の助けを借りてこの問題を回避しようとしており、2ノードではなく4ノードのシステムを一度に購入しようとしています。 したがって、たとえば、HP 3PARシステムは、4ノードシステムの1つのコントローラーに障害が発生すると、残りの3つのコントローラーが通常の記録モードで動作しますが、ノードの50％に障害が発生すると、システムがモードになりますパススルー。 ストレージシステム全体が死ぬ方が、このようなひどいブレーキを使用するよりも良い場合には、時々面白い状況があります。 これは、FASシステムとは対照的です。FASシステムは、シングルモード構成であっても、このような問題からアーキテクチャ的に保護されているため、キャッシュを無効にすることはありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <a href="https://habr.com/ru/post/280616/">メモリバッファ：書き込み</a> </h2><a name="MBUF"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     実際、書き込みは常にMBUF（Write Memory Buffer）で行われます。 そして、そこから、ダイレクトメモリアクセス（DMA）要求を使用して、NVRAMはこのデータのコピーを自分自身に作成し、CPUリソースを節約します。 その後、WAFLモジュールは、MBUFからのデータが書き込まれるブロックの範囲を選択します。このプロセスは、書き込み割り当てと呼ばれます。  WAFLモジュールは単純にブロックを選択するだけでなく、最初にテトリスを収集し（そうそう、 <a href="https://cloud.mail.ru/public/DCR2/R6LmAunRx">テトリス！それについて聞いたことがありますか？</a>次に28分を見てください）、空のブロックを選択して、テトリス全体をディスクに書き込めるようにします作品。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/8c2/c56/d4a/8c2c56d4a0bd427f9b2bfbfff0323d4b.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      WAFLは、データのその他の書き込み最適化も実行します。  NVRAMからの書き込み確認がWAFLモジュールに到着すると、MBUFからのデータは、割り当てられたブロックに従って、RAIDモジュールによって処理されます。RAIDモジュールでは、パリティディスクのチェックサムが計算され、チェックサムが計算され、各ブロックに保存されます（ブロック/ゾーンチェックサム）。  RAIDモジュールに転送されたMBUFからのデータは「アンパック」されることに注意することも重要です。たとえば、一部のコマンドは情報ブロックの繰り返しパターンの記録やブロックの移動要求を要求する場合があります。このようなコマンド自体はNVRAMのスペースをあまり消費しませんが、多くの新しいデータを生成します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 書き込み割り当て </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これはWAFLの一部であり、特に新しいストレージメディアと並列化（2011年に出荷された新しいアーキテクチャ）の点で、元のデバイスアーキテクチャから大幅に変更されており、近い将来登場する可能性のある新しいストレージテクノロジの使用のための踏み台を準備しています。 デバイスのインテリジェンスのおかげで、書き込み割り当てにより、さまざまな方法でディスクサブシステムのさまざまな場所にデータをきめ細かく書き込むことができます。 記録された情報の個別のストリームは個別に処理され、データの書き込み、読み取り、ブロックのサイズ、およびレコード（およびその他）の性質に応じて処理できます。 記録されたデータの性質に基づいて、WAFLは書き込みの価値があるメディアの種類と方法を決定できます。 この例としては、フラッシュドライブがあります。この場合、細分化して、セルが消去されるブロック境界に沿って（ブロックサイズを消去して）書き込むのが理にかなっています。 さらに、メタ情報は通常、データ自体に比べてはるかに少ないスペースを占有しますが、有用なデータを持つ大きなブロックとは別に配置でき、場合によっては実験的に確立された大きな利点があります。 実際、書き込み割り当て内部デバイスの説明は、別の非常に大きなトピックです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <a href="https://habr.com/ru/post/280616/">RAID</a> </h2><a name="RAID"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      WAFLモジュールからデータはRAIDモジュールに転送され、RAIDモジュール<a href="http://www.netapp.com/us/media/tr-3001.pdf">はそれらを単一のトランザクション</a>で処理し<a href="http://www.netapp.com/us/media/tr-3001.pdf">て書き込み</a> 、パリティディスクを含むディスクに<a href="http://www.netapp.com/us/media/tr-3001.pdf">ストライピング</a>します。 また、データは常にストライプに書き込まれ、常に新しい場所に書き込まれるため、パリティディスクのデータを再計算する必要はなく、RAIDモジュールによる記録のために事前に準備されています。 このため<i>、実際</i>に<i>はFASシステムでは、ディスクドライブの負荷は常に</i>他のディスクよりも<i>はるかに少なく</i> 、これはRAID 4/6の通常の実装とは対照的です。 また、チェック量の計算は、記録されたデータのストリップ全体に対して即座に実行され、データを上書きすることはなく（記録は新しい場所で発生します）、メタ情報のみが変更されます（データを持つ新しいブロックへのリンク）。 これにより、ディスクの1つを書き換える場合、システムメモリがより合理的に使用されるため、毎回残りのディスクから情報をメモリに読み込んでチェックサムを再カウントする必要はありません。  <a href="https://www.netapp.com/us/media/tr-3298.pdf">RAID-DPの詳細をご覧ください</a> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href="http://www.netapp.com/us/media/tr-3001.pdf"><img src="https://habrastorage.org/files/de6/f0f/a23/de6f0fa23b6a4ddcada803d73a66b118.png"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> テトリスはIO削減を実行します </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Tetrisは、CP（CPタイムフレーム）間のデータを1つのホストから一連のブロックチェーンに収集し、小さなブロックを大きな順次レコードに変換する（IO削減）書き込みおよび読み取り最適化メカニズムです。 一方、これにより、複雑なロジックなしで先読みデータを有効にできます。 したがって、例えば、違いはありません-5KB、8KB、13KB、または16KBなどを読み取ります。 このロジックは先読みに使用されます。 先読みは、将来要求される可能性のあるデータのキャッシュ形式であり、その後に要求されたデータが続きます。 そして、質問になった場合、どの特定の「余分な」ブロックをキャッシュに転送するためにプロアクティブに読み取る必要があるか、テトリスで、あなたは自動的にこの質問に対する答えを得ます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/525/3fc/577/5253fc57758c4d239e54dad8b017b02f.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 読み取りキャッシュ </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     システムキャッシュ（MBUF）は、書き込み操作と読み取り操作の両方に使用されます。 すべての読み取り操作は例外なくキャッシュに分類され、読み取りデータのみがキャッシュから読み取られます。 ストレージシステムのCPUがシステムキャッシュでデータを見つけることができない場合、ディスクにアクセスします。最初に行うことは、読み取りキャッシュに入れてからホストに渡すことです。 さらに、このデータは単に削除するか（これは読み取りキャッシュであり、すべてがディスク上にあります）、または存在する場合は下位レベル（キャッシュレベルII）に移動できます：FlashPool（SSDディスク、読み取り/書き込みキャッシュ）またはFlashCache（ PCIeフラッシュカード、読み取りキャッシュのみ）。 まず、システムキャッシュ（第1レベルと第2レベルの両方）は非常に細かく混み合っています。  4 KBの情報ブロックが置き換えられる場合があります。 第二に、システムとレベルIIのキャッシュは、重複排除に対応しています。 そのようなブロックが複製または複製された場合、それは再びコピーされず、メモリ空間を占有しません。 これ<a href="https://habrahabr.ru/post/280105/">により、キャッシュヒットが増加し、パフォーマンスが</a>大幅に<a href="https://habrahabr.ru/post/280105/">向上します。</a>  <a href="https://habrahabr.ru/post/280105/">これは、</a>たとえばVDI環境<a href="https://habrahabr.ru/post/280105/">で、ストレージシステムにあるデータセットを何度も複製または複製できる</a>場合に発生します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 一貫性ポイント </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     多くの最新のファイルシステムと同様に、WAFLはジャーナリングファイルシステムです。 ジャーナリングファイルシステムと同様に、ログエントリのあるジャーナルを使用して、ストレージレベルでの整合性と整合性を確保します。 ジャーナルファイルシステムの他のすべての実装は、破損した場合に一貫した状態にロールバックし（検証とリカバリを実行する必要がある）、リカバリを試みることができるように設計されていますが、WAFLは、コントローラの突然の障害の場合に損傷自体が防止されるように設計されています。 これは、まずコンシステンシーポイントの記録のアトミックな性質のために、次に、記録操作中にシステムスナップショットを使用するために達成されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      NetAppのスナップショットテクノロジーは非常に成功していることが実証されているため、他の多くの機能の基礎としてONTAPのあらゆる場所で使用されています。  CPには<a href="https://habrahabr.ru/post/244923/">、WAFL</a>およびRAID <a href="https://habrahabr.ru/post/244923/">によって</a>既に<a href="https://habrahabr.ru/post/244923/">処理さ</a>れたデータが含まれていることを思い出させてください。  CPはスナップショットでもあり、システムメモリから内容をダンプする前に（WAFLおよびRAIDモジュールによる処理後）、ストレージシステムはユニットからシステムスナップショットを削除し、ディスクに新しいデータを追加します。その後、ストレージはデータが正常に書き込まれたことを示します。次に、NVRAMのNVLOGエントリをクリアします。 新しいデータが（常に新しい場所に）ディスクにフラッシュされる前に、システムスナップショットが作成されます。その後、データは1つのトランザクションで書き込まれるか、（事故の場合）以前に作成されたスナップショットが（ユニットレベルで）ファイルシステムの最新の作業バージョンとして使用されます。トランザクションの途中でストレージシステムが突然再起動した場合。 事故が発生し、両方のコントローラーが再起動するか電源が失われた場合、NVRAMのデータはすべての情報を復元し、コントローラーが再びオンになるとすぐにデータをドライブにリセットします。  1つのコントローラーのみがシャットダウンまたは再起動した場合、NVLOGのコピーからNVRAMへの2番目のコントローラーはすぐにデータを復元して書き留め、アプリケーションに対して透過的に行われます。 データがディスクに正常にフラッシュされると、古いルートiノード（スナップショット）に基づく最後のCPブロックは、記録された古いデータと新しいデータへのリンクを含む新しいブロックを作成します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  CP生成イベント </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      CPは、次のいずれかの条件で自動的に生成されるイベントです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  10秒が経過しました </li><li>  NVRAMの半分がいっぱいです </li><li> ローカルMBUFがいっぱいです（最高水準点）。 これは、ホストからの1つまたは複数のコマンドがCPに対して大量のデータを生成した、たとえば、一定量の情報の繰り返しパターンを記録したという事実が原因です。 </li><li> コントローラー停止コマンド（停止） </li><li> その他。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ところで、CPのリセット状態は、多くの場合、ストレージシステムの動作に問題があることを間接的に示すことができ<a href="http://blog.aboutnetapp.ru/archives/199">ます。</a>たとえば、 <a href="http://blog.aboutnetapp.ru/archives/199">十分なスピンドルがない場合や破損している場合です</a> 。 作業の詳細については、 <a href="https://kb.netapp.com/support/s/article/faq-consistency-point%3Flanguage%3Den_US">ナレッジベースFAQ：一貫性ポイントの</a>記事をご覧<a href="https://kb.netapp.com/support/s/article/faq-consistency-point%3Flanguage%3Den_US">ください</a> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  NVRAMサイズが必ずしも重要ではないのはなぜですか？ </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     前述したように、NVRAMはFASシステムで書き込みキャッシュではなくログレコードのストレージとして使用されるため、HDDおよびハイブリッドFASシステムのサイズは競合他社ほど大きくありません。 単にNVRAMを増やす必要はありません。 各システムは、サポートされている最大数のスピンドルを処理するのに十分なリソースを持つように設計されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> バッテリーとフラッシュ </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     すでに述べたように、バッテリーはシステムメモリに電力を供給します。 ただし、コントローラにインストールされているシステムフラッシュドライブも起動します。 電源障害が発生した場合、その後、メモリの内容はシステムのフラッシュドライブに排出されるため、ストレージシステムは非常に長い時間オフのままになります。 ストレージを開始すると、コンテンツのメモリへの復元が自動的に行われます。 バッテリーは最大72時間持続するため、この時間中に電力が回復すると、コンテンツはキャッシュに残り、システムのフラッシュドライブからの回復は行われません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <a href="https://habr.com/ru/post/280616/">SSDおよびWAFL</a> </h2><a name="SSD_and_WAFL"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     前述のように、WAFLは常に新しい場所に書き込みます。これは多くの理由でアーキテクチャ的に行われ、その1つはスナップショットの形式でのMBUFコンテンツのダンプです。 実際、そうでない場合、ブロックの物理的な書き換えの場合-不完全なキャッシュリセットトランザクションを使用した新しいブロック、古いブロックの上書き、これはデータ破損につながる可能性があります。  「新しい場所への書き込み」アプローチは、SSDドライブのすべてのセルを均一に廃棄する必要があるため、回転ディスクやスナップショットメカニズムだけでなく、フラッシュテクノロジーでも非常に成功していることがわかりました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 結論 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      NetApp FAS RAMは、読み取りおよび書き込み操作を高速化するだけでなく、そのような操作に対して高い信頼性、速度、最適化を提供するように設計されています。 豊富な機能、複数の保護レベル、およびシステムキャッシュの速度により、Aクラスのシステムは生産性の高い負荷とミッションクリティカルなタスクを定性的に区別します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     英訳 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ONTAPでのメモリの仕組み： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://wp.me/p9LTcx-2H">NVRAM / NVMEM（パート1）</a> </li><li>  <a href="https://wp.me/p9LTcx-2E">NVRAM / NVMEM＆ライトスルー（パート2）</a> </li><li>  <a href="https://wp.me/p9LTcx-2S">書き込み割り当て、テトリス、MBUFおよびCP（パート3）</a> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>これには、後で公開されるHabraの記事へのリンクが含まれる場合があります</b> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>テキストのエラーに関するメッセージを<abbr title="プライベートメッセージ">LANに</abbr>送ってください</b> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>反対の記事に関するコメント、追加、質問はコメントしてください</b> 。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J280604/index.html">多分国際的な伝説</a></li>
<li><a href="../J280606/index.html">Badooでのデーモンログの収集と分析</a></li>
<li><a href="../J280608/index.html">プログラミング言語のタプル。 パート2</a></li>
<li><a href="../J28061/index.html">5分間のメールまたは一時メールボックス</a></li>
<li><a href="../J280610/index.html">ラプラシアンの可能性に関するサルタン王の物語</a></li>
<li><a href="../J280618/index.html">研究テスト：使用するタイミングと方法</a></li>
<li><a href="../J28062/index.html">古いが素晴らしいたとえ</a></li>
<li><a href="../J280622/index.html">2016年カンファレンステキストブロードキャストの構築-2日目</a></li>
<li><a href="../J280626/index.html">Apple Developer Centerの認定はわかりやすい</a></li>
<li><a href="../J280628/index.html">C ++ロシア2016から++ 5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>