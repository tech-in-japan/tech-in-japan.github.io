<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍤 🏩 🈚️ シンプルなツメゴ格子の書き方 📧 👍 🧕🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="約1年前、友人が私に行って、それがどのようにプレイされるかを示しました。 最初のゲームの1つで、ボードの下側を上に接続する石のチェーンと、左側を右に接続するチェーンを誇らしげに構築したことをよく覚えています。友人がこれを確かに良いと教えてくれましたが、私は失いました。 その後、その理由を理解するのに...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>シンプルなツメゴ格子の書き方</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/260935/"><img src="https://habrastorage.org/getpro/habr/post_images/0fd/559/c01/0fd559c0131b7de24d690bd13652396a.jpg" alt="2対2ゴバネ" align="left"> 約1年前、友人が私に行って、それがどのようにプレイされるかを示しました。 最初のゲームの1つで、ボードの下側を上に接続する石のチェーンと、左側を右に接続するチェーンを誇らしげに構築したことをよく覚えています。友人がこれを確かに良いと教えてくれましたが、私は失いました。 その後、その理由を理解するのに長い時間がかかりました。 それ以来、私は最初のKGS段について進み、友人は私と遊ぶのをやめました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     外出先でうまくプレイするには、いくつかの動きを先に見る必要があります。このスキルは、多くの問題を抱えている解決策をうまく開発します。 当然のことながら、ある日、これらの事柄の格子を書いて、理想的には問題に埋め込むのがいいだろうという考えに打たれました。特に、adumがこの考えを承認するので。 私自身は、数秒で約1の速度で多かれ少なかれ意味のある動きを試行する非常にゆるやかな方法でそれを解決しているので、検索の開始方法を定期的に忘れています（そしてこれは、与えられた問題3を自信を持って解決するのに十分です）。速度と精度は最も単純な検索、つまりdfsで機能し、タスクの複雑さを「数日間」と評価しました。 すぐに、私はこの格子を最も単純なdfsを使って「正面から」素早く書き込もうとしましたが、ちょっとした迷惑につまずきました。 考え直さずに、私は既に決められた位置を保存するためのキャッシュを開始し、すぐに別の迷惑につまずきました：別の動きのシーケンスでこの位置に来ると、一度見つかった解決策は間違っているかもしれません。 ここで私は何をすべきかわからずにハングアップしましたが、このトラブルは簡単に解決できると判断しました。少し考えてみるだけです。 私は長い間考え、このトピックの準備ができているもの、記事、アルゴリズムなどを見ることが理にかなっていると判断しました。 私が最初に出会ったのは、特定の「ラムダ深さ第一証明番号検索」であり、記事のサイズが数ページしかないことを見て、喜んで読み始めました。 この記事には、MartinMüllerとAkishi Kishimotoによる他の同様の記事へのリンクがあり、それらの記事にはリンクもあり、Kishimotoによる200ページの論文へのリンクがあり、問題の規模を認識しました。非常に単純なものでさえ、ほとんどの場合、アルゴリズムの複雑さは非常に複雑でした場合によっては、質問はすべてのオプションをどのようにソートするかではなく、ボード上で何かを見つける方法（初心者でもすぐに何をするか）、何をキャプチャまたは防御する必要があるかを理解する方法（人にとっても些細なこと）、およびどのような動きがありますか これは（ほとんどの場合も明らかです）オプションの実際の列挙に関しては、決定されたと言えます（ただし、効果的な列挙アルゴリズムは非常に注意が必要です）。 一般に、私のIQは明らかに外出先でこのような問題を解決するのに十分ではないことに気付き、すべての意味のある動きと目標が事前に設定されている最も単純なケースのソルバーを少なくとも書ければいいと判断しました-これは問題でも非常に役立ちます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私の知る限り、すべてを解決するプログラムはほとんどありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -Thomas WolfのGoTools：最大15の可能な動き、クローズドソース、非常に高度な静的解析を備えた簡単なdfs。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -Martin MullerのTsumego Explorer（ちなみに7が与えられます）：最大30の可能な移動、オープンソースJava（どこで入手できるかは明確ではありませんが）、Mullerの記事と論文で説明されている非常に高度な静的分析による高度なl-df-pn-r検索岸本。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -Martin MullerのFuego：オープンソースのC ++（SourceForgeからダウンロード可能）を使用して、本格的な2+ボットが提供されます（私よりも明らかに強力なので、その強さは評価できません）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Müllerもadumもjs格子を聞いていません（そして、格子はgosbleblemsに埋め込むことができるようにjs上になければなりません）、もしそうなら、それを書くことは理にかなっています-特にMüllerとKishimotoが多くの記事とこのトピックに関するプログラムですら。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href="http://www.goproblems.com/18629"><img src="https://habrastorage.org/files/ac0/b09/5b0/ac0b095b015b49b1b64e09cff0d75f5f.png" alt="タスク№18629、第一段" align="left"></a> 左は典型的なつめごです。 一般的なケースでは、タスクは黒と白の両方に対して最適な動き（および必要かどうか）を見つけることです。 明らかに、白が先に動いた場合、彼らはコーナーをキャプチャします。 黒が最初に移動すると、角度を保存できますが、解の1つはkoにつながり、黒がkoに負けた場合は角度を失い、もう1つの解はkoなしで角度を保存します。これは通常望ましいことです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     簡単にするために、ボードを見て、解決するために整理する必要があるすべての意味のある動きを見つける方法があると仮定します（実際、これはすべての動きが手動で設定されることを意味します）。 ボードbで誰が勝つかを示す関数Rを定義します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li><img src="https://habrastorage.org/getpro/habr/post_images/cc6/320/972/cc63209721b471ebec4c1b52705d0583.png"> 黒が始まり勝った場合。 </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/4e3/ea4/8854e3ea49e5c08bc583aa8a6328f30a.png"> 黒が始まり負けた場合。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Rの定義により、黒は秒のバランスを崩したとしても最初の動きをする義務があります-これは白と黒が絶えず通過する状況を排除します。 白人についても同様です。 黒と白の両方が失われた場合、これらはセクです。 次に、この関数を次のように再帰的に定義できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/ce7/ad2/32c/ce7ad232cb3d7c932e892a3fe4c43cd1.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     少しわかりにくいですが、その本質はシンプルです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Rの定義により、ブラックは何らかの動きを余儀なくされているため、可能な限りすべての動きの中からベストを選択します。 したがって、すべての移動の最大値はmです。 </li><li> その後、動きは白になり、彼らは動きをするかしないかを決めるかもしれません-これは最小です。 ホワイトが動きをする場合、結果は <img src="https://habrastorage.org/getpro/habr/post_images/317/2fb/e73/3172fbe73531d3e0f2ead9f0c93a5a53.png"> ここで、b + mは、黒い石mが追加されたボードbです。 </li><li> 白が動きを逃した場合（そして、これがRの定義と矛盾しない場合）、黒には選択肢があります：動きをするかセーブするか、ゲームを終了します-これは2番目の最大値です。 黒が動けば、判明 <img src="https://habrastorage.org/getpro/habr/post_images/66b/7a0/a2c/66b7a0a2c2aebfe328268b3afa90bed6.png">  、そして、それらが失敗した場合、R（b + m）は誰が勝ったかを決定します（実際には、これは、捕獲する必要がある石がボード上にあるかどうかを確認するためだけです）。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     白について対称式が得られます。  「額」と数えると、すべてのオプションを列挙した単純なdfsが得られます。これは、5ポイントの最も単純な攻撃でも非常にゆっくりと動作します。 次のように書くことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board: Board, color: Color</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = -color; <span class="hljs-comment"><span class="hljs-comment">// that's a loss for (const move of board.getMovesFor(color)) { const nextBoard = board.fork().play(move); result = bestFor(color, // it's +color's turn, so he chooses result, bestFor(-color, // now it's -color's turn solve(nextBoard, -color), // -color makes a move bestFor(color, // -color can pass, but then it's +color's turn again solve(nextBoard, color), // +color makes two moves in a row estimate(nextBoard)))); // neither player makes a move } return result; }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムは、最も単純な秒が秒であることを証明するために多くの時間を浪費することに注意してください。 白と黒のグループに共通の自由のみがあり、これらの自由が多数ある場合、このアルゴリズムは最初に最初の自由でプレイしようとし、それが機能しないことを見つけ、次に2番目の自由でプレイし、再び勝てないことを見つけます。 このアルゴリズムがすべてのオプションを反復するために行う移動の数について、単純な再帰式を作成することもできます。 成長は指数関数以上です。 この問題は、おそらく静的解析によってのみ解決できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここで、同じボードが2回解決されないようにする必要があります。 たとえば、5ポイントの高架道路の解決策を見つけたら、別の位置がその高架道路に下がった場合に再利用できます。 このようなソリューションキャッシュは通常、転置テーブル（tt）と呼ばれます。 このテーブルのキーは、ボードのハッシュ+最初に行く人の色です。 最初は、このように単純に実装しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tt: { [key: string]: Result } = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board: Board, color: Color</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = color + board.hash(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = -color; <span class="hljs-comment"><span class="hljs-comment">// that's a loss if (key in tt) return tt[key]; for (const move of board.getMovesFor(color)) { const nextBoard = board.fork().play(move); result = bestFor(color, // it's +color's turn, so he chooses result, bestFor(-color, // now it's -color's turn solve(nextBoard, -color), // -color makes a move bestFor(color, // -color can pass, but then it's +color's turn again solve(nextBoard, color), // +color makes two moves in a row estimate(nextBoard)))); // neither player makes a move } return tt[key] = result; }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/b2a/25e/964/b2a25e964920413684bbd875cf9bc3bb" align="left"> このコードの問題は、石の位置を見ただけでは判断できない位置があることです。 たとえば、ホワイトの動きは左側にありますが、誰が勝つかを理解することは不可能です。なぜなら、ホワイトがブラックの石を捕らえることができるかどうかは不明だからです（つまり、典型的な共同または2移動サイクル） ルールのこの小さな修正-位置を繰り返すことはできません-はゲーム中に当たり前のことであり、問​​題を引き起こすことはありません。また、スーパーコルール（つまり、数回の移動を伴うサイクルの禁止）は、毎日10ゲームをプレイしても一生会います。 奇妙なことに、アルゴリズムの列挙中に、いくつかの動きの長さ（5-7でそのように動きます）のサイクルが存在するという仮想的な可能性も確実に実現され、これが考慮されない場合、結果が正しくないか、アルゴリズムがループします。 したがって、この一見仮想の問題は、岸本の論文「反復の存在下での正確かつ効率的な検索アルゴリズム」として200ページも授与されました（実際、私はそれを圧倒しようとしています）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この問題の解決策はミュラーと岸本の記事で何度も言及されており、次のように聞こえます：解決策の検索で繰り返しが見つからなかった場合、それは彼らがこの位置に来た方法に依存しません。 あなたがそれについて考える場合、ステートメントはまったく明らかではありません。 私が証明にうんざりしているとき、私はミュラーに手紙を書きました、そして、彼はそうです、これは非常に強くて普遍的な声明であり、証明は論文のどこかにあるようです。 そこにはこの証拠が見つかりませんでしたが、既に解決されたパスに依存しないすべての決定が（メモリ不足のため）削除されることはないと仮定すれば機能する独自の証拠を考えました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/458/556/d06/458556d06b774bc39ae7ae51a65862d6" align="left"> 説明のために、私は恥知らずに誰かから写真をコピーしました:)可能な動きのグラフは通常、写真の中のこのツリーのように見えます。 このグラフの上部は、ボード上の石の位置を表し、色は誰が動くかを示します。 簡単にするため（そして一般性を失うことなく）、13番目のポジションが先に決定され、検索プロセスでサイクルが見つからなかった間にBlackが開始して勝ったことが判明したと仮定します。 ソリューションはツリーであり（サイクルはありません）、各黒い頂点から1つの動きが行われ（ソリューションの本質は任意の位置で正しい動きを示すことであるため、必要ありません）、すべての可能な動きは各白い頂点から行われます（ソリューション白の動きごとに黒の動きがあり、黒の勝利につながることを証明する必要があります）。 ここで、ステートメントが真実ではなく、13の位置で見つかった解がそれが含まれるパスに依存すると仮定します。 どういうわけか決定を間違える方法があります。 そのようなパスがデシジョンツリーと交差しなかった場合、そのパスに影響を与えることはできません。この仮想パスには、ツリーの少なくとも1つの頂点が含まれます。 このピークを取り、それを忘れずにこの経路に沿ってピーク13に進んでください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  13のソリューションは既にキャッシュされており、 </li><li> サイクルを検出せずに見つかったすべての中間ソリューションもキャッシュに残りました。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     頂点17から始めて、13に到達しようとするとします。証明の本質は、決定ツリーにサイクルがないため、17から13に接続するためにツリーを超える必要があることです。 頂点17は白（まあ、はい、それは赤ですが、それが白であると仮定します）であり、したがって、それからのすべての動きはツリー内にあります。  25番目のブラックピークに達したとしましょう。 頂点は黒であるため、そのソリューション（正しい移動）はキャッシュに書き込まれ（そこからは何も削除されません）、25のソリューションが見つかった後、この仮想パスに沿って進むため、既製のソリューションをキャッシュから取得し、まだツリー内にある白いピークに入ります。 ですから、この仮想的な道をたどり、動きのない行き詰まりに陥るまで待ちます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ご覧のとおり、ループの問題を解決するには、かなりの量が必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 位置ではなくパスの解決策を探します：解決（パス：ボード[]、色：色）。 </li><li> 検索中に繰り返しに遭遇した場合、それを敗北と見なしますが、同時に、繰り返されるパスの先頭を指します（パスのインデックスを覚えておいてください）。 ペア（結果、インデックス）の意味は、解は無条件ではなく、特定の位置での繰り返しに依存するということです。 </li><li> すべての可能な動きの中ですべてが敗北につながる場合、繰り返しを示すすべてのインデックスの中で最小値を見つけ、この最小値を返します。 </li><li> 勝ち手がある場合は、可能な限り大きな繰り返しインデックスを持つものを選択することが望ましいです。 最良の場合、ゲインは無条件になります。 パスに依存しません。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これ（および石の自由度を最大化し、他の人の自由度を最小化する単純なヒューリスティック）は、最も単純な大工の正方形を解くのに十分です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最初の例のように、もっと面白いことを解決するには、coを考慮する必要があります。 考えられるアプローチの1つは、「動的に」検討することです。 検索プロセスで繰り返しが発生する場合は、検索を2つのケースに分岐します（脅威がある場合とない場合）が、このためにはコード全体を徹底的にシャベルする必要があります。 別のアプローチは、次の「静的」な会計です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 新しいパラメーターは、外部の脅威の数です。 このパラメーターが+3の場合、黒にはさらに3つの脅威があり、-2の場合、白には2つの脅威があります。 </li><li> 決定プロセス中に繰り返しが発生し、この繰り返しに対する脅威がある場合、無駄になり、パスがリセットされます（実際、脅威の目標は、パスをリセットし、ゼロから検索を開始することです）。 </li><li> キャッシュ内の決定は、単一の数値（+1または-1）としてではなく、両側の数字の無限の配列として書き込まれ、それぞれの共脅威の数に対して結果が書き込まれます：-2共脅威の場合、白が共脅威を1つだけ持つ場合、白が勝ちます。 secaが判明し、脅威がなければ黒が勝ちます。 明らかに、黒がN個の脅威で勝った場合、彼はN + 1でも勝ちます。 白人についても同様です。 これは、ソリューションが2つの数字の形式で記述できることを示しています。勝利するのに十分な黒の脅威の数（maxb）と、勝利するのに十分な白の脅威の数（minw）です。 そして、k個のco脅威を持つbの解を探しており、b minwとmaxbが以前の解決の試みから知られている場合、k &lt;minw（白勝）とk&gt; maxb（黒勝）の答えをすぐに返すことができます。 minw &lt;k &lt;maxb解決策を探す必要があります。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs">interface Results { <span class="hljs-attr"><span class="hljs-attr">minw</span></span>: number; <span class="hljs-comment"><span class="hljs-comment">// white wins if nkt &lt;= minw maxb: number; // black wins if nkt &gt;= maxb } const tt: { [key: string]: Results } = {}; function solve(path: Board[], color: Color, nkt: number): Result { function solveFor(color: Color, nkt: number): Result { const board = path[path.length - 1]; const key = color + board; const cached = tt[key] || { minw: -Infinity, maxb: +Infinity }; if (color &gt; 0 &amp;&amp; nkt &gt;= cached.maxb) return +1; // black has enough ko treats to win if (color &lt; 0 &amp;&amp; nkt &lt;= cached.minw) return -1; // white has enough ko treats to win var result = -color; // that's a loss var depth = Infinity; // where repetition occured /* ... */ if (color &gt; 0 &amp;&amp; nkt &lt; cached.maxb) cached.maxb = nkt; if (color &lt; 0 &amp;&amp; nkt &gt; cached.minw) cached.minw = nkt; tt[key] = cached; return [result, depth]; } return solveFor(color, nkt); }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さて、外部の脅威を考慮して問題を解決するために、最初に脅威がないという仮定の下でそれを解決する必要があり（nkt = 0）、結果が変わるまでこのパラメーターを増減し続けます。 これは、理論的には決定グラフによって決定できます。見つかったソリューションが失われたkoに依存する場合、1つの外部ko脅威を追加して再度解決するのが理にかなっています。 実際には、私はこれをしませんでした。必要な脅威の数が1を超えることはほとんどありません。 解決するために2つのkoを獲得する必要がある問題がありますが、これはエキゾチックです。したがって、| nk2 | &lt;2で解決した場合、一般に、問題は解決したと言えます。 このように、キャッシュを埋める最初のソリューション（通常はnkt = 0の場合）の検索に99％の時間が費やされ、その後、他のnktのソリューションが（JSでも）ほぼ瞬時に見つかることに注意してください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それだけです。 最適化のないJS上のこのような単純なラティスは、すべての人（GCがロードするもの）に一時オブジェクトを作成し、各移動がボード全体をコピーする前に、数秒で合計10個の空きセルをすばやく解決できます（たとえば最初に見せたもの）。 少し大きくなると、ほとんどの場合、ハングし、GCをロードします。 ただし、アルゴリズムを高速化する方法はたくさんあるため、この種の最適化には意味がありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 高度な深さ検索を適用します：dfpn、dfpnr、ldfpnr。  Mullerは、ldppnrは27個の空きセルでそれを圧倒できると書いています。 </li><li> 静的解析アルゴリズムを書く-まだBensonのアルゴリズムを実装していません。 誰が勝ったかが明らかな場合、これは検索を停止します。 これがおそらくすべてを迅速に解決できる主な理由です。通常、頭の中で解決策を見つけることは、評価で終わるいくつかの短いシーケンスを整理するように見えます。 </li><li> ボード上の何かを探す方法と移動する場所を考え出します。 これを行うには、自分の考えを「注意深く」注意深く観察し、何かを正確に見つける方法を理解するだけです。 もちろん、この探索の鍵は、グループが2つの目を作ることができるかどうかを判断することに基づいて、グループ（少数の密集した石）の活力を評価することです：それは常に、弱くて比較的大きなグループの近くに配置されます（そのため、それをキャプチャまたは保存するのに意味があります） </li><li> スクイズ、ウェッジ、スナップバック、ラダー、ネットなどのトリックライブラリ（tesuji）を作成します。 これらのトリックは、心の中で解決策を見つける上で大きな役割を果たします。結局のところ、スナップバックを見つけるために可能なオプションをすべて計算するわけではありません-石の特徴的な組み合わせに気づき、このトリックから何かを絞ることができるかどうかを確認するだけです。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="">気</a>にする人<a href="">は</a> 、 <a href="">githubで</a>コードを見ることができます。 率直に言って、速度を犠牲にすることなくモジュールに分割されるようにラティスコードを整理する方法を理解したらすぐに、すべてを書き換えてnafigする必要があります。など さて、単体テストを書くことができるように、そうでなければ、各変更の後、「このがらくたはまだ機能しますか？」 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J260919/index.html">ボード配布結果。 優良株のアップグレード</a></li>
<li><a href="../J260923/index.html">アクセス権-所有者は何でもできます</a></li>
<li><a href="../J260929/index.html">近い将来の7つのWebデザインのトレンド</a></li>
<li><a href="../J260931/index.html">Jii-Yii 2のアーキテクチャを備えたJavaScriptフレームワーク</a></li>
<li><a href="../J260933/index.html">クラウドゾンビハント</a></li>
<li><a href="../J26094/index.html">マスターホストからの学生</a></li>
<li><a href="../J260943/index.html">健康を守るIntel Edison。 「FRUCT MD」を体験</a></li>
<li><a href="../J260947/index.html">Windowsログのイベントの監視と警告：Windows Server 2012 R2の電子メール</a></li>
<li><a href="../J260949/index.html">プログラミングがそんなに難しいのはなぜですか？</a></li>
<li><a href="../J26095/index.html">Houseisms（まあ、まだDoctor Houseを見ていない人はいますか？）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>