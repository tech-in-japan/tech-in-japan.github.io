<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😎 💜 😊 プロジェクト間のコラボレーションセキュリティ 👂🏻 👁️ ✊🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="はじめに  
  
 今日、多くのインターネットサービスがインターネットを介して相互にやり取りしています。 相互作用の特別なクラスは、機密情報が送信されるもの（個人データ、秘密メッセージ）または誰かが実行を明確に確認する必要があるチーム（たとえば、送金や誰かに代わってメッセージを公開する）です。 明...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>プロジェクト間のコラボレーションセキュリティ</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/77689/"><h4> はじめに </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     今日、多くのインターネットサービスがインターネットを介して相互にやり取りしています。 相互作用の特別なクラスは、機密情報が送信されるもの（個人データ、秘密メッセージ）または誰かが実行を明確に確認する必要があるチーム（たとえば、送金や誰かに代わってメッセージを公開する）です。 明らかに、そのようなサービスは侵入者から確実に保護されるべきです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     残念ながら、すべての開発者がアプリケーションのセキュリティの程度について考えるわけではありません。 この問題は、多くのeビジネス担当者がエンドサービスに実装された場合、適切に理解せずに使用すると深刻な脆弱性を引き起こす可能性のあるプロトコルを開発しているという事実によってさらに複雑になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事の目的は、既製のプロトコルをより慎重に使用して独自のプロトコルを開発するために、プロジェクト間（つまり、サーバーとサーバー）の相互作用中に発生する可能性のあるタイプの攻撃とそれらに対する保護手段を簡単に説明することです。 多くの場合、この分野のエンド開発者の知識はやや断片的であるため、情報セキュリティの基本を事前に検討します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さまざまなタイプの攻撃からの保護（または保護の欠如）は、今日の一般的なシステムのプロトコルの例で実証されています： <a href="http://assist.ru/">Assist</a> 、 <a href="http://www.cyberplat.ru/">Cyber​​plat</a> 、 <a href="http://webmoney.ru/">WebMoney</a> 、 <a href="http://www.chronopay.com/">ChronoPay</a> 、 <a href="http://www.robokassa.ru/">Robokassa</a>および<a href="https://www.x.com/">PayPal</a> （支払いシステム）、および<a href="http://openid.net/">OpenID</a> 、 <a href="http://dev.aol.com/api/openauth">OpenAuth</a> 、 <a href="http://oauth.net/">OAuth</a> （分散認証）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 安全な相互作用 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それでは、「 <b>安全な相互作用</b> 」という言葉の意味を定義しましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. <b>認証</b> 。 サーバーAがサーバーBにメッセージを送信するようにします。Bは、メッセージがAから送信されたことを確認できるはずです。このチェックは、サーバーB上のサーバーAの認証と呼ばれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2. <b>データの整合性</b> 。 転送中にメッセージが変更されていないことを確認する必要があります（たとえば、50ドルが支払われ、500ドルの確認が受信されました）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3. <b>相互作用の機密性</b> 。 この条項は、メッセージを受信する資格がある当事者のみを意味します。 原則として、この句は送信中<b>の</b>情報の<b>暗号化を</b>意味し<b>ます</b> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     場合によっては、さらに2つのポイントを検討できます。アクセス権の検証と否認防止の不可能性ですが、今のところはこれを無視します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 暗号プリミティブ </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここでは、理論に余談をする必要があります。 暗号の基礎については詳しく説明しません（さもなければ、記事の量は妥当な範囲を超えます）が、記事のさらなる部分を理解するために必要な知識を示すために、主要な「 <b>暗号プリミティブ</b> 」について簡単に言及します。 興味のある方は、ウィキペディアへのリンクをたどって詳細をご覧ください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> さまざまな<b><a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">対称暗号化</a></b>システムがあります。 これらのシステムの基礎は、両当事者に知られている1つのキーKです。 このキーは、メッセージの暗号化と復号化の両方に使用されます。 標準の例： <a href="http://ru.wikipedia.org/wiki/RC2">RC2</a> 、 <a href="http://ru.wikipedia.org/wiki/RC4">RC4</a> 、 <a href="http://ru.wikipedia.org/wiki/RC5">RC5</a> 、 <a href="http://ru.wikipedia.org/wiki/DES">DES</a> 、 <a href="http://ru.wikipedia.org/wiki/3DES">3-DES</a> 、 <a href="http://ru.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> 、 <a href="http://ru.wikipedia.org/wiki/Blowfish">Blowfish</a> 、 <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%259E%25D0%25A1%25D0%25A2_28147-89">GOST 28147-89</a>など </li><li>  <b><a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">非対称暗号化システム</a></b>が存在します。 ここでは、それぞれの側に秘密鍵と公開鍵があります。 オープンは誰にも知られています（システムをハックしたい暗号解読者を含む）、秘密-片方だけに。 誰でもサイドAの公開鍵を使用して、サイドAのメッセージを暗号化できます。秘密鍵の所有者のみがこのメッセージを解読できます。これはAです。標準の例： <a href="http://ru.wikipedia.org/wiki/RSA">RSA</a> </li><li> 原則として、公開鍵はいわゆる形式で配布されます。  <b><a href="http://ru.wikipedia.org/wiki/X.509">証明書</a></b> 一般的に、公開鍵は証明書の一部にすぎませんが、将来的にはこれらの用語を同義語として使用します。 </li><li> 通常、秘密鍵と公開鍵の同じペアを使用して、 <b><a href="http://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">デジタル署名</a></b> （CPU）を生成できます。 この場合、紙の文書に人の署名が存在するように、メッセージと秘密鍵に基づいて生成された電子メッセージの本文にデジタル署名が生成されます。 秘密鍵を使用せずに署名を生成することはできませんが、誰でも対応する公開鍵を使用して署名を検証できます。 このようにして、メッセージが必要なサーバーまたは人によって正確に送信され、「偽物」ではないことを確認できます。 プロトコル： <a href="http://ru.wikipedia.org/wiki/RSA">RSA</a> 、 <a href="http://ru.wikipedia.org/wiki/DSA">DSA</a> 、 <a href="http://ru.wikipedia.org/wiki/ECDSA">ECDSA</a> 、 <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%259E%25D0%25A1%25D0%25A2_%25D0%25A0_34.10-2001">GOST R 34.10-2001</a> </li><li>  2つのパーティーが<b>それをチャンネルの上に伝えないで共通のキーK</b>を<b>生成</b>できるプロトコルがあり<b>ます</b> 。 プロトコルの例は、 <a href="http://en.wikipedia.org/wiki/Diffie%25E2%2580%2593Hellman_key_exchange">Diffie-Hellman Key Exchange Protocol</a> （以降、簡潔にするために単にDiffie-Hellman）、 <a href="http://ru.wikipedia.org/wiki/SRP">SRP</a>です。 たとえば、最初のものは現在人気のある<a href="http://ru.wikipedia.org/wiki/OpenID">OpenID</a>システムで使用されています。 </li><li> テキストを固定長のビットセットにマッピングする<a href="http://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">ハッシュ関数</a>があります。 同じハッシュを持つ2つのテキストを見つける作業は「非常に難しい」と考えられています。 例： <a href="http://ru.wikipedia.org/wiki/MD5">MD5</a> （すでに「壊れている」）、 <a href="http://ru.wikipedia.org/wiki/SHA-1">SHA-1</a> 、 <a href="http://ru.wikipedia.org/wiki/SHA-2">SHA-256</a> 、 <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%259E%25D0%25A1%25D0%25A2_%25D0%25A0_34.11-94">GOST R 34.11-94</a> </li><li>  <b><a href="http://ru.wikipedia.org/wiki/HMAC">ハッシュメッセージ認証コード</a></b> （HMAC）コードが存在します。 これはメッセージとキーの関数であり、出力で固定長のハッシュ文字列を提供します。 両側に秘密鍵Kがある場合は、対称暗号システムでデジタル署名を生成する方法としてHMAC機能を使用できます。これは、鍵を持つ2者のみがメッセージの署名を生成および検証できるためです。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  SSL / TLSおよびHTTPS </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「相互作用のセキュリティ」について言えば、合理的な（やや）質問をすることができます。このすべて：認証、整合性サポート、暗号化はSSL / TLS（HTTPS）にあります。  <b>なぜ他の何かが必要なのですか？</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、理論への2番目の余談は<b>、SSL / TLSおよびHTTPSが何</b>である<b>かを</b>簡単に思い出させる<b>こと</b>です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>SSL</b> （ <a href="http://ru.wikipedia.org/wiki/SSL">Secure Socket Layer</a> ） <a href="http://ru.wikipedia.org/wiki/SSL">プロトコル</a>とその「子孫」 <b>TLS</b> （ <a href="http://ru.wikipedia.org/wiki/TLS">Transport Layer Security</a> ）は、安全なクライアントサーバー通信の必要性に応じて開発されました。 プロトコル<a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_OSI">はOSIモデル</a>トランスポート<a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_OSI">層で動き</a>ます。 適切に使用すれば、クライアントとサーバー間の暗号化された接続を確立できます。 プロトコルは、両方向に送信されるメッセージの変更および読み取りから保護されます。 また、このプロトコルにより、クライアント（私は繰り返し使用しています）が、不正なサーバーではなく適切なサーバーとの接続を確立したことを確認できます（言い換えると、クライアントはサーバーを認証できます）。 クライアントへの認証を許可する、つまり双方向認証を提供する変更があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>HTTPS</b> （ <a href="http://ru.wikipedia.org/wiki/HTTPS">HTTP Secure</a> ）は同じHTTPですが、SSL / TLSで保護されたチャネルを介して送信されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     不完全な実装にSSL / TLSチャネルが存在するということは、ポイントとリモートサーバー間の接続が、情報のリッスンと置換の観点から十分に保護されたプロトコルを通過することを意味するだけであることを理解することは非常に重要です。 しかし、これはリモート側がまさにあなたが連絡したかったものであると確信するまで何も意味しません。 これは、リモートパーティの証明書が事前に知られていて信頼している場合、またはセキュリティで保護されていないチャネルを介して「サードパーティ」と呼ばれる同じ証明書を受け取った場合にのみ確認できます 証明機関またはCA 同時に、署名を検証するために使用されるCA公開キーは、安全でないチャネルを介して送信される必要がないように、事前に知っておく必要があります。 たとえば、ブラウザでこのセキュリティをどのように確保していますか？ メインCAの証明書（最も有名なもの-COMODO、VeriSign、Go Daddy、Thawteなど、数十個しかない）は事前にブラウザに組み込まれています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして、あなたのサービスのコードで証明書を検証する方法は？ 事前に証明書をお持ちの場合、これを行うのは非常に簡単です（たとえば、PHPプログラマーは<a href="http://ru2.php.net/curl_setopt">curl_setopt</a> （）、オプションCURLOPT_CAINFOおよびCURLOPT_CAPATHの方向を見ることができます）。 このようにして、WebMoneyサーバーとの相互作用コードで接続が保護されます。 事前にCAサーバーを知らない場合、さまざまなCAの証明書のコレクションを自分で選択して維持する必要があるため、実際にこのようなチェックを行うことはやや困難です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     実際には、コードでの証明書の検証は実行されないことが多く、 <b>サーバーのなりすまし</b> <b>攻撃</b>または中間者（MITM）攻撃という<b>2つの攻撃の</b>いずれかにつながる可能性があり<b>ます</b> 。 後者は、ユーザー（A）と宛先サーバー（B）の間に別のサーバー（M）があることを意味します。 あなた（A）は、Bとの接続を確立したと考えて、Mとの完全に安全な接続を確立します。その後、MはBとの安全な接続を確立し、要求を彼とあなたに返します。 したがって、MはインタラクションA-Bをリッスンし、送信されたメッセージを修正することさえできます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     論理的な問題は、サーバースプーフィングと「中間者」の攻撃が実際にどれだけ実行可能かということです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     おそらく、相互作用するサーバーが両方とも深刻なデータセンターにある場合（そしてもちろんサーバー自体がハッキングされていない場合）、そのような攻撃の実装は非常に困難です。 サーバーが企業、大学、またはホームネットワーク（最適な方法で設計されていない）にある場合、 <a href="http://ru.wikipedia.org/wiki/ARP-spoofing">ARP攻撃</a>により、攻撃者はネットワークを出入りするすべてのトラフィックを自分自身で完全に誘導でき、これらの攻撃はすべて非常になりますただ実行可能。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>それで、なぜSSL / TLSに必ずしも満足していないのか。</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>アプリケーションコードでのランダムサーバー認証の複雑さ。 その結果、「Man in the Middle」攻撃に対する保護なしで、プロトコルを部分的に使用します。 </li><li> 一方向認証（はい、双方向認証のためのプロトコル変更がありますが、これはあまり使用されず、すべてのプログラミング言語が既製のソリューションを簡単に見つけることができるわけではありません）。 </li><li> さらに、SSL / TLSアーキテクチャでは、送信者のデジタル署名付きのメッセージを保存することは許可されていないため、後でそれを使用して、メッセージが実際に作成者によって送信されたことを証明できます（つまり、非作成者に対する保護が機能しません）。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> セキュリティを実践する </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それでは、少しの間「 <b>安全な相互作用</b> 」に戻り、示したポイントが実際にどのように実装されているかを見てみましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. <b>認証に</b>は、通常、「ログイン-パスワード」ペア、または何らかの方法で生成されたデジタル署名を使用します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2.アプリケーションによって生成されたSSL / TLSおよびデジタル署名は、 <b>データの整合性</b>を検証するために使用され<b>ます</b> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3.データを<b>暗号化する</b>ため、つまり<b>機密性</b>を<b>確保するために、</b>ほとんどのシステムはSSL / TLSを使用します（自己暗号化キーの例がありますが、データは「独自の」方法で暗号化されることは比較的まれです）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Webサービスといえば、ほとんどの場合SSL / TLSがHTTPSとして使用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 保護されたアプリケーションの種類 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最終的にプロトコルへの攻撃に移る前に、設計されたシステムが機能する制限について話す必要があります。 安全な相互作用の問題を考慮できる3つの主要なタイプのアプリケーションに言及したいと思います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. <b>相互作用する2つの当事者は、保証された安全なチャネルで必要な情報を事前交換する機会があります</b> 。共有キー、証明書、パスワードなどです。 そのようなチャネルは、人々の間で必要な情報を直接送信すること（何よりも）、代替通信チャネル（モバイル通信、電話）、さらにはインターネットです。両当事者が「中間者」またはメッセージを傍受または変更する別の方法がないと確信している場合です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2. <b>集中型アーキテクチャ</b> 。  2者ごとに事前に合意する機会はありませんが、ネットワークメンバーは、相互作用する当事者の証明書に署名し、その有効性を保証する<b>第三者</b>を信頼します。 例としては、公開キー基盤（PKI）、またはいくつかの注意事項がありますが、ブラウザーが有限数の証明機関（CA）を信頼するのと同じインターネットであり、これに基づいて、適切なサイトと対話することを確認できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3. <b>分散アーキテクチャ</b> 。 そのようなアプリケーションでは、単一のサードパーティはありません。 このようなアーキテクチャの主なタスクは、同じ人が<b>2回目に</b>来たことを確認することで<b>ある</b>ことを理解することが重要です。 つまり、誰もが最初に認証できるようにするとき（たとえば、OpenIDをサポートするサイトでは、誰でも認証できます）。 さらに<b>、システムに</b>何らかの<b>貢献をし</b>たとします。たとえば、メッセージを書いたとします。 次回ここに来るとき、サイトはこのメッセージを編集するためのアクセス権をあなた（そしてあなただけ）に与える必要があります。 プロトコルの例：OpenID、OAuth、ピアツーピアプロトコル。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 攻撃と防御 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして最後に、プロトコルで実行される主な種類の攻撃と、それらがプロトコルからどのように保護されるかを見てみましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>1.メッセージの作成者または信頼性の検証の欠如</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     古い冗談を思い出させてください。 プログラミングには、2種類のエラーがあります。入力データの検証不足とその他のエラーです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     サイドAからメッセージMを受信した場合、次のことを確認する必要があります。a）メッセージが実際にAから送信されたもの。  b）AがメッセージMを正確に送信し、途中で変更されなかったこと。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     非識字者向けに設計されたプロトコルの例は、 <a href="http://assist.ru/">Assist</a>支払いシステムとオンラインストアとの<a href="http://assist.ru/files/manual_new.pdf">相互作用</a>の<a href="http://assist.ru/files/manual_new.pdf">ためのプロトコルです</a> 。  Assistのサーバーで購入代金を支払った後、ユーザーはURL_RETURN_OKアドレスに戻ります。このアドレスは平文で送信され、ユーザー購入者が変更できます。 つまり、ユーザーはオンラインストアへの購入代金を支払った後に戻ってきて、「ありがとう、$ 1000の支払いをしただけです」と言いますが、ストアはこれが正しいことを確認する方法がまったくありません。 後になって、マネージャーの手によって、または自動的に（ただし、10分間に1回を超えないように！）、支払いが本当に通過したことを確認できます。 ちなみに、Assistのプロトコルは4年以上変更されていません。 そして、デジタル署名を追加するだけです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、メッセージの作成者と整合性を検証する方法。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 秘密鍵と公開鍵のペアに基づいたデジタル署名を使用します。 これはおそらく最も信頼性が高く、汎用性の高い（つまり、あらゆる条件で動作する）方法です。 公開鍵は、事前に受信側に送信できます（今日の<a href="http://webmoney.ru/">WebMoney</a> 、 <a href="http://www.cyberplat.ru/">Cyber​​plat</a> 、 <a href="http://oauth.net/">OAuth</a>など、多くの人がこの方法を使用しています）。 また、公開キーは後で安全でない接続を介して取得し、証明機関（CA）証明書を使用して検証できます。 この方法は、大企業で使用される公開キー基盤（PKI）の機能の基礎となります。 </li><li> 共通鍵Kが生成されます。たとえば、 <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B8%25D1%2584%25D1%2584%25D0%25B8_%25E2%2580%2594_%25D0%25A5%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Diffie-Hellman</a>プロトコルなどに基づいて、メッセージの署名に使用されます（たとえば、 <a href="http://ru.wikipedia.org/wiki/HMAC">HMAC-SHA1</a>を使用）。  <a href="http://openid.net/">OpenIDで</a>使用されます。 </li><li> メッセージの整合性が重要ではなく、作成者の確認のみが重要な場合、「ログイン-パスワード」またはシークレット行のペアを使用して、保護されたリソースにアクセスすることがあります。 たとえば、 <a href="http://www.flickr.com/">Flickrは</a> 、ユーザー名とパスワードを含む要求に応じて、XML-RPCプロトコルを使用して写真を送信します。  <a href="http://recaptcha.net/">reCAPTCHA</a>システムでは、ユーザーが入力したCAPTCHAコードを検証し、秘密の文字列で検証者を認証できます。 この方法は、単純ではありますが、メッセージの傍受によりパスワードが明らかになり、将来、攻撃者があなたに代わって自由にリクエストを送信できるという点で非常に悪いことを理解する必要があります。 デジタル署名を使用する場合、メッセージを傍受しても攻撃者は何もできません。 </li><li> メッセージ認証には、より簡単な（サーバーのなりすましや中間者に対する保護はありませんが）方法があります。 たとえば、 <a href="https://www.x.com/">PayPalの</a> <a href="https://www.x.com/docs/DOC-1084">即時支払い通知</a> （IPN）プロトコルでは、サーバーが支払い確認を受け入れて、「 <b>本当に送信しました</b>か？」という質問とともにメッセージのコピーをサーバーに<b>送信する必要があります</b>か？ 同様の方法がOpenIDプロトコルで使用されますが（非推奨モードで作業している場合）、メッセージが返されるだけでなく、デジタル署名付きのメッセージが返され、リクエストは既に「 <b>このデジタル署名を入れたかどうかを確認</b> 」のように見え<b>ます</b> 。 同様のスキームが<a href="http://dev.aol.com/api/openauth">OpenAuthで</a>機能し<a href="http://dev.aol.com/api/openauth">ます</a> 。 このアプローチの利点は、片側または両側に暗号化アルゴリズムを実装する必要がないことです。 </li><li>  <a href="http://www.robokassa.ru/">ロボカッサ</a> <a href="http://www.robokassa.ru/Doc/Ru/Interface.aspx">は</a> 、デジタル署名を生成する独自の方法を<a href="http://www.robokassa.ru/">考案</a> <a href="http://www.robokassa.ru/Doc/Ru/Interface.aspx">し</a>ました。デジタル署名は、メッセージと秘密パスワードのMD5ハッシュ関数として形成されます。 この方法は、パスワードが十分に強力でなければならないという理由だけで、慎重に扱う必要があります。 パスワードが短い場合、さらにパスワードが人によって選択された場合、パスワードを解読することはハッカーにとって簡単な作業です。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>2. HTTPSの信頼性を願っています。</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     前述のように、アプリケーションが接続する任意のサーバーのHTTPSプロトコル内での認証の実装は、かなり難しいタスクです。 上記で詳細を検証しましたが、簡単な結論は簡単です。サーバー証明書の認証なしで、HTTPSの意味をゼロに減らすことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     分散型の認証プロトコルはありません-OpenID、OpenAuth、OAuthは、サーバーのなりすまし攻撃や中間者から保護されています。 場合によっては、支払いシステム（PayPal、Assist）も同様の方法で攻撃される可能性があります。 その結果、実際には発生していませんが、支払いが発生したことをオンラインストアアプリケーションに納得させることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      HTTPS接続を確立するサーバーに主要なインターネットCA（VeriSign、COMODOなど）の十分な数の証明書があれば、この攻撃を保護できることを再度強調しますが、実際には実装が難しい場合があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして私は、 <b>分散システムの場合、</b>これは<b>根本的に不溶性の問題で</b>あることを強調し<b>ます</b> 。 私たちの分類（上記を参照）に属する商用支払いシステムでは、当事者が「 <b>事前に同意</b>する」 <b>こと</b>ができるシステムに対応していますが、この攻撃は適切なプロトコル設計<b>により防止されてい</b>ます。 そのような実装の例は<a href="http://webmoney.ru/">WebMoneyです</a> 。これは、HTTPS接続を認証するための証明書を提供します。  （ <a href="http://www.chronopay.com/">クロノパイ</a>もそれを行うよう<a href="http://www.chronopay.com/">です</a> -私を修正してください）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>3.「Man in the Middle」を攻撃します（Man in the Middle、MITM）。</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      HTTPSプロトコルのMITM攻撃を調べました。 ただし、他のプロトコルもこのタイプの攻撃に対して脆弱です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この例は、OpenIDで使用される<a href="http://ru.wikipedia.org/wiki/Diffie-Hellman">Diffie-Hellman</a>です。 上記のように、その本質は、AとBの2つのパーティによる共有キーKの生成にあります。しかし、トラフィックを変更できる中間（M）がいる場合、AがMでキーを生成したことがわかります。 K1、およびB-Mと共有されるキーK2 その結果、「The Man in the Middle」は、あらゆる方向に向かうあらゆるデータに署名して読み取ることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     もちろん、クライアントとサーバー（OpenIDプロバイダーと証明書利用者）が完全な証明書検証を使用してHTTPS経由で通信する場合、OpenIDではこのような攻撃は機能しません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>4.オープンチャネルを介した秘密鍵の送信。</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     多くの開発者は、秘密鍵の本質を理解していません。 公開鍵を使用するインフラストラクチャのすべてのセキュリティは、相互作用する当事者が無条件に誰かを信頼できるという事実に基づいています。  2番目のサーバー、サードパーティ-それは重要ではありません。 原則として、「信頼」の問題は、メッセージ加入者の公開鍵を使用したデジタル署名の検証にかかっています。 この公開キー（証明書）が安全でないチャネルを介して送信され、途中で変更された場合、すべてのセキュリティがクラッシュする可能性があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「深刻な」企業には、このキーの転送、保管、更新を担当する特別な人がいます。 転送は通常、信頼できる宅配業者を通じてオフラインで行われます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     支払いシステム用のプロトコルを作成している場合、オフィスで契約書に署名するときに、サーバーの公開鍵をオンラインストアの所有者（ディスケットまたはフラッシュドライブ）に個人的に転送することが理想的です。 はい、何らかの理由で、これは常に実行可能ではありません。 したがって、多くの場合、証明書はインターネット経由で配布されます。 ただし、この場合、キーのなりすましを防ぐために、考えられるすべての対策を講じる必要があります。 電子メールでキーを送信することはできません。  HTTP経由でダウンロードすることはできません-HTTPSのみ。 サイトには、ダウンロードされた情報の確認に関する情報（たとえば、キーからのハッシュを使用してその信頼性を検証する）を含める必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>5.リクエストを再送信します。</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2つの例を使用して、このタイプの攻撃を検討します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     例1：支払いシステム。 立派なサーバーである私が、支払システムを通じて10ドルを送金したいとします。 同時に、HTTPまたは「不正な」HTTPS（証明書の検証なし）を使用して、支払いシステムサーバーに接続します。 正直にリクエストを作成し、証明書で署名します。 反対側がリクエストを受け取り、私の10ドルが受取人に送られます。 しかし、私はオープンプロトコルを使用していたため、攻撃者はサーバーへのリクエストを読み取ることができました。 この攻撃者が私を台無しにしたい場合、彼は同じリクエストを支払いシステムサーバーに再度送信します。 サーバーは署名を検証し（「正しい」サーバーによって形成されるため正しい）、他の$ 10がアカウントから引き落とされます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     例2：OpenIDプロトコル。  <a href="http://openid.net/specs/openid-authentication-1_1.html">OpenID Authentication 1.1</a>プロトコルには、次の脆弱性がありました。 攻撃者がOpenIDクライアント（Relying Party）とエンドユーザーの相互作用を聞いた場合、しばらくすると、OpenIDを使用してRelying Partyでこのユーザーの再認証を開始できます。 この場合、ユーザーがサイトを訪問したという記録が依存パーティのログに表示されます。 特に軽率な実装の場合、攻撃者はこのユーザーとして認証さえする可能性があります。 はい、これに対する保護方法がありますが、プロトコルで必須と宣言されていません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この脆弱性は<a href="http://openid.net/specs/openid-authentication-2_0.html">OpenID Authentication 2.0</a>で修正され、サーバー（OpenIDプロバイダー）とクライアント（依存パーティ）の両方の動作に変更が加えられました。  OpenID認証プロトコルに精通している読者には、理解するためのタスクを提案します。サーバーを変更できない場合に、OpenIDクライアントバージョン1.1でそのような保護を実装する方法を教えてください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このタイプの攻撃から保護するには、いくつかの方法があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> たとえば、 <a href="http://www.cyberplat.ru/">Cyber​​plat</a>では、各リクエストに一意のセッション番号を挿入するよう顧客に要求しています。 この一意の番号は、単語<a href="http://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a> （Number used ONCE）とも呼ばれます。 同じセッション番号を持つ2つの要求、支払いシステムは処理を拒否します。 また、攻撃者はセッション番号を変更できません。これは、変更されたメッセージに対して正しいデジタル署名を生成する機会がないためです。 </li><li> また、リクエストに現在の時刻のラベルを挿入することにより、時間保護を使用することもできます。  「古い」リクエストは切断されます。 </li><li>  OpenID 2.0は、これらの両方の方法を使用して、このタイプの攻撃から保護します。ノンスには、現在の時刻と（オプションで）ランダムな文字列が含まれます。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>6.</b>説明を完全なものにするために（時には忘れられることもあります）、当たり前のことも言及する価値があります。 システムがパスワードまたはキーのセキュリティに基づいて構築されている場合、このデータは確実に保護する必要があります。 共有ホスティング上のすべてのファイルにアクセスするためのUNIX権限07XXを設定すると、「サーバーネイバー」によって読み取られる「シークレット」が保存されているデータベースへの証明書ファイルまたはパスワードが作成される可能性があります。 パスワード、権限、アクセス制限の設定を忘れないでください。 しかし、誰もがこれを知っているので（誰もが知っているわけではありませんが）、私は長い間広めません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>7.</b>別のタイプの脆弱性は、プロトコルを実装するときにプログラマーによって作成されたものです。 簡単な例を挙げましょう（幸いなことに、深刻な脆弱性ではありません）：2年前、OpenIDサーバーの5つの最も人気のある実装の2つで、開発者はlife_time（秒単位のキーの有効期間）とexpires_time（秒単位のキーの有効期限）の概念を混同しました1970年1月1日）。 コードの特に重要なセクションをプロジェクトの他の参加者が見ることができるようにすることが望ましいです（OK、これもありふれたものですか？-その後、結論に進みます）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 結論 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事で伝えたかった主なアイデアは、著者が有名企業であっても、特定のプロトコルの開発者に依存しないことです。 自分で考え、自分で決めてください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     実践について少しだけでなく、記事の範囲を超えたものについても。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 公開キー基盤（PKI）は、その規模（特に、プロトコルの数）で顕著なソリューションです。 これはおそらく、Twitterのブログ見出し用の自動クロスポストサービスを作成することを学ぶべきものではありません。 また、分散システムに関しては、おそらくここにいないでしょう。 ただし、この場合でも、一般的な用語を知っておくと便利です。  <a href="http://tools.ietf.org/html/draft-ietf-pkix-roadmap-09">インターネットX.509公開鍵インフラストラクチャ：ロードマップ</a>から開始できます。 </li><li> また、今日では、Webサービス（主にSOAP上に​​構築）のセキュリティを確保するために、多数の標準が開発されています。 これについては多くの記事が取り上げられています。  （たとえば、 <a href="http://webservices.xml.com/pub/a/ws/2003/01/15/ends.html">セキュリティで保護されたWebサービス</a>は多くの関連リンクを収集しました。）したがって、ソリューションを開発する前に、既存の開発に慣れる価値があるかもしれません。 </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J77678/index.html">州内の「Hand in Hand」ツアー</a></li>
<li><a href="../J7768/index.html">HabrawikiのTODO</a></li>
<li><a href="../J77681/index.html">筋金入りのプログラマー向けの使いやすさとインターフェース設計</a></li>
<li><a href="../J77683/index.html">スタートアップをビルドします。 パート1</a></li>
<li><a href="../J77684/index.html">スタートアップをビルドします。 パート2</a></li>
<li><a href="../J7769/index.html">専用または広告を持っていますか？ だまされていますか！？</a></li>
<li><a href="../J77694/index.html">YandexとGoogle：コンテンツ広告の交換</a></li>
<li><a href="../J77695/index.html">Honeywell Users Group 2010</a></li>
<li><a href="../J77698/index.html">ビジネスレターを書かない方法</a></li>
<li><a href="../J7770/index.html">ロシアのブックマークサービスの比較レビュー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>