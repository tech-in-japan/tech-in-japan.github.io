<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌨️ 🐰 🕺🏿 凸包を見つけるためのクイックハルアルゴリズム 🔪 🤘🏼 🤟🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="定義が言うように、ある集合の凸包  最小の凸集合です  多くを含む  。 ペアごとに異なる点の有限集合の凸包は多面体です。 
  
 Quickhullアルゴリズムの1次元のケースを実装するには、関数std :: minmax_elementが適しています。 ネット上では、フラットケースのQuick...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>凸包を見つけるためのクイックハルアルゴリズム</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body">定義が言うように、ある集合の<i>凸包</i> <img src="https://habrastorage.org/files/eeb/2cf/9be/eeb2cf9be1334810ace291fafe932336.png"> 最小の凸集合です <img src="https://habrastorage.org/files/287/2d8/d4e/2872d8d4ee9b4bab8c26925725f47cf4.png"> 多くを含む <img src="https://habrastorage.org/files/eeb/2cf/9be/eeb2cf9be1334810ace291fafe932336.png">  。 ペアごとに異なる点の有限集合の凸包は多面体です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Quickhullアルゴリズムの1次元のケースを実装するには、関数<a href="http://en.cppreference.com/w/cpp/algorithm/minmax_element"><i>std :: minmax_elementが適してい</i></a>ます。 ネット上では、フラットケースのQuickhullアルゴリズムの多くの実装を見つけることができます。 ただし、任意のディメンションの場合、 <a href="http://qhull.org/">qhull.org</a>からの1つのヘビーウェイト実装のみがすぐに見つかります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     用語の横の括弧内に、英語への翻訳を示します（Tuґboのスタイルで、すみません）。 これは、用語に精通しておらず、リンクで英語のテキストを読んだり、ソースコードを扱うことを決めたりする人に役立ちます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     上記の「標準的な」実装はCで記述され（C ++バインダーがあります）、長い間（GNU OctaveおよびMATLABパッケージの一部として）広く使用されているため、十分にテストされています。 ただし、1つのQuickhullアルゴリズムのみに関連するコードを分離することにした場合、問題が発生します。 最も単純なアプリケーションの場合、もっとコンパクトなものでできるようにしたいと思います。 少し試してから、実装を作成しました（ <a href="https://github.com/tomilov/quickhull">https://github.com/tomilov/quickhull</a> ）：これは依存関係のない唯一のクラスです。 合計約750行。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> 幾何学的な概念。 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     多次元エンティティの操作を開始すると、通常の2次元および3次元のオブジェクトとの類似性が有効であることがわかります。 知識をいくらか合理化する必要があります。いくつかの新しい用語を導入し、それらの関係を明確にします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プログラマーにとって、幾何学的オブジェクトは主にデータ構造です。 最初に、幾何学的定義（厳密ではありません）を示します。 次に、データを格納し、それらを効果的に操作するのに便利な対応するデータ構造の説明を行います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     空間の次元を <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> シンプレックス（英語シンプレックス）が設定されている <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> アフィン独立点。 親和性の独立性についてさらに説明します。 これらのポイントは、頂点（Eng.units頂点、pl。頂点）と呼ばれます。 </li><li> 多面体（多面体、多面体、多面体、英語の多面体、多面体）は最小値として定義されます <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> アフィン独立点（頂点）; シンプレックス（英語の単体ポリトープ）-最も単純なケース <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> 次元のボディ、より少ない頂点を持つ多面体は必然的にゼロになります <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> 次元のボリューム。 </li><li> 平行四辺形（英語の平行四辺形）-平らな平行四辺形と平行六面体の一般化。 シンプレックスの場合、構築できます <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> 対応する平行四辺形（それらはすべて同じ体積を持ちます <img src="https://habrastorage.org/files/bb6/13a/f39/bb613af39a1c467cbef4314bc67f310b.png"> シンプレックスボリューム）、平行四辺形のジェネレーター（ベクトル）として、1つの固定頂点から残りのベクトルに出現するベクトルを取る <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> トップス。 </li><li> 凸多面体の概念（Eng。Convex polytope、convex polyhedron）ここでは説明しませんが、それについての直観的な考えはうまくいきます。 多面体の特殊なケースとしてのシンプレックスは、常に凸です。 </li><li> 飛行機の概念も説明しません。 囲まれているスペースよりも次元が1つ少ないことに気づくでしょう。 </li><li> 単体ファセットが定義されています <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> アフィン独立点（頂点）。 さらに、単体オブジェクト（凸多面体を除く）についてのみ説明するため、「単体」の定義は省略します。 続編の多くのステートメントは、単純な幾何学的オブジェクトの非縮退（すべてのポイントがペアワイズで異なる）の場合にのみ有効です。 </li><li> エッジ（英語の尾根）は2つの面の交差として定義され、 <img src="https://habrastorage.org/files/5da/04a/848/5da04a84816d4817a1bafa06a7687cc4.png"> トップ。  2つの面に共通のエッジは1つしかありません。 したがって、1つの顔に <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  rib骨を通して隣人。 </li><li> ピークが定義されています <img src="https://habrastorage.org/files/0b4/846/fd6/0b4846fd6de449a4b1aad5e1ad84255b.png"> ドット。 ここでは、ピークと頂点の概念が一致しないため、3次元空間との直感的な類似性が浮かびますが、このようなオブジェクトでは操作しません。 顔は、ピークを介して任意の数の隣接する顔を持つことができます。したがって、メモリと変換中のデータ構造の関連性を維持するコストの両方で、ピークを介した顔の隣接グラフを保存するのはコストがかかると結論付けることができます。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     多面体の表面、その境界、その境界の境界など 英語では顔と呼ばれます。 良いリソースへの<a href="http://eusebeia.dyndns.org/4d/vis/02-analogy">リンク</a>を提供します。ここでは、 <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> 次元空間、可視または観測可能なオブジェクトは <img src="https://habrastorage.org/files/5da/04a/848/5da04a84816d4817a1bafa06a7687cc4.png"> 次元オブジェクト、つまり境界 <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> 次元オブジェクト。 英語のファセットは正確に観察された顔です。 直線は常に1次元のエンティティです。 このグラデーションのポイント（頂点）はゼロ次元と見なすことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     いくつかのセットを扱う <img src="https://habrastorage.org/files/f9c/dfd/0ff/f9cdfd0ff4624b4e80120219d4f1a4ed.png"> ポイント、我々は対応するセットの検討に進むことができます <img src="https://habrastorage.org/files/1c9/c5f/677/1c9c5f67724e44f288da709192edc19d.png"> 他のすべてのポイントから1つのポイントを減算することにより、ベクトルを作成します。 したがって、この点を原点（Eng。Origin）として割り当てます。 すべてのポイントが同じ平面にある場合、平面は原点を通過し始めるようにシフトされます。 アフィニティ独立 <img src="https://habrastorage.org/files/f9c/dfd/0ff/f9cdfd0ff4624b4e80120219d4f1a4ed.png"> 線形独立性が実行されるときにポイントが実行されます <img src="https://habrastorage.org/files/1c9/c5f/677/1c9c5f67724e44f288da709192edc19d.png"> 対応するベクトルの。 ベクトルの線形独立性の定義は、よく知っていることでしょう。 だから <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  -次元空間はこれ以上選択できない <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> それらはすべてアフィン的に独立しています。 これを説明しましょう。3次元空間では、三角形（3次元シンプレックスの面-四面体）は3つの点（もちろん、1つの直線上にない）によって定義されます。 単一の平面がこれらの3点を通過します。 三角形の3つの頂点のセットに追加されたこの平面上の任意のポイントは、3つのアフィン独立ポイントの可能性を4つのアフィン依存セットに変換します。 他の次元についても同様です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     とりわけ、ハイパーボリューム（英語のハイパーボリューム）の概念を導入する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">ハイパーボリューム。</b> <div class="spoiler_text"> 多数の<i>シンプレックス</i> 、 <i>面</i> 、 <i>エッジ</i> 、 <i>ピーク</i>などから考慮されるオブジェクト。 対応するサブスペースで制限されます。 そのようなオブジェクトが占める「スペースの量」は、測定/決定/定義できます。  1次元の直接測定値は長さと呼ばれます。  2次元平面の場合、メジャーは面積と呼ばれます。 三次元のボディ-ボリューム。 この概念は、D次元ボリュームまたはDハイパーボリュームと呼ぶことで一般化できます。 ペアごとに異なる点で形成されたシンプレックスの場合 <img src="https://habrastorage.org/files/867/0a0/1eb/8670a01eb15446298cb02ef3b256425b.png">  （ポイントをリストする順序は重要です）、ハイパーボリュームは<a href="http://math.stackexchange.com/a/828854/54348">次のよう</a>に計算でき<a href="http://math.stackexchange.com/a/828854/54348">ます</a> ： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/b2b/153/9e4/b2b1539e4ead4a78a4a8a1d8a92e7272.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/78a/ec1/db9/78aec1db9be84e2094448179a1894fa9.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/c1e/ee3/802/c1eee3802ae74f2c87bad556acdf9f90.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここで、ベクトルの座標を線で書きました。 同様の式と推論を列ベクトルに与えることができます（つまり、すべての行列を転置する場合、これは結果と結論に影響しません）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     上記の式の行列式の約数は、平行四辺形を分割できるシンプレックス（すべて同じ体積）の数です。 <img src="https://habrastorage.org/files/440/542/e05/440542e0512f43449985bb17f3544893.png"> ベクトルに基づく <img src="https://habrastorage.org/files/a37/776/123/a3777612336446b8b6c8c50b17798c98.png">  。 したがって、行列式自体は平行四辺形のハイパーボリュームです。 この声明の根拠に興味がある人のために、私はグラム行列の行列式とその幾何学的解釈について読むことをお勧めします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「体積」オブジェクトのこの測定値はゼロ以外の値になり、正と負の両方になる可能性があることに注意してください。 次の考慮事項から記号の意味を理解することは難しくありません。シンプレックスの2つのポイントを交換すると、行列式の記号に変化が生じます。 ポイントの順序は、シンプレックスの「左右の向き」です。 飛行機では、想像するのは簡単です。三角形の辺が <img src="https://habrastorage.org/files/2fc/394/99f/2fc39499fdc84d3a8503d2593e634551.png"> 反時計回りに記載 <img src="https://habrastorage.org/files/674/e5c/04c/674e5c04c9c14d43aadae56d8dd47286.png"> 行列式は正です <img src="https://habrastorage.org/files/60e/55a/a10/60e55aa100a04fee847dde99542b411f.png"> そうでなければ <img src="https://habrastorage.org/files/e00/e8c/66c/e00e8c66c6354dbab96d4fe1f0dd929c.png">  -負 <img src="https://habrastorage.org/files/47f/ee8/274/47fee8274ff1485b855c4841802143eb.png">  。 四面体の場合、符号は最後から見たときに最初の3点がリストされる順序（時計回りまたは反時計回り）に依存します。 したがって、将来、幾何オブジェクトを定義するとき、ポイントの列挙の順序を固定する必要があることを受け入れる必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズムは方向付けられたハイパーボリュームの大きさの符号に関する情報のみを使用するため、行列式の前の因子を省略できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     少なくとも2つのラインが線形に依存している場合、行列式はゼロです（ポイントがペアごとに異なる、つまりラインがゼロではないことを思い出してください）。 アフィン依存点とそれらに対応する線形依存ベクトルに関する上記の推論の対応を簡単に検証できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     行列式の絶対値は、ベクトルに渡すときに減算する正確な点の影響を受けず、符号のみに影響します。 最後のポイントは常に最初のポイントから減算する必要があります。そうしないと、将来使用される同一方向の類似オブジェクトの場合、メジャーの符号は偶数次元と奇数次元で異なります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     顔など、大きすぎる空間に埋め込まれたオブジェクトのメジャーをどうするか？ 上記と同じ方法でマトリックスを作成すると、長方形になります。 このような行列の行列式は取得できません。 行ベクトルで構成される同じ行列を使用して、式を一般化できることがわかります（この一般化は<a href="https://en.wikipedia.org/wiki/Cauchy%25E2%2580%2593Binet_formula">Binet-Cauchy式に関連付けられています</a> ）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/696/52d/600/69652d600a604ca6a7e8609ab68357f1.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/c3d/9a1/289/c3d9a128986c4955ba5af9ac17447854.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/bed/a18/a2b/beda18a2b61d477d9a2e2d1c0536b831.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/e7c/a5b/967/e7ca5b96728748df88b935d04538c310.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/162/4ad/6de/1624ad6dec5341fe95ab392764324768.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アフィン的に独立したペアごとに異なる点の場合、行列式の下の行列は常に正定正方行列であり、そのような行列の行列式自体は常に正の数です。 アフィン依存点の場合、行列は特異です（つまり、行列式はゼロです）。 測定値が常に非負であり、方向に関する情報がないことは明らかです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一方では、正方行列の積の行列式は行列式の積に等しく、他方では、転置された正方行列の行列式は元の行列式と一致するため、最後の式は <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> 正方形の根を除く点、すなわち このモジュールは、空間内のポイントの相対的な方向に関する追加情報を取得するために省略できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> アルゴリズム </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     任意の次元の場合のQuickhullアルゴリズム自体は、 <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">Barber、C. Bradford</a>によって提案されました<a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">。</a>  <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">ドブキン、デビッドP。;</a>  <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">Huhdanpaa、Hannu（1996年12月1日）。</a>  <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">「凸包のクイックハルアルゴリズム。」</a>  <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">数学ソフトウェア上のACMトランザクション22（4）：469–483</a> 著者の「標準的な」C実装は、すでに言及したサイト<a href="http://qhull.org/">http://qhull.org/</a>にあります。これは、C ++インターフェイス<a href="https://gitorious.org/qhull/qhull">https://gitorious.org/qhull/qhullを</a>備えたリポジトリです。 元のソースからアルゴリズムを引用します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><pre> d + 1ポイントのシンプレックスを作成します
各ファセットF
	未割り当ての各点p
		 pがFを超える場合
			 pをFの外部セットに割り当てます
空でない外部セットを持つ各ファセットFについて
	セットの外側のFの最も遠い点pを選択する
	可視セットVをFに初期化します
	 Vのファセットのすべての未訪問のネイバー
		 pがNを超える場合
			 NをVに追加
	地平線の尾根の集合HはVの境界です
	 Hの各リッジR
		 RとPから新しいファセットを作成します
		新しいファセットをその近隣にリンクします
	新しいファセットごとにF '
		 Vのファセットの外部セット内の各未割り当て点q
			 qがF 'より大きい場合
				 qをF 'の外部セットに割り当てる
	 Vのファセットを削除します
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     凸包は面のリストです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> シンプレックスの開始。 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ご覧のとおり、 <i>開始シンプレックスから</i>開始する必要があります。 どれでも選択できます <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> アフィン独立したポイントですが、何らかの安価なヒューリスティックを使用することをお勧めします。 このステップの主な要件は、シンプレックスが可能な限り「狭く」なることがないようにすることです。 これは、浮動小数点演算が使用される場合に重要です。 元の実装では、最大および最小の座標を持つポイントが使用されます（明らかに、それらは凸包の頂点のセットにも含まれます）。 開始シンプレックスから開始して、後続の各ステップで、より大きな多面体を取得します。その不変のプロパティは常にその凸性になります。  <i>一時的な多面体</i>と呼びます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">シンプレックスを開始するための頂点検索ヒューリスティック。</b> <div class="spoiler_text"> 私の発見的手法は、ポイントの順次選択に基づいているため、次の各ポイントは以前のすべてのポイントから可能な限り離れています。  「さらに」-ある意味で、これをさらに明確にします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2つのポイントリストが維持されます：ソースリスト <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  （最初は、アルゴリズムの入力からのすべてのポイントが含まれています）およびシンプレックスのポイントのリスト <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  （最初は空です）。 セットによると <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png"> そして <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png"> あなたは多くのベクトルを置くことができます <img src="https://habrastorage.org/files/2be/5ce/624/2be5ce624d7d42e7bcf7ec8aa2ee8db5.png"> そして <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  。 これを行うには、このアルゴリズムのすべてのステップで精神的に任意のポイントを選択します <img src="https://habrastorage.org/files/c44/9d6/768/c449d6768df14bf2ac0e15fc3e726b4c.png"> 多くのうち <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  （空ではありません）、覚えてから、そこから他のすべての点へのベクトルを描画します <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  （受け取った <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png"> 含まれる要素は1つ少ない <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  ）からすべてのポイントへ <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  （受け取った <img src="https://habrastorage.org/files/2be/5ce/624/2be5ce624d7d42e7bcf7ec8aa2ee8db5.png">  ） まず、最初の（または他の）ポイントを取得します <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png"> に移動します <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  。 次に、からベクトルを探します <img src="https://habrastorage.org/files/2be/5ce/624/2be5ce624d7d42e7bcf7ec8aa2ee8db5.png"> 最大のモジュールを使用して、対応するポイントを <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png"> で <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  。 からの最初のポイント <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png"> に戻る <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  （彼女は基準なしで選ばれた）。 次のそれぞれについて <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> ポイントを探している <img src="https://habrastorage.org/files/0ce/aa9/211/0ceaa921124f417ca2a9fd18d2814d0b.png"> から <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  <i>基底の</i> <i>あるアフィン空間</i>から可能な限り遠い <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png"> から移動する <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png"> で <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  。 これを行うには、対応するポイントを探します <img src="https://habrastorage.org/files/0ce/aa9/211/0ceaa921124f417ca2a9fd18d2814d0b.png"> ベクトル <img src="https://habrastorage.org/files/8f2/349/5c4/8f23495c4c7c4c1fab26681da323d17c.png"> から <img src="https://habrastorage.org/files/2be/5ce/624/2be5ce624d7d42e7bcf7ec8aa2ee8db5.png">  <i>直交補完</i>上の<i>投影</i>モジュール <img src="https://habrastorage.org/files/3d2/148/942/3d2148942d794d1d807f904ee66f9dba.png"> ベクトル部分空間 <img src="https://habrastorage.org/files/7b0/f75/476/7b0f754769ce4ef98cdf043b2999e903.png"> 最大。 ここに <img src="https://habrastorage.org/files/7b0/f75/476/7b0f754769ce4ef98cdf043b2999e903.png">  -線形シェル <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  、つまり-ベクトル空間 ベクトル <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  （構築により）線形に独立して得られる場合、 <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png"> このベクトル空間の基礎です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     からの距離 <img src="https://habrastorage.org/files/0ce/aa9/211/0ceaa921124f417ca2a9fd18d2814d0b.png"> 前に <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  ： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/2e7/6be/624/2e76be624b7c43aa967c90717ab5d653.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ベクトルは、任意の部分空間およびこの部分空間の直交補数への射影の合計に直接分解されるため、次のようになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/ffd/070/e7a/ffd070e7a47a4a37af8d6c3ced82af82.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>正規直交基底</i>を持つ <img src="https://habrastorage.org/files/bcc/80b/03e/bcc80b03e9794bbc85be76fc2bf29845.png"> ベクトル部分空間 <img src="https://habrastorage.org/files/7b0/f75/476/7b0f754769ce4ef98cdf043b2999e903.png">  、この部分空間の直交補数への投影モジュールを計算できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/e43/8ec/253/e438ec253ca840158226b66a6df807c2.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ベクトル座標 <img src="https://habrastorage.org/files/3e5/977/4be/3e59774beffa475e93c3a924c70636ce.png"> セットからの（座標）列ベクトルで構成される（たとえばHouseholderメソッドによる）長方形行列のQR分解を実行することで取得できます。 <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  。 その結果、直交（長方形）行列Q（ <img src="https://habrastorage.org/files/20b/c16/cc9/20bc16cc945e47db9ff0ce21ed2a8cf2.png">  ）および上三角R（未使用）。 列Qはベクトルの座標です <img src="https://habrastorage.org/files/3e5/977/4be/3e59774beffa475e93c3a924c70636ce.png"> ベクトル空間の正規直交基底を形成する <img src="https://habrastorage.org/files/7b0/f75/476/7b0f754769ce4ef98cdf043b2999e903.png">  。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     でアルゴリズムを完了した後 <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png"> 位置しています <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> ポイント。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次に、顔のいわゆる<i>外部ポイントのリスト</i> （英語の外部セット）に残りのポイントを配布する必要があります-これらは、各顔に対して維持され、まだ<i>考慮され</i>て<i>い</i>ない（以下-未割り当て、英語未割り当て）ポイントのリストですシンプレックスの内部（または将来の一時的な多面体）の反対側の面に直面します。 ここでは、凸面多面体（特にシンプレックス）のプロパティを使用します。これは、空間全体を各面の平面で割ることによって得られる2つの<i>半空間の</i>うちの1つのみに存在します。 このプロパティは、ある点が凸包の面の外部点のリストのいずれにも該当しない場合、その点の内部に確実に配置されるという事実を意味します。 将来的には、アルゴリズムは、外部ポイントのリストに含まれるポイントのどれが顔の平面から最も離れているかについての情報を必要とします。したがって、外部ポイントのリストにポイントを追加するには、どれが最も遠いかに関する情報を保存する必要があります。 任意のポイントは、外部ポイントの1つのリストのみに分類されます。 漸近的な複雑さは、ポイントがリスト全体にどの程度正確に分布しているかには影響されません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この段階で、顔を設定する方法、顔までの距離を計算する方法、顔に対する点の向きを決定する方法について説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">瀬戸際。</b>  <b class="spoiler_title">フェースプレーンからポイントまでの方向距離。</b> <div class="spoiler_text"> 顔を設定するには、持っている必要があります <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> ポイント-顔の頂点。 上記の理由により、これらのポイントを整然と保管します。 さらに、必要な順序は厳密ではありません。 たとえば、ペアごとに異なるポイントの必ずしも異なるペアではない2つの交換を2回行った場合、将来の操作で意味がまったく同じ向きになります（これは通常、頂点の定数と座標から形成された行列から行列式を取得します）このようなペアの順列は結果に影響しません。  2つの可能な方向は、平面（面）の法線の2つの可能な方向に対応します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一度だけ-最初に-記号で向きを決定するために、開始シンプレックスのハイパーボリュームの値を計算する必要があります。 面に関する以降のすべての操作は、ポイントまでの指向距離（英語の指示距離）の計算のみで構成されます。 ここで、任意の次元の場合に一般化できる学校の公式を思い出すことができます。つまり、「三角形の面積は底辺、高さの積の半分です」または「ピラミッドの体積は基底面積と高さの積の3分の1です」 体と顔の尺度を削除する方法を知っているので、高さ（1次元の長さ）を表現できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/db2/cf7/238/db2cf72383bb4ea78d5f12a8d1156f42.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズムでは、固定平面（面）からポイントまでの方向付けられた距離を計算する必要があります。 この場合、分母に正の定数があることがわかります。 分子内のハイパーボリュームのみがポイントの位置に依存します（「上」または「下」）。 <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> 定数でもあります。 したがって、顔と点から構成されるシンプレックスのハイパーボリューム（または、対応する平行四辺形）の相対的な大きさのみを考慮することができます。 行列式が最も遅い方法と見なされない場合（定義により、 <img src="https://habrastorage.org/files/210/c31/3d0/210c313d0f9346d88e5b24d7dd9785ab.png">  ） <a href="https://en.wikipedia.org/wiki/Determinant">最速では</a>ありません（ <img src="https://habrastorage.org/files/cc7/50e/00b/cc750e00befc4239991d4ff466980beb.png">  ）、およびLUP分解法（英語のLUP分解）を使用すると、複雑さを達成できます。 <img src="https://habrastorage.org/files/844/1db/88c/8441db88c259424d97fbe07b6437d5df.png"> そしてまともな数値安定性。 私は、行列式の計算の複雑さがアルゴリズム全体の最終的な複雑さにどのように影響するかを評価することは想定していませんが、実験して、最悪の場合（たとえば、球（英語の球形の点）にある点の場合） <img src="https://habrastorage.org/files/acd/c86/a86/acdc86a86e4a421197a5db4cfae9423d.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）距離を推定するための行列式の計算は、計算コストが高すぎます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のアプローチは、正規化された平面方程式の使用です。</font><font style="vertical-align: inherit;">これは、</font></font><img src="https://habrastorage.org/files/caa/0be/593/caa0be5938a84e5ea7dc4a730db092e5.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平面上の</font><font style="vertical-align: inherit;">点</font><font style="vertical-align: inherit;">の座標、正規化された法線ベクトル</font><font style="vertical-align: inherit;">の座標を関連付ける一次方程式です</font></font><img src="https://habrastorage.org/files/694/ece/f55/694ecef55fbd4f048896af5eaa95c4e2.png">  （ <img src="https://habrastorage.org/files/011/4b4/5d3/0114b45d3c364d6581f2f9b6a0c96b40.png"> —  )   (. normalized normal vector)    <img src="https://habrastorage.org/files/871/9f8/9de/8719f89de882478988124f13ba29331f.png">    (. offset): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/e0e/869/273/e0e8692738514991adbf772fae96330e.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
       <img src="https://habrastorage.org/files/011/4b4/5d3/0114b45d3c364d6581f2f9b6a0c96b40.png">  ： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/c6d/35b/134/c6d35b1347174dfb8ac557fe0571e322.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <img src="https://habrastorage.org/files/871/9f8/9de/8719f89de882478988124f13ba29331f.png"> —     : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/975/fe8/9a6/975fe89a67d245b5add8a5784aba125a.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <img src="https://habrastorage.org/files/db2/cf7/238/db2cf72383bb4ea78d5f12a8d1156f42.png"> ,         , —         : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/467/f27/49a/467f2749aef94f12ad3a82a52e810380.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
             ,   ,   <img src="https://habrastorage.org/files/14c/e62/95d/14ce6295d9e046629fc3868eb6c302ed.png">  ,  — . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
            <img src="https://habrastorage.org/files/5f4/2e5/6e3/5f42e56e3af645919037968aa7387431.png"> そして <img src="https://habrastorage.org/files/1e2/74b/4ba/1e274b4bad4a496082310cf407b9f6b6.png">     <img src="https://habrastorage.org/files/c80/d9e/efa/c80d9eefa7f442518568acb94c20408a.png"> -  ()  . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
              <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> : <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">        .       <a href="http://en.cppreference.com/w/cpp/algorithm/inner_product"><i>std::inner_product</i></a> ,           ,    ,    —  <img src="https://habrastorage.org/files/b94/3ba/f5a/b943baf5a4ac4679a98cb1e7e6c78eba.png">  。           , ,  ,    ,     ,               . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これで、面の平面を説明することができますが、あいまいさが1つあります。開始シンプレックスの面の頂点のリストで、ポイントの列挙の順序を選択する方法です。著者は、頂点のリストを順序付けしません。そうしません。任意であるが固定された次数の頂点に対して平面の方程式を設定すると、この平面に対する内部ポイント（英語の内部ポイント）の方向がわかります。つまり、指向距離が計算されます。距離が負の場合、超平面の法線の座標と原点からのオフセットで符号が変わります。または、フラグの値を設定して、顔が上下逆になっていることを示します（英語を反転）。凸多面体の内部点は、少なくとも</font></font><img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その頂点（すべての頂点を取得した場合、いわゆる重心）の</font><font style="vertical-align: inherit;">算術平均に</font><font style="vertical-align: inherit;">なります。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始シンプレックスの面の向きを変更します。</font></font></b> <div class="spoiler_text">           (        )  .       ,        ,     ( <img src="https://habrastorage.org/files/1a3/78c/a07/1a378ca079224f41bae61d9107065742.png"> )   ( <img src="https://habrastorage.org/files/e77/cb5/e71/e77cb5e717e242be9556b5f03dab48b0.png">  ）      ,   <img src="https://habrastorage.org/files/1a3/78c/a07/1a378ca079224f41bae61d9107065742.png">  «»    <img src="https://habrastorage.org/files/f6f/401/0f0/f6f4010f0e9d41e19491ee9114f30012.png">    ,         (   ).         ,        <img src="https://habrastorage.org/files/a21/429/41c/a2142941c8a14aacaaa185f984f894e7.png"> (  <img src="https://habrastorage.org/files/7cc/3fb/509/7cc3fb509d3949da84244c32a1b76c52.png">   ).          . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
            <img src="https://habrastorage.org/files/867/0a0/1eb/8670a01eb15446298cb02ef3b256425b.png">    <img src="https://habrastorage.org/files/359/596/1c0/3595961c0444421f83885a1e649d4500.png">  。                ,     ,          .    ,             .    (   /   ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ,    ,      <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">    ,      ,         .     ,             . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面ごとに、頂点のリスト、外部ポイントのリストを指定することに加えて、隣接する（英語の隣接リスト）面のリストを指定する必要があります。</font><font style="vertical-align: inherit;">顔ごとに正確に含まれます</font></font><img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"> 要素。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始シンプレックスには</font></font><img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面</font><font style="vertical-align: inherit;">が含まれて</font><font style="vertical-align: inherit;">いるため、その面のいずれについても、他のすべての面（</font></font><img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピース）</font><font style="vertical-align: inherit;">が隣接する面のリストに</font><font style="vertical-align: inherit;">含まれる</font><font style="vertical-align: inherit;">ことは明らかです</font><font style="vertical-align: inherit;">。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> メインループ。 </font></font></h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これで、メインループで作業できる一時的なポリゴンができました。メインループでは、この一時的なポリゴンが完成し、多面体の外側に1つのポイントがなくなる瞬間が来るまで、ますます多くのスペースと元のセットのポイントを「キャプチャ」します。次に、このプロセスについて詳しく説明します。つまり、それが私の実装でどのように機能するかです。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインループはフェイスループです。各反復で、外部ポイントの空でないリストを持つ面の中から、最良の面が選択されます</font></font><img src="https://habrastorage.org/files/a82/a1e/139/a82a1e139d9248cbbb58685e3debe880.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の最良の面）。外部ポイントのリストから最も遠いポイントが他のフェースよりもフェースから遠いという意味で最高です。外部ポイントの空でないリストを持つ面がなくなると、サイクルが終了します。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインサイクルのボディでは、選択した面は凸包の意図的に非面として削除されます。</font><font style="vertical-align: inherit;">しかし、最初に、彼女は「コンポーネントを理解します」。</font><font style="vertical-align: inherit;">外部ポイントのリストから最も遠いポイントが抽出されます</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-おそらく凸包の上部です。</font><font style="vertical-align: inherit;">残りのポイントは、割り当てられていないポイントの一時的なリストに移動されます。</font></font><img src="https://habrastorage.org/files/41b/832/432/41b8324326f74a989bdfc203b6eb21a0.png">  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに、Facesのリストから始まる</font></font><img src="https://habrastorage.org/files/a82/a1e/139/a82a1e139d9248cbbb58685e3debe880.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接するFacesの</font><font style="vertical-align: inherit;">リストでは</font><font style="vertical-align: inherit;">、一時的な多面体のFacesの隣接グラフがバイパスされ、各Facesが既に訪れた（Visit）Facesのリストに追加され、ポイントからの可視性がテストされます</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png">  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面がポイントから見えない場合、</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その隣接する面はそれ以上進みません。隣接する面の中で次の可視面に不可視ポイントがある場合、</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">境界の可視面のリストになります（水平線の前ではなく、水平線の前-「水平線を超えて」）。ただし、すべての隣接する顔が表示されている場合、そのような顔は削除用の顔のリストに追加されます。面の隣接グラフを走査した後、境界に表示される面のリストと削除する面のリストには、ポイントから見えるすべてが含まれます</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファセット。これで、リストからすべての顔が削除されました。さらに、削除された各顔は、その隣接する隣接顔のリストから削除されません。これは安全です。これは、隣接する面が将来的に隣接する面のリストから見える境界であっても、ポイントから見えない</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エッジ</font><font style="vertical-align: inherit;">への近接に関する情報のみが使用されるため</font><font style="vertical-align: inherit;">です。削除する面のリストに続いて、境界に表示される面のリストがスキャンされます。境界に表示される各面は「解析」され（その後、隣接する面のリストと頂点のリストが必要になります）、削除されます。境界の可視面ごとに、新しい面が作成されます（1から</font></font><img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい顔のリストに追加されます。</font><font style="vertical-align: inherit;">この場合、隣接する顔のリストがスキャンされ、このリストから見えない各顔について、特定の可視境界を持つ共通のエッジが検索されます。</font><font style="vertical-align: inherit;">非表示エッジと境界表示エッジに共通の頂点（つまり、共通エッジの頂点）は、さらに、境界表示面の頂点のリストに書き込まれた順序で、新しい面の頂点のリストに書き込まれます。</font><font style="vertical-align: inherit;">ちなみに、エッジ（Eng。Horizo​​n ridge）は、ポイントから見える一時的な多面体の表面のその部分の地平線の一部です</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png">  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> このエッジに属さない境界可視面の唯一の頂点がポイントに置き換えられます </font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい面の頂点のリストでは、残りの頂点は、表示されている面の境界の頂点の（順序付けられた）リストと同じで、同じ場所にあります。したがって、構築された新しい面の頂点のリストは正しい向きを保証します。つまり、正規化された平面方程式を計算するとき、法線は一時的な多面体の外側に向けられ、オフセット値は正しい符号を取得します。すべての境界表示面が処理された後、新しい面のリストが作成されます。これらの面の超平面方程式は、それらの頂点のリストを作成した直後に計算できます。また、新しい面を作成する場合、隣接する面のリストに1つの面、つまり新しい面の頂点のリストを作成するときに境界の可視面に隣接していた対応する非表示面を追加できます。明らかに残り</font></font><img src="https://habrastorage.org/files/5da/04a/848/5da04a84816d4817a1bafa06a7687cc4.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りの新しい顔の中から隣接する顔を探す必要があります。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">判明したように（</font></font><a href="https://code.google.com/p/gperftools/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Performance Tools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からプロファイラーでサンプリングするとき</font><font style="vertical-align: inherit;">）、アルゴリズムは、大きな次元および/または悪い入力データの場合（つまり、ほとんどのポイントが凸包の頂点である場合）に新しい顔の隣接する顔の検索に費やします。私の実装では、最初はアルゴリズムは非常に簡単でした：新しい面のリストからの面のすべての可能なペア（2つのネストされたループ）がソートされ、1つの不一致を持つ頂点リストの順序（ポイントの入力リストからの番号による）の比較が</font></font><a href="http://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さ</font><a href="http://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference"><i><font style="vertical-align: inherit;">れました</font></i></a><font style="vertical-align: inherit;">（修正されたアルゴリズム</font><a href="http://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference"><i><font style="vertical-align: inherit;">std :: set_difference</font></i></a><font style="vertical-align: inherit;">または</font></font><a href="http://en.cppreference.com/w/cpp/algorithm/set_difference"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: set_symmetric_difference</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font>それは <img src="https://habrastorage.org/files/5a6/031/fe9/5a6031fe9a674b41b32cbb9c2b8ef718.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較、ここで</font></font><img src="https://habrastorage.org/files/f9c/dfd/0ff/f9cdfd0ff4624b4e80120219d4f1a4ed.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は新しい顔の数です。しかし、将来、</font><font style="vertical-align: inherit;">このボトルネックで</font><font style="vertical-align: inherit;">順序付けられた連想配列（</font></font><a href="http://en.cppreference.com/w/cpp/container/set"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: set</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を使用して、隣接するものを検索する速度で（バイナリ=）のペアを獲得することができました</font><font style="vertical-align: inherit;">。一般に、このタスクに関連する知識の分野全体があります（隣人の決定）-これは</font></font><a href="http://en.wikipedia.org/wiki/Locality-sensitive_hashing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">局所性に敏感なハッシュ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。元の</font><b><font style="vertical-align: inherit;">qhull</font></b><font style="vertical-align: inherit;">実装で</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュのみ（LSHではなく）が使用されます。その中には、各エッジ（2つの面）に個別のデータ構造（エッジのエッジのリストと、エッジの「上」と「下」に関する情報）が保存され、各フェイスにはエッジのリストが含まれます。面のすべてのエッジの面（新しい面のリストからの面）の近傍を決定するために、それらの頂点の配列のハッシュの関連付けられた順序なし配列が作成され（1回スキップして）、1つの破棄された頂点</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png">  ） それは <img src="https://habrastorage.org/files/e2a/e70/908/e2ae70908193468e9a49d7a8040881fa.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">節約ハッシュ。ハッシュの衝突（およびそれに続くリストの完全な一致）がある場合、（明らかに）これらの2つの面には共通のエッジがあり（ハッシュは、ハッシュテーブルを削減するために削除できます）、それらのそれぞれは、他の隣接する面のリストに追加できます。標準ライブラリもSTLも</font></font><a href="http://www.boost.org/doc/html/hash/reference.html"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュコンバイナ</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのツールを持っていないため、この方法は使用しません</font><font style="vertical-align: inherit;">（更新。</font></font><a href="http://stackoverflow.com/questions/5889238/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最良の選択</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はXORのみで</font><font style="vertical-align: inherit;">あるという情報を受け取りました</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">私自身は</font><font style="vertical-align: inherit;">、</font><a href="http://en.cppreference.com/w/cpp/container/vector"><i><font style="vertical-align: inherit;">std :: vector &lt;std :: size_t&gt;の</font></i></a></font><a href="http://en.cppreference.com/w/cpp/utility/hash"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: hash</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">、正当性に関する理論的な情報の正当化なし</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">特化し</font><font style="vertical-align: inherit;">たくありませんでした。それが私が連想</font><b><font style="vertical-align: inherit;">順序</font></b><font style="vertical-align: inherit;">付けを使用した理由です</font></font><a href="http://en.cppreference.com/w/cpp/container/vector"><i><font style="vertical-align: inherit;"></font></i></a><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接する面を検索するためのリブコンテナー。</font><font style="vertical-align: inherit;">その結果（明らかに）、アルゴリズムの私の実装は、</font><font style="vertical-align: inherit;">速度で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qhull</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を漸近的に</font><font style="vertical-align: inherit;">失う</font></font><img src="https://habrastorage.org/files/df3/d68/1d6/df3d681d6482417496dd59e07dfb9c5e.png"> 前に <img src="https://habrastorage.org/files/03a/497/6b1/03a4976b11c14634b02addfdbc12da7f.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 回（さまざまな入力データ用）。 </font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 比較テスト。 </font></font></h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     例は、パッケージマネージャー（Ubuntu 14.04 LTS）を介してインストールされたQuickhull <b>qhull</b>アルゴリズムの「標準的な」実装です。 同じ<i>qhull-bin</i>パッケージから入力を生成するために、 <i>rbox</i>ユーティリティが<b>使用されました</b> 。  <i>rbox tn D4 30000 s&gt; /tmp/qhuckhull.txtコマンド</i>は、4次元球体上の30,000ポイントの座標を持つファイルを作成します。  <i>rbox tn D10 30 s&gt; /tmp/quickhull.txtコマンド</i>は、10次元の球体上の30点の座標を持つファイルを作成します。 プログラムが消費するメモリ量は、 <i>-vスイッチを</i>使用した<i>/ usr / bin / time</i>ユーティリティの出力で確認できます。  <i>/ usr / bin / time -v bin / quickhull /tmp/quickhull.txtの出力|</i>  <i>head -7</i>は、私の実装のメモリとプロセッサ時間の両方の消費量（ファイルの読み取りと端末への出力のクリア）、およびoutput <i>/ usr / bin / time -v qconvex s Qt Tv TI /tmp/quickhull.txt-</i> 「標準的な」 <b>qhull</b>実装用。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     凸包の面の数の一致により、実装の正確さを判断します。 しかし、（2次元および3次元モードで）デバッグするために、段階的に（ <i>一時停止</i>コマンドを使用して） <b>gnuplot</b>形式のアニメーション出力を実装し<b>ました</b> 。 コミットのどこかです。 プログラムの出力は、凸包と<b>gnuplot</b>形式で表される入力ポイントの番号付きセットです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さらに、私は<b>rboxの</b>類似物である<b>randombox</b>ユーティリティを何とか書き始めました（しかし、完成しませんでした）。  <b>randomboxは</b> 、均一に分布していないポイントを生成する<b>rbox</b>とは異なり、空間に均一に分布しているポイント（英語の均一な空間分布）を生成するユーティリティとして考案されました。  <b>randombox</b>は、単一の「ダイヤモンド形」多面体の表面に、単位球（英語の単位球）、ボール（英語の球）、シンプレックス（ポイントのある空間に埋め込むことができる任意の次元）で囲まれたポイントのセットを生成できます。ユニットダイヤモンド）、ユニットキューブ（Eng。ユニットキューブ）内、平行四辺形内、標準ユニットシンプレックス（Eng。ユニットシンプレックス）内、およびコーン（Eng。コーン）またはシリンダー（Eng。シリンダー）のボリュームに多くのポイントを投影します）  （空間に囲まれた）任意のシンプレックス内に均一に分布する座標を生成するために、インターネット上で（Dirichlet分布を介して）数値的に安定したアルゴリズムを見つけました。 その結果、最初のものを選択しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プロジェクトルートから<b>gnuplot</b>を使用して、凸包を「感じ」させるには、コマンド<i>rbox n D3 40 t |を</i>入力します<i>。</i>  <i>bin / quickhull&gt; /tmp/quickhull.plt &amp;&amp; gnuplot -p -e "load '/tmp/quickhull.plt'"</i> 。  <i>rbox n D3 40 tは</i> 、境界キューブ内に40ポイント<i>を</i>生成します <img src="https://habrastorage.org/files/f41/6ce/72e/f416ce72ee6b40baa7ace420288a905f.png">  （英語の境界ボックス）。 キー<i>t</i>は、PRNGの初期値として現在の時間（秒単位）の使用を指定します。 球上の点を取得するには、キー<i>s</i>を追加する必要があります。 非単純な面がどのように壊れているかを見るのも興味深いです： <i>rbox n D3 c</i> -cube、 <i>rbox n D3 729 M1,0,1-</i> <img src="https://habrastorage.org/files/62a/68d/fb6/62a68dfb6efe4c37934a96c31d0ea0e0.png"> ノード全体にあるポイント。 らせんの凸包は美しく見えます（英語のらせん）： <i>rbox n D3 50 l</i> 。 面と同一平面上にある多数のポイントを同時に配置する場合、アルゴリズムオブジェクトの構築時に設定される<i>eps</i>定数が、結果の正確性に大きな役割を果たし始めます。 たとえば、 <a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><i>std :: numeric_limits &lt;value_type&gt; :: epsilon（）</i></a>を小さな値として使用する場合、64個の整数ポイント<i>rbox n D3 64 M3,4の</i> 「回転した」立方体の場合、アルゴリズムは正しくない幾何学的オブジェクトになります。凸多角形であること。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 結果または遅延TL; DR。 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私の仕事の結果は、C ++でのQuickhullアルゴリズムの実装でした。これは非常にコンパクトで、 <a href="http://qhull.org/">qhull.org</a>での実装よりもそれほど遅くありません。 このアルゴリズムは、STLで慣例となっているように、入力で空間の次元の値、小さな定数<i>epsの</i>値、およびイテレータのペアで指定された範囲として表されるポイントのセットを受け取ります。 最初の段階で、 <i>create_simplex</i>は開始シンプレックスを構築し、入力ポイントを含むアフィン（サブ）空間のポイントベースを返します。 基底の点の数が点を含むユークリッド空間の次元よりも大きい場合、凸包を完成させるアルゴリズムを実行する必要があります。 出力では、アルゴリズムは入力セットの凸包の面を記述するデータ構造の配列を提供します。これが答えです。 失敗した場合、すべてのポイントを含む低次元の部分空間のポイントベースがあります。  Householderアルゴリズムを使用すると、ポイントの最高座標を無効にしながら、何らかの方法で入力セットを回転させることができます。 そのような座標は破棄でき、Quickhullアルゴリズムは低次元の空間に既に適用できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 用途 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムには多くの用途があります。 凸包自体を見つけることに加えて、凸包、 <a href="http://www.youtube.com/watch%3Fv%3DxYzULMoyaQk">ドロネー三角形分割</a>と<a href="http://www.youtube.com/watch%3Fv%3DFIPu9_OGFgc">ボロノイ線図の</a>間に<a href="http://algolist.manual.ru/maths/geom/chull_dv.php">関連</a>があるという事実のため、「間接」アルゴリズムの適用を見つけることは難しくありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この実装<a href="https://hal.inria.fr/hal-01104587/file/DeClope_isbra.pdf">はすでにいくつかの人にとって便利になっており</a> 、感謝の気持ちで（謝辞で）支払われました。これは非常に素晴らしいことです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> アップデート。 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2015年6月24日： <a href="">Kurt Mehlhorn、StefanNäher、Thomas Schilz、Stefan Schirra、Michael Seel、Raimund Seidel、およびChristian Uhrig</a>のアルゴリズムに従って、結果の幾何学的構造の凸性の検証を追加しました<a href="">。</a>  <a href="">幾何学的プログラムのチェックまたは幾何学的構造の検証。</a>  <a href="">Procで。</a>  <a href="">12周年。</a>  <a href="">ACMシンポジウム。</a>  <a href="">計算。</a>  <a href="">Geom。、ページ159〜165、1996年</a> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2015年6月24日：結果の多面体の面には、対応する頂点が反対側（英語の反対側）になるように配置された隣接する面の頂点とインデックスのセットが含まれるようになりました。 これにより、構造が使用しやすくなる場合があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      06/24/2015：ハッシュを使用して、新しく受け取った顔の近傍を決定します。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J245209/index.html">Drupal＃1の世界からの興味深い資料のダイジェスト</a></li>
<li><a href="../J245211/index.html">乾燥摩擦の問題におけるラグランジュ形式</a></li>
<li><a href="../J245213/index.html">Web開発者のためのいくつかの興味深く有用なこと＃34</a></li>
<li><a href="../J245215/index.html">Highload ++ 2014-さまざまな悪い方法で大規模グラフデータを処理するのが好きなスピーカーの目を通して</a></li>
<li><a href="../J24522/index.html">サイトのFlashナビゲーション</a></li>
<li><a href="../J245223/index.html">先週の第137号（2014年12月1日〜7日）のウェブ開発とITの世界からの興味深い資料のダイジェスト</a></li>
<li><a href="../J245233/index.html">PHPのExcelでの処理とレポート</a></li>
<li><a href="../J245237/index.html">Sergey Chernyshev：「毎年、ウェブは遅くなるだけです」</a></li>
<li><a href="../J245241/index.html">ビジネスインテリジェンスの聖杯を見つける</a></li>
<li><a href="../J245243/index.html">MODX RevolutionのコンポーネントDropboxファイルソース</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>