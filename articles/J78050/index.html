<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌯 👎 🙏🏻 SignalsyMQ-PHP + Redis（および小さなZend Framework）のシンプルで高速なメッセージキュー 🐥 🧕🏾 🏵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="読者への挨拶。 現在、現在支配的なMVCモデルとは対照的に、 信号アーキテクチャ （信号/スロット）に基づいて独自のフレームワークを開発しています。 彼が私たちのスタートアップで戦闘の慣らしを受けている間に、この間、ライブラリが不足していることに気付きました-実際のタスクと将来のビジョンは、異なる機...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>SignalsyMQ-PHP + Redis（および小さなZend Framework）のシンプルで高速なメッセージキュー</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/78050/"><img align="left" src="http://abrdev.com/wp-content/uploads/2009/08/1250198491_signal.png" width="128" height="128">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     読者への挨拶。 現在、現在支配的なMVCモデルとは対照的に、 <a href="http://abrdev.com/%3Fp%3D563">信号アーキテクチャ</a> （信号/スロット）に基づいて独自のフレームワークを開発しています。 彼が私たちのスタートアップで戦闘の慣らしを受けている間に、この間、ライブラリが不足していることに気付きました-実際のタスクと将来のビジョンは、異なる機能が必要であるが、1つのテーマで統一されていることを示しています-リアルタイムで多くのクライアントへの情報の処理と配信（はい、コメットに似たもので、彼もそこにいます）。 したがって、次のプロジェクトの主要なコンポーネントとなる、高速で柔軟かつスケーラブルなメインコンポーネントであるメッセージキューの実装を試みることが決定されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     どうしたの？  SignalsyMQ Alphaは、PHP / Redis / Zend Frameworkベースのメッセージキューです。 <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     メッセージキューについてはすでに書きました（ <a href="http://abrdev.com/%3Fp%3D503">レビューの最初の記事</a> 、 <a href="http://abrdev.com/%3Fp%3D545">2番目</a> ）が、すべてのシステムを批判的にレビューし、それらのいくつかを試してみると、メインアプリケーションのプラットフォームにできるだけ近い、このニッチが小さく、柔軟で構成可能であることに気付きました（この場合、PHP）、オープンで無料のままです。 標準メッセージ（JSON形式で、アプリケーション内の単なる連想配列）を処理し、メッセージ配信の柔軟な構成、キューの永続的な保存、およびそれらとの非常に高速な処理を提供するシンプルなサーバーがありません。 同時に、シンプルなプロトコルと、一般的に最大限のシンプルさが必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これに最も近いのは、Rubyベースの製品である<a href="http://github.com/starling/starling/tree/master">Starling MQ</a>と<a href="http://abrdev.com/%3Fp%3D471">MemcacheQ</a>です。 ところで、両方のシステムはmemcacheプロトコルで動作します。これは、異種環境に埋め込む機能にプラスの影響を与えます。 しかし、memcacheqはその開発ポリシーに恥ずかしかったのですが、Twitterの使用経験はありますが、それはかなり具体的な製品であり、絶対に必要です。別のプラットフォーム。 したがって、最良の伝統では、メッセージキューの独自の実装を記述することが決定されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://code.google.com/p/redis/">Redis</a>プロジェクトは、構造化データを保存および処理するための開発機能を備えた非常に高速かつ柔軟なNoSQLシステムの出発点として取り上げられました（Habréでこれについて書く時間はありませんでした）。  2番目の「クジラ」は<a href="http://zendframework.ru/articles/rediska-redis-key-value-database-client">Rediskaでした-</a>便利な構文と多くの興味深い機能（たとえば、複数のサーバー、組み込みのシリアル化、サーバー間でのキーの配布など）をサポートするRedisと連携するための<a href="http://zendframework.ru/articles/rediska-redis-key-value-database-client">PHPライブラリ</a>ですが、ライブラリは活発に開発されています。したがって、機能は常に追加されます）。  3番目の「クジラ」は<a href="http://framework.zend.com/">Zend Frameworkで</a> 、現在ほとんどのプロジェクトで使用していますが、ここではサポートの役割しか果たしていません（いくつかのユーティリティクラスが使用されています）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ZFには、メッセージキューの独自の実装-Zend_Queueが既にあることがすぐに<a href="http://framework.zend.com/manual/en/zend.queue.html">わかり</a>ます。これは、通常のPHP配列から始まり、MemcacheQ、データベース、Zend Platformで終わる、メッセージを保存するためのさまざまなバックエンドをサポートします。 ただし、実際には、MemcacheQで最も有望なインターフェイスを試すことができませんでした。メッセージフローが密集している場合にデータベースを操作することは、単に不可能です。スクリプト全体が失敗するまで、作業は非常に遅くなります。  Zend_Queueインターフェース自体は非常に抽象的です。私の場合は、いくつかの高レベルの関数が必要だったため、既存のコードを大幅に拡張する必要があります。 ちなみに、RediskaライブラリにはRedis上でキューを操作するための特別なアダプターがありますが、1週間苦労し、テストケースが動作しなかった後、私は最終的に決定しました-それが私のシステムを書いています！ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、一般的なアーキテクチャと機能を決定しましょう。 基本的な概念は、メッセージ、キュー（チャネル）、サーバー、およびストレージです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <strong>メッセージ</strong>は特定のデータ構造であり、この例では、保存する情報を含む連想配列です。 メッセージは、いくつかのサービスフィールドと本文で構成されます。 メッセージの本文には、受信者に送信されるデータ自体が保存されます。最も重要なことは、変更されていないことです。 サービスフィールドは処理中に変更される場合があります。 これまでのところ、私に必要なフィールドは、メッセージのタイプ（任意の行）、メッセージのソース（また行）、メッセージを配信するチャネル、およびメッセージを作成するためのタイムスタンプです。 メッセージ本文もフィールドの1つですが、空の場合もあります。特定の受信者に対してのみ意味があり、システム全体の責任は単に保存して配信することです。 </li><li>  <strong>キュー</strong> （チャネル）は一意のアドレスであり、メッセージが配信されるキューの名前です。 私は最もシンプルで最も理解しやすい形式のアドレス指定-URLのようなものを取りました。 たとえば、/ users / aleksは、ユーザーaleksのメッセージキューです。 内部でいくつかの追加処理が発生しますが、これは他のスクリプトがキューで動作する方法には影響しません。 また、一度に複数のキューにメッセージを送信することもできます-このためには、メタ文字「*」（任意の数の文字）、「？」  （任意の単一文字）および '[a..z]'-配信されるメッセージの名前に含まれる必要がある任意の文字セット。 これは私の開発が同じZend_Queueと比較して好意的です-たとえば、名前がaleksであるすべてのユーザーにメッセージを簡単に送信できます（ユーザー名でキューを呼び出す場合）。 キューは、長さ（そこに格納できるメッセージの最大数）によっても特徴付けられます。 メッセージがメモリ（さらにはシリアル化された形式）に保存されることを考えると、メモリの消費を考慮する必要があるため、プロジェクトの詳細に基づいてキューの長さを選択してください。 キューがオーバーフローした場合、最も古いメッセージが削除されます。 </li><li> 実際、 <strong>キューサーバー</strong>はライブラリスクリプトそのものです。 現在の実装はRedisサーバーで直接動作します。次のステップは専用サーバーの作成です。 つまり、クライアントアプリケーションはソケットを介してサーバーに接続し、メタ情報付きのメッセージを送信します（少なくとも、メッセージを送信するチャネルを示します）。残りはサーバーのビジネス（またはデーモン）です。 機能を拡張するために、ソケット、XML / JSON-RPC、HTTP-REST、SOAPなどを介して、さまざまなデータ形式（シリアル化）といくつかの作業プロトコルの両方をサポートする予定です。 </li><li>  <strong>ストレージ</strong> -現在のバージョンでは1つまたは複数のRedisサーバーを実行していますが、将来的には、Zend_Queueと同様に、メッセージを保存するためのいくつかのオプションを実装する可能性があります。 </li></ul> アーキテクチャとRediska_Queueとの違いについてのもう1つの発言は、ソースから理解しているように、速度のために貴重な配布プロパティを配置することです。 たとえば、格納されているすべてのキューの配列（メッセージではなく、キューの名前のみ）を返すgetQueuesコマンドは、キューリストのローカルコピーを処理します。 したがって、最初のキューが機能している間に別のクライアントが新しいキューを作成した場合、彼はそれを知りません。  Webアプリケーションの場合、ページが形成されている間にリクエストが処理されるとき、これは重要ではないかもしれませんが、デーモンとして動作し、多くのクライアントからの多くのキューとコマンドを処理できるメッセージサーバーが必要です。 これには追加のリソースが必要ですが、Redisのおかげですが、すべての操作には複雑さの非常に良い指標があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、一般的なAPIは、Zend_Queueインターフェースに可能な限り近いいくつかのメソッドで構成されていますが、いくつかの拡張機能があります。これについては以下で説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <strong>getInstance（$ config）</strong> -ライブラリとアダプターの1つのインスタンスを使用してRedisにアクセスするため、すべての作業は、既に初期化されたインスタンスの作成または使用を決定する静的メソッドを介して行われます。 構成では、サーバーパラメーター（アドレス、ポート）が設定され、複数のサーバーの場合はシリアル化機能とキー配布メカニズムが設定されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>  private $ _options = Array（
   'maxQueues' =&gt; 100000、//キューの最大数
   'maxMessagesPerQueues' =&gt; 1000、// 1つのキュー内のメッセージの最大数
   'expireQueues' =&gt; 15552000、//キューの最大有効期間は180日間
   'expireMessages' =&gt; 604800、// 1つのメッセージの最大有効期間
   'maxMessageLength' =&gt; 32768、//メッセージの最大サイズ（シリアル化後）
   'log' =&gt; false、//指定されている場合、メッセージを記録するZend_Logオブジェクト、
   'redis' =&gt;配列（
	 'namespace' =&gt; 'smq_'、//キーを減らすために選択されたキーの名前空間
	 'サーバー' =&gt;配列（
 	   array（ 'host' =&gt; 'localhost'、//ホスト
	           'port' =&gt; 6379、//ポート
	           'weight' =&gt; 1、//キー配布のためのサーバーの重み
	           'password' =&gt; '' //パスワード
	  ）
   ）、
  'keyDistributor' =&gt; 'crc32'、//キー配布タイプ
  'serializer' =&gt;配列（ 'Signalsy_MQ'、 '_ serialize'）、
  'unserializer' =&gt;配列（ 'Signalsy_MQ'、 '_ unserialize'））
 ）; </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ロガー（Zend_Logを使用）を設定して、すべての重要なイベント、エラー、さらにはメッセージ自体を記録することもできます（デバッグではなく、プロダクションでRedisにデータ損失または複製を防ぐために組み込まれたappendonly.logメカニズムを設定するだけで十分です）バックアップサーバーへ）。 </li><li> <strong>_serialize / _unserialize-</strong>格納されたメッセージをリポジトリに追加し、そこから取得するときに使用される組み込みのシリアル化関数。  Redisは値として数値と文字列のみを保存できるため、保存する前にデータをシリアル化する必要があります。 これはサーバー自体によって透過的に行われます。これらのアクションのメソッドを指定するだけでよく、そうでない場合はデフォルトでPHPシリアル化が使用されます。 将来的にはクライアントとリポジトリの間の中間層の数を最小限に抑えたいため、AJAXアプリケーションにはより便利で「ネイティブ」なJSONを選択しました。 次のバージョンでは、Zendインキュベーターの新しいZend_Serializerコンポーネントが使用され、他のアルゴリズムを使用できるようになります。 さらに、PHPに保存されたデータは、JSONパーサーがある任意の言語の他のプログラムで読み取ることができます。これは、分散システムにとって非常に重要です。 </li><li>  <strong>createQueue</strong>は、名前が渡されるキューを作成するメインメソッドです。 最初に、名前の正確さがチェックされ（さまざまな特殊文字が削除されるなど）、システム内のそのようなキューの存在もチェックされます。 作成後、最初のサービスメッセージがキューに配置され、タイムスタンプが示されます。 これは、Redisが最初の要素を追加するときに空のリスト（リストデータ構造）を自動的に作成するため、空の文字列などの公式なものを指定しないように、特別なユーティリティメッセージタイプでキューを初期化することが決定されたためです。 </li><li>  <strong>isExists-</strong>指定されたキューがサーバー上に存在するかどう<strong>かを</strong>確認します。  Zend_Queue用のRediskaアダプターの実装とは対照的に、データベースメモリ内のそのようなオブジェクトの存在の確認やデータ型の一致など、より深刻なチェックを実行します。 </li><li>  <strong>count-</strong>キュー内のメッセージの数を取得できます。 </li><li>  <strong>deleteQueue-</strong>サーバーストレージからキューを削除します。キュー内のすべてのメッセージも削除されます。 おそらく、クラッシュの場合にデータが関連するように、データベースの状態の強制記録をそのような変更で初期化する必要があります。 </li><li>  <strong>send</strong>は、指定されたチャネルにメッセージを送信するメインメソッドです。 必須パラメーター-メッセージに加えて、キューシステムの正しい動作を保証する追加のチェックを指定できますが、作業が大幅に遅くなる可能性があります。  skipCheckQueueLengthは、構成で設定された制限を超えた場合にキューの長さとその切り捨てをチェックする役割を果たします。 切り捨てられると、最も古いメッセージが削除されます。 このパラメーターが整数の場合、この要求でこのようなチェックが実行される可能性を設定しますが、これはサーバーへの1つまたは2つの要求を必要とするため、速度と信頼性の間の一種の妥協です。  skipCheckQueueExistsパラメーターを使用すると、キューの存在のチェックを無効にできます。 前述のように、メッセージは標準的な配列であり、シリアル化後にキューに格納されます。 必須チャネルフィールドで、メッセージを配置するキュー（またはマスクを使用した複数）を指定します。 マスクが指定されている場合、指定されたパラメーターに一致するすべてのキュー名をこのマスクから抽出し、メッセージ内のチャネルフィールドを調整した後、ループ内の各キュー名にメッセージを追加します。 現時点では、サービスヘッダーの変更や分析は行われません。メッセージの本文自体も、文字列または正しいシリアル化を可能にするPHPの任意のデータ型のいずれかです。 繰り返しますが、他の実装との主な違いは、1回の呼び出しで複数の（またはすべての）キューにメッセージを送信できることです。 ロギングオプションが設定されている場合、メッセージはZend_Logを使用してログに書き込まれます </li><li>  <strong>receive</strong> -2番目に重要な操作-キューから1つ以上のメッセージを受信します。 ここではマスクはサポートされなくなり、メッセージは特定の指定されたキューからのみ受信できます。 また、サーバー上のキューの存在を確認する必要があります（特に最大のパフォーマンスを得るには、特にRedisサーバーで作業する人がいない場合、これらのすべての確認は作業の初期化時に1回のみ実行できます）。 受信するために、受信できるメッセージの最大数を示しますが、実際には、たとえばキューに同じ数のメッセージがある場合、受信できるメッセージの数は少なくなります。 別の興味深いオプション（最適化に関して機能が完全になるまで非表示にしません）は、指定した日付以降に送信されたメッセージのみを受信することです。 たとえば、過去1時間に送信されたメッセージを100個まで受信したいとします。 最初に、指定された数のメッセージがサンプリングされ、次に作成時間の基準を満たさないメッセージをチェックして破棄します。 キューからのメッセージは読み取り専用であり、読み取り直後に削除されないことに注意してください-このためには、特別なコマンドを使用する必要があります。 キュー自体は永続的であり、そのステータスはクライアントによって手動で（またはキューの長さをチェックした結果として）変更されるだけです。 将来的には、期限切れメカニズムが実装されます。Redisで最初にサポートされますが、クライアントパーツではまだ実装されていません（個々のリストアイテム用）。 </li><li>  <strong>deleteMessage-</strong>キューからメッセージを削除します。 </li><li>  <strong>getQueues-</strong>サーバーで使用可能なすべてのキューのリストを表示できます。 </li><li>  <strong>getQueuesByPattern-</strong>指定されたパターンに一致するキューのリストを表示します（メタキャラクター「*」、「？」、および文字グループ[a..z]を使用します） </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     正直なところ、 <a href="http://code.google.com/p/signalsy-mq/">プロジェクトのソースコードは、アクセス可能</a>ですが、実際の作業の準備ができていません。むしろ、単なるプロトタイプと最初のアルファバージョンです。 まだ最適化されていない場所、Zend_Queueのピースなど、さまざまなドキュメントがまだありますが、それらのインターフェイスには、不完全に考え出された作業とデータ構造のアルゴリズムがあります（たとえば、deleteMessageには、チャネルサービスフィールドには2つのパラメーター、キュー名とメッセージが必要です）メッセージには既に彼のキューの名前などがあります）。 それにもかかわらず、現在のコードはすでに結果を示しており、動作しており、実験に適しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     現在パフォーマンスについて話すことも本当に不可能ですが、Amazon EC2スモールインスタンス（32ビット、Debian、PHP 5.2.11、Redis 1.1.9）を使用していくつかのテストを実施しました。ランダムキュー（1000の多数のメッセージを選択的に記録するモードのシングルスレッドサーバーメッセージおよび各バッチ100）は、1秒あたり1500-3000メッセージ内の速度を示します（記録のため、他のシステムはまだサーバー上で回転しているため、変動は負荷に大きく依存します。また、このモードではRedis自体の保存間隔が設定されるため、非常に敏感です） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各クライアントが少数のメッセージと1つのキューで動作するが、多数の並列クライアントがある場合、原則として、 <a href="http://porteightyeight.com/2009/11/09/redis-benchmarking-on-amazon-ec2-flexiscale-and-slicehost/">この構成のテストによると</a> 、引き出し可能な最大値（1秒あたり5から7千メッセージ、テストとサーバーが同じマシン上にある場合）。 マルチスレッドを使用して、Redisを別のサーバーに移動し、サーバーを可能な限り他のタスクからアンロードすることで、より大きな結果を得ることができます。さらに、パフォーマンスはサーバーのCPUパラメーターに依存します-大きいインスタンス（2コアと7 GB RAM）はすでに5-6より速い速度（もちろん、これは単なる平均的な指標であり、現実とはかけ離れています）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらは実験です。 メッセージキューのトピックは興味深いものです。たとえば、仕事でZFを積極的に使用している開発者であっても、Zend_Queueコンポーネントとそのアプリケーションについてほとんど誰も知らないなど、さらに記事を書く必要があります。 さて、サーバーには多くの改善と改善があり、それをネットワークデーモンに変え、さまざまなプロトコル（おそらくMQの標準であるStomp、AMQP）で動作する特別なサーバーを構築し、バックグラウンド保存中の輻輳のレプリケーションとアカウンティングを設定し、いくつかの並列サーバーなど あなたはそれについて読んでみたいですか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J78037/index.html">www.betterworldbooks.comで本を購入する</a></li>
<li><a href="../J7804/index.html">太っている人はソーシャルネットワークに集まります</a></li>
<li><a href="../J78040/index.html">プロの再訓練</a></li>
<li><a href="../J78045/index.html">@importを使用しない別の理由</a></li>
<li><a href="../J7805/index.html">しかし、あなたにいちじく！ トムスクのシビルテレコムからの制限はありません！</a></li>
<li><a href="../J78055/index.html">学生のオブジェクト思考の発達</a></li>
<li><a href="../J7806/index.html">新世代のおもちゃは脳をスキャンします</a></li>
<li><a href="../J78062/index.html">Thunderbird +コンテンツタブ= Google Waveサポート</a></li>
<li><a href="../J78063/index.html">AppleのiTunes LPを無料でお試しください</a></li>
<li><a href="../J78068/index.html">phpUnderControl 0.5.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>