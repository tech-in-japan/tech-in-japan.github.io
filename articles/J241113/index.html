<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏻 🏙️ 📋 This Poodle Bites：SSL 3.0での穴の使用 🦐 👴🏿 👩🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Webセキュリティに関心のある人は、POODLEと呼ばれるもう1つのSSLの脆弱性を既に認識しています。 この脆弱性の詳細と、攻撃者が保護されていると思われるユーザーデータを取得する方法を詳細に調べ、Mail.Ru Groupチームがこの獣をどのように処理したかについても説明します。 
  
  
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>This Poodle Bites：SSL 3.0での穴の使用</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> <a href="http://habrahabr.ru/company/mailru/blog/241113/"><img src="https://habrastorage.org/files/430/c33/f9d/430c33f9de9b4455964f4402de6965fb.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Webセキュリティに関心のある人は、POODLEと呼ばれるもう1つのSSLの脆弱性を既に認識しています。 この脆弱性の詳細と、攻撃者が保護されていると思われるユーザーデータを取得する方法を詳細に調べ、Mail.Ru Groupチームがこの獣をどのように処理したかについても説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      POODLEを使用するメカニズムの包括的な説明は、 <a href="https://www.openssl.org/~bodo/ssl-poodle.pdf">このPOODLEバイト：SSL 3.0フォールバックのエクスプロイトにあり</a>ます。 以下に、この記事の翻訳を示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     悪意のある犬の活動の詳細にあまり興味がない人には、POODLEがSSL 3の脆弱性であることを思い出してください。SSL3は、2番目の10を生き残ったプロトコルの古いバージョンです。 脆弱性に対処するには2つの方法があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> サーバーに、TLS経由で接続できない場合のハンドシェイクプロセス中のSSL3へのロールバックを禁止するパッチを適用します。 キャッチは、パッチがサーバーとクライアントにある場合にのみ、この方法が機能することです。 現在、これはGoogle Chrome（2014年2月から）でのみ実装されており、次のFirefoxのアップデートで計画されています。 ユーザーの安全をある程度確保することは、ユーザー自身にかかっていることがわかります。 </li><li> サーバーでSSL 3を無効にします。これで終わりです。 シンプルでエレガントですが、「しかし」1つだけです。 ほとんどのブラウザーはTLSバージョン1.0以降を使用しますが、Internet Explorerバージョン6と呼ばれる過去の遺産を手放す準備ができていない人々がまだ世界中にいますが、これは単にデフォルト構成のプロトコルの新しいバージョンをサポートしていません。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     統計によると、IE6を介して、0.2％のユーザーがMail.Ru Mailにアクセスしています。 絶対的な意味ではこれはそれほど小さな数字ではありませんが、安全性は何よりも重要だと考えています。 そのため、メール、クラウド、カレンダー、認証センター、および業務用のMail.RuでSSL3を介してクライアントに接続する機能を無効にしました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      IE6ユーザーの場合、これはMail.Ru Mail、およびこのPOODLEと戦う方法を選択した他のサービスが利用できなくなることを意味します。  Habrの視聴者の中にIE6のフォロワーが多いことはまずありませんが、最新のテクノロジーにあまり親しくない親relativeや友人がブラウザを更新したことを確認することをお勧めします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     脆弱性から保護するための最初の方法を選択したサービスの場合、おめでとうと定期的に自動更新するChromeユーザーであれば、保護されています。 他のブラウザを使用する場合は、少なくともパブリックWi-Fiにアクセスする場合は、この場合は脆弱であるため、新しいChromeを使用することをお勧めします。 なんで？ これは、以下の翻訳で見つけることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      SSL 3.0 [RFC6101]は時代遅れの安全でないプロトコルです。 実際の問題のほとんどを解決する際に、後継プロトコルであるTLS 1.0 [RFC2246]、TLS 1.1 [RFC4346]、およびTLS 1.2 [RFC5246]に置き換えられましたが、古いシステムとの相互作用のためにSSL 3.0との後方互換性を保持しています。 これにより、サーバーに新しいバージョンのプロトコルを導入する際のクライアントデバイスの問題を回避できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ただし、クライアントとサーバーの両方がTLSをサポートしている場合でも、多くのクライアントは古いプロトコルを使用してサーバー互換性のバグに対処するため、SSL 3.0のセキュリティレベルは依然として問題です。 そして、攻撃者がこの状況を悪用し、SSL 3.0プロトコルをクラックする方法について説明したいと思います。  <a href="http://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2014-3566">POODLE</a>攻撃（ダウングレードされたレガシー暗号化のパディングOracle）について話しているため、たとえば、セキュアHTTPクッキーまたはHTTP認証ヘッダーのコンテンツを傍受することが可能です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     また、このような攻撃に耐えるために、クライアントとサーバーで実行するアクションを推奨します。 単にSSL 3.0を無効にすることが互換性の理由から適切でない場合、TLSの既存のバージョンではTLS_FALLBACK_SCSVを使用する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  POODLE脆弱性の説明 </h1> サーバーの古いバージョンとの互換性を確保するために、多くのTLSクライアントはダウングレードダンスを使用します。最初に、最新バージョンのプロトコルを使用して通信を確立しようとします。 接続が確立されない場合、新しいプロトコルが使用されますが、古いプロトコルが使用されます。 両当事者がサポートする通常のバージョン決定手順（たとえば、クライアントがTLS 1.2を介してアクセスし、サーバーがTLS 1.0に従って応答する）とは対照的に、上記のスキームはネットワークエラーまたは悪意のあるアクションにより開始できます。 クライアントとサーバー間のネットワークを制御する攻撃者が介入し、プロトコルバージョンTLS 1.0以上との接続を妨害すると、クライアント自身がSSL 3.0の使用に切り替わります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このプロトコルは、RC4ストリーム暗号化、またはCBCモードでのブロック暗号化を使用します。  RC4の主な問題はオフセットの存在です。同じデータ（パスワードやHTTP Cookieなど）を送信するために使用される接続と暗号化ストリームが多いほど、解読に役立つトラフィックからより多くの情報を抽出できます。 以下に、SSL 3.0を使用してCBC暗号化に対する効果的な攻撃を組み合わせる方法を示します（攻撃者がクライアントとサーバー間のネットワーク交換を変更できる場合）。 同時に、BEASTやLucky 13の脆弱性とは異なり、ここでは回避策はありません。 安全でないSSL 3.0プロトコルのみを使用しているため、強力な暗号化を確保するため、使用は避けてください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      SSL 3.0でのCBC暗号化の最も深刻な問題は、パディングが任意であり（最後のバイトを除く）、MAC（メッセージ認証コード）に適用されないことです。  SSL 3.0では、メッセージは最初にMACを使用して署名され、次にパディングで補完され、その後ブロック暗号で暗号化されるため、復号化中に追加の整合性を完全に確認することはできません。  1〜Lバイト（Lはバイト単位のブロックサイズ）のパディングを使用して、暗号化の前に整数のブロック数を取得します。  （暗号化の前に）L-1の任意のバイトとそれに続くL-1の値を持つ1バイトで構成されるパディングブロック全体がある場合、保護を突破するのが最も簡単です。 着信暗号化レコードC <sub>1</sub> ... C <sub>n</sub>を処理するには、初期化ベクトルC0も指定されている場合（各C <sub>i</sub>は1ブロック）、受信側は最初にP <sub>1</sub> ... P <sub>n</sub>をP <sub>i</sub> = D <sub>K</sub> （C <sub>i</sub> ）⊕C <sub>i-として決定します1</sub> （D <sub>K</sub>は、セッションキーKを使用した1ブロックの復号化を表します）。 次に、メッセージの最後のパディングが検証および削除され、最後にMAC署名が検証および削除されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後のブロックC <sub>nが</sub>完全にパディングであり、攻撃者がC <sub>n</sub>を同じストリームの以前の暗号化されたブロックC <sub>iに</sub>置き換えた場合、D <sub>K</sub> （C <sub>i</sub> ）⊕C <sub>n-1</sub>であれば、メッセージは受け入れられます。 L-1の最後のバイト。それ以外の場合はおそらく拒否されます。これにより、パディングOracleの攻撃が可能になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ラボの条件以外では、攻撃者がBEAST攻撃手法を使用してSecure HTTP Cookieを復号化する場合、SSL 3.0の弱点をMITM攻撃で使用できます。  POODLE攻撃を実行するには、次のものが必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  www.evil.comで<a href="http://www.evil.com/">JS-を</a>実行して、被害者のブラウザーがHTTPS要求を含むCookieを<a href="http://example.com/">https://example.comに</a> <a href="http://www.evil.com/">送信する</a>ようにし<a href="http://example.com/">ます</a> </li><li>  <a href="http://example.com/">example.com</a>が変更されたレコードを受け入れる可能性が十分に大きくなるように、SSLレコードをインターセプトして変更し<a href="http://example.com/">ます</a> 。 この場合、攻撃者はCookieから1バイトを解読できます </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各ブロックCに16バイト-C [0] ... C [15]が含まれているとします。 また、Cookieのサイズを認識したと仮定します（以下では、Cookieのサイズを知らずに攻撃を行う方法を示します）。  SSL 3.0のMACサイズは通常20バイトなので、CBCレイヤーの下の「暗号化されたPOST」は次のようになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      POST / <i>パス</i> Cookie： <i>名前=値</i> ... \ r \ n \ r \ n <i>本文</i> ǁ20 <i>バイト</i> MACǁ <i>パディング</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     攻撃者はリクエストのパスと本文を制御するため、次の2つの条件を満たすリクエストを開始できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> パディングはブロック全体を埋めます（C <sub>nで</sub>暗号化） </li><li> まだ知られていない最初のCookieバイトが、以前のブロックの最後に置き換えられます（C <sub>iで</sub>暗号化されます） </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次に、攻撃者はC <sub>n</sub>をC <sub>iに</sub>置き換え、この変更されたレコードをサーバーにリダイレクトします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ほとんどの場合、サーバーはそれを受け入れず、攻撃者は新しいリクエストを送信します。 時々（およそ256回の試行ごとに）サーバーは変更されたレコードを受け入れ、攻撃者はD <sub>k</sub> （C <sub>i</sub> ）[15]⊕C <sub>n-1</sub> [15] = 15、したがってP <sub>i</sub> [15] = 15⊕C <sub>n -1</sub> [15]⊕C <sub>i-1</sub> [15]。 これにより、以前は不明であったCookieの最初のバイトが開きます。 攻撃者は次のバイトに移動し、同時にリクエストのパスと本文のサイズを変更して、リクエストのサイズは変わらないが、ヘッダーの場所は移動するようにします。 これは、Cookieが完全に復号化されるまで行われます。 予想される合計ワークロードは、1バイトあたり256 SSL 3.0要求です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     パディングはペイロードの正確なサイズを隠すため、Cookieのサイズはすぐにはわかりません。 しかし、リクエストGET /、GET / A、GET / AA、...により、攻撃者はブロックの境界を計算できます。 アドオンのサイズ、したがってCookieのサイズを調べるには、最大16個のこのようなクエリで十分です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> 推奨事項 </h1> 上記の攻撃にはSSL 3.0を介した接続が必要であるため、クライアントまたはサーバー（または両側）で接続を無効にすると、トラブルを完全に回避できます。 少なくとも一方がSSL 3.0のみをサポートしている場合、薬は無力であり、安全でない暗号化を避けるために深刻な更新が必要です。  SSL 3.0のみがサポートされているプロトコルではなく、無効になっていない場合、ダウングレードダンス（サーバーとの互換性のためにクライアントを下位バージョンに切り替える）で攻撃が可能です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     古いシステムで定期的に作業する必要がある場合、SSL 3.0を無効にすることは実用的ではありません。  TLS_FALLBACK_SCSVメカニズムは、異なるプロトコルバージョンの一般的な問題を解決します。これは、SSL 3.0互換性をサポートするシステムにとって特に重要であると考えています。 以下に、TLS_FALLBACK_SCSVの操作アルゴリズムを示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ダウングレードダンスを使用するTLSクライアントは、各ダウングレードプロトコルバージョン中にClientHello.cipher_suitesに値0x56、0x00を含める必要があります。 この値は、ダウングレード攻撃が発生した場合、更新されたサーバーが接続の確立を拒否できる信号として機能します。 クライアントは、常に次の下位バージョンにアップグレードする必要があります（たとえば、TLS 1.2で開始した場合、TLS 1.1、TLS 1.0、SSL 3.0の順に試してください）。  TLS_FALLBACK_SCSVの場合、バージョンをスキップすると接続が失敗することもあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TLSサーバーは、着信接続でClientHello.cipher_suitesの0x56、0x00が検出された場合、ClientHello.cipher_versionをサーバーでサポートされている最高のプロトコルバージョンと比較します。 サーバーがクライアントよりも高いバージョンをサポートしている場合、接続はエラーで中断します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このようなTLS_FALLBACK_SCSVの使用により、SSL 3.0は古いシステムで作業する場合にのみ使用されるという確信が得られます。攻撃者はプロトコルのダウングレードを開始できなくなります。 両側がSSL 3.0を許可しているが、一方がTLS_FALLBACK_SCSVをサポートしていない場合、攻撃は依然として可能です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> 参照資料 </h1><ul><li>  [BEAST] T. Duong、J。Rizzo：“ <a href="https://www.google.com/search%3Fq%3D%2522Here%2BCome%2BThe%2BXOR%2BNinjas%2522">Here Come The⊕Ninjas、</a> ” 2011。 </li><li>  [draft-ietf-tls-downgrade-scsv-00] B.Möller、A. Langley：「プロトコルダウングレード攻撃を防ぐためのTLSフォールバックシグナリング暗号スイート値（SCSV）」、Internet-Draft <a href="https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00">draft-ietf-tls-downgrade-scsv -00、2014</a> 。 </li><li> [Lucky13] NJ AlFardan、KGパターソン：「 <a href="http://www.isg.rhul.ac.uk/tls/Lucky13.html">Lucky Thirteen：Breaking the TLS and DTLS Record Protocols</a> 」、IEEE Symposium on Security and Privacy、2013年。 </li><li>  [RC4biases] NJ AlFardan、DJ Bernstein、KG Paterson、B。Poettering、JCN Schuldt：「 <a href="http://www.isg.rhul.ac.uk/tls/">TLSおよびWPAでのRC4のセキュリティについて</a> 」、USENIX Security Symposium、2013年。 </li><li>  [RFC2246] T.ディークス、C。 アレン：「TLSプロトコルバージョン1.0」、 <a href="http://www.ietf.org/rfc/rfc2246.txt">RFC2246</a> 、1998年。 </li><li>  [RFC4346] T. Dierks、E。Rescorla：「トランスポート層セキュリティ（TLS）プロトコルバージョン1.1」、 <a href="http://www.ietf.org/rfc/rfc4346.txt">RFC4346、2006</a> 。 </li><li>  [RFC5246] T. Dierks、E。Rescorla：「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、 <a href="http://www.ietf.org/rfc/rfc5246.txt">RFC5246</a> 、2008年。 </li><li>  [RFC6101] A.フライアー、P。カールトン、P。  Kocher：「Secure Sockets Layer（SSL）Protocol Version 3.0」、 <a href="http://www.ietf.org/rfc/rfc6101.txt">RFC6101、1996</a> （2011年にHistoric RFCとして公開）。 </li><li>  [tlscbc] B.Möller：「SSL / TLSでのCBC暗号スイートのセキュリティ：問題と対策」、 <a href="http://www.openssl.org/~bodo/tlscbc.txt">http</a> ：//www.openssl.org/~bodo/tlscbc.txt、2004年。 </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J241103/index.html">Pythonプロジェクトでクローンを視覚化する</a></li>
<li><a href="../J241105/index.html">#MBLTDev 2014のTinkoff Bank</a></li>
<li><a href="../J241109/index.html">輸送モニタリング：CIS対West</a></li>
<li><a href="../J24111/index.html">Nokia N800：OSを内部カードに転送する方法。</a></li>
<li><a href="../J241111/index.html">CoffeeScriptのリトルブックの翻訳</a></li>
<li><a href="../J24112/index.html">RIT-2008からビデオを検索</a></li>
<li><a href="../J241125/index.html">内部からのSystem-NS</a></li>
<li><a href="../J24113/index.html">テストとしてのHabr</a></li>
<li><a href="../J241133/index.html">サンプルのSFMLアプリケーションを使用して、EclipseでC ++プロジェクトをセットアップする</a></li>
<li><a href="../J241135/index.html">HTMLインポートの概要</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>