<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏼 👸🏽 ✌🏻 並べ替えについて（バブル、クイック、コーム...） 👨‍🎨 👩🏻‍🔬 ♠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事の主な目的は、初心者プログラマーです。 一般的な並べ替えについて、およびインターネットの見出しで言及されている記事の海について、なぜもう1つ必要なのですか？ たとえば、ハブに関する良い記事があります： バブルソートとすべてすべて 。 第一に、あまり良いものはありません。第二に、この記事では「...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>並べ替えについて（バブル、クイック、コーム...）</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/357640/"> この記事の主な目的は、初心者プログラマーです。 一般的な並べ替えについて、およびインターネットの見出しで言及されている記事の海について、なぜもう1つ必要なのですか？ たとえば、ハブに関する良い記事があります： <a href="http://habrahabr.ru/post/204600/">バブルソートとすべてすべて</a> 。 第一に、あまり良いものはありません。第二に、この記事では「なぜ、何、どのように、なぜ」という質問に答えたいと思います。なぜソートが必要なのですか？ まず、データの検索と表示用。 未ソートのデータを使用するタスクには、解決が非常に困難なものと、不可能なものがあります。 例：単語がアルファベット順にソートされているスペルチェック辞書。 そうでない場合は、正しい単語を見つけてください。 サブスクライバーがアルファベット順にソートされている電話帳。 並べ替えがオプションであり、あまり必要ではない場合でも、並べ替えられたデータを使用すると便利です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a> どのような種類のデータをソートしますか？ 比較と交換を使用して、配列内の整数データをソートします。 つまり 配列のm [i]とm [j]（i &lt;j）の要素を比較し、j番目がi番目より「小さい」場合、それらを交換します。 結果として、配列は昇順でソートされます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>注</b> ：比較するので、m [j] / 10 &lt;m [i] / 10です。 これは、同じキーを持つアイテムがどのようにソートされるかを確認するために行われます。 この比較では、30 &lt;40、ただし30 = 31 = 32 ...安定（または安定した並べ替え）は、同じ比較キーを持つ要素の順序を変更しません（この例では、比較キーは/ 10要素の値の整数部分です） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     以下は初期（未ソート）配列です。 <table><tbody><tr><td>  50 </td><td>  32 </td><td>  40 </td><td>  31 </td><td>  20 </td><td>  30 </td><td>  10 </td></tr></tbody></table> ソート済み： <table><tbody><tr><td>  10 </td><td>  20 </td><td>  32 </td><td>  30 </td><td>  31 </td><td>  40 </td><td>  50 </td></tr></tbody></table> 注：要素32、31、30の順序が変更されました。 ソートは安定していません（安定していません）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事で使用されているすべての並べ替えは、いくつかの要素を比較し、それらが正しい順序になっていない場合は変更します。 それらはどう違うのですか？ 比較する要素のペアを選択する方法が異なります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     以下は、Cのソート手順の例です。 どこでも、最初のパラメーターは配列のアドレス、2番目は配列内の要素の数です。 プロシージャの外側のループはパスと呼ばれ、内側のループは単純にループです。 <h4> 簡単な仕分け </h4> パスは配列のすべての要素を反復処理し、ループ内で現在の要素と後続のすべての要素を比較します。 <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sorto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *m,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// , , ...  { int tmp; for (int i=0;i&lt;n-1;++i) { //  for (int j=i+1; j&lt;n;++j) { //  if (m[j]/10&lt;m[i]/10) { // j- ,     i- tmp=m[i]; m[i]=m[j]; m[j]=tmp; } } } }</span></span></span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 作業結果 <table><tbody><tr><td>  10 </td><td>  20 </td><td>  32 </td><td>  31 </td><td>  30 </td><td>  40 </td><td>  50 </td></tr></tbody></table> シンプルな並べ替えに加えて、実装が簡単で安定しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     短所-それは非常に遅いので 多くの比較操作があります。  n個の要素はそれぞれ後続のすべての要素と比較されるため、比較の数は〜n * n / 2です。  n = 100000の場合、比較は50億です。 確かに、n = 1000の場合、「唯一」の比較は50万であり、最新のコンピューターは1秒未満でこれを行うことができるため、少量でこのソートが適しています.1つの重要なマイナスがある場合-データがほとんどソートされている場合（10万の要素のうち、10のみがアウトオブプレース）、すべて同じように、動作時間はほとんど変わりません、なぜなら 比較操作が多くなります。アルゴリズムを改善して、 <h4> バブルソート </h4>  「バブル」であり、「バブル」でもあります。内側のループは配列を何度も繰り返し、現在の要素を前の要素と比較します（したがって、実行は1から始まります）。現在の要素が小さい場合は、前の要素と再配置します。 順列の場所は変数kに格納され、kのパッセージの終わりにインデックスがあり、そこから配列がソートされます。 <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *m,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp,k; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(n&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  ,     k=0; //   for (int i=1; i&lt;n;++i) { if(m[i]/10&lt;m[i-1]/10) { tmp=m[i-1]; m[i-1]=m[i]; m[i]=tmp; k=i; //       } } n=k; //  k   } }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 最悪の場合（元の配列が逆の順序で並べ替えられた場合、同じn * n / 2の比較が得られます。最高の場合と良い場合のどちらですか？最良の場合は、配列が完全に短縮された場合です。その後、最初のパスで何も再配置されませんパッセージの終わりにnに0（k = 0）が割り当てられ、2回目のパスはありません。100,000パスの代わりに1つだけです！素晴らしいですが、配列が並べ替えられてもまったく並べられない場合はどうでしょう。たとえば、並べ替えられた配列の最小要素と最大要素を並べ替えて、問題のある「アレイ（30-  32は同じキーを持っています）： <table><tbody><tr><td>  50 </td><td>  20 </td><td>  32 </td><td>  31 </td><td>  30 </td><td>  40 </td><td>  10 </td></tr></tbody></table>  1パスの最初のステップでは、「20」が「50」と比較され、交換が行われます。 次のステップでは、「32」が「50」と再び比較されます（現在は「20」の位置を占めています。その結果、最初のパスの終わりに「50」が終わりに置き換わり、残りはすべて1ポジションを配列の先頭に移動します。最初の位置が上にあり、下の位置が下にあると想像すると、通過の結果として最も重いものが下になり、最も軽いものになります。ある記事では、重い要素は「野ウサギ」と呼ばれ、軽い要素は「カメ」と呼ばれます。 オード「ウサギ」は、より重要なウサギ（バトンに乗って走る）に出会うか、その場所に着くまで、最後まで（またはdrれ）走ります。 、あなたはあなたの場所に到達するためにnパスを必要とします。最も重い（「ペレット」）は1回のパスで素早くownれ、最も軽い（「バブル」）はゆっくりとポップアップします。通路。 最軽量が配列の最後にある場合、配列内の要素と同じ数のパスが必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     彼らがそれほど干渉しないように、「カメ」をどうするか。 救助に来ます <h4> シェーカーソート </h4>  <b>泡の選別で重い要素がすぐに沈み、軽い要素がゆっくりと浮くのは</b>なぜですか？ 比較サイクルは配列の先頭から末尾に移動し、重い要素を「ドラッグ」するためです。 そして、最後から最初に移動すると、肺がすぐに現れ、重い肺がゆっくりと沈みます。  1回のパスで最も軽いものが最後から最初に移動します。 偶数パスでのシェーカーのソートは、最初から最後まで移動し、奇数セットでは、問題の配列は3パスでソートされます。 ほぼソートされたアレイの場合、シェーカーのソートは「バブル」よりもはるかに高速ですが、ランダムにソートされたソースアレイの場合、ゲインは通常それほど大きくありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> ヘアブラシを並べ替える </h4> または櫛。 繰り返します<b>が、なぜバブルがゆっくりポップアップするのでしょうか？</b> 通過中に彼は1ポジションに移動するためです。 そして、なぜ彼は1ポジションしか動かないのですか？ 隣接する要素が比較および再配置されるためです。 それでは、隣接する要素ではなく、距離s（各パスで徐々にsを減らす）にある要素を比較してみましょう。 このアイデアを実践に移すと、櫛でソートすることになります。 <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *m,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp,k; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s=n; <span class="hljs-comment"><span class="hljs-comment">//    long long cnt=0; while(n&gt;1) { s/=1.247f; //    .      80%   , //         20% if (s&lt;1) s=1; // 0   ,  1 k=0; //   for (int i=0; i+s&lt;n;++i) { // ,    ( s  )   if(m[i]/10&gt;m[i+s]/10) { tmp=m[i]; m[i]=m[i+s]; m[i+s]=tmp; k=i; } ++cnt; } if (s==1) //  1,    .   n=k+1; } }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> アイデアは単純なようで、アルゴリズムは複雑ではありませんが、結果は印象的です。 櫛の並べ替えは、バブル/シェーカーよりもはるかに高速であることが判明し、「迅速な」qsort並べ替えを追い越すことさえできます。 しかしマイナスがあります-それは安定していません（直感的に明らかです）。 <h4>  Qsortクイックソート </h4> 配列のクイックソート機能は非常に簡単です。 <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   qsort int fcomp(const void *i, const void *j) { return (*(int *)i)/10 - (*(int *)j)/10; } void sortq(int *m,int n) { qsort(m,n,sizeof(int),&amp;fcomp); }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 標準のqsortクイックソートを使用するため、単純です。 与えられたアルゴリズムをもう一度見てみましょう。 全体で、要素のペアm [i]とm [j]が選択され、比較されます。 しかし、m [i]とは何ですか？ これは、整数mの配列のi番目の要素、または「アドレスAi = m + i * &lt;sizeof（int）&gt;にある要素」です。 したがって、j番目の要素はアドレスAj = m + j * &lt;sizeof（int）&gt;にあります。 そのため、アドレスAiとAjの要素を比較し、Aj &lt;Aiの場合はそれらを再配置します（適用する比較演算の意味ではこれよりも少ない）。 したがって、qsort関数は、配列（最初のパラメーターとして渡される）から要素を選択、比較、および再配置する一種の並べ替えプロセッサです。 当然、配列内の要素の数を知る必要があり、2番目のパラメーターによって渡されます。  qsortはi番目の要素の位置をどのように決定しますか？ 非常に簡単-i * &lt;バイト単位の要素サイズ&gt;を配列アドレスに追加します。 この&lt;size in bytes&gt;は、3番目のパラメーターによって渡されます。 わかりましたが、qsortはどのように要素を比較しますか？ 彼女は自分自身を比較するのではなく、アドレスが4つのパラメーターで渡される比較関数fcompを使用します。  qsortが内部アルゴリズムでiおよびj番目の要素を比較する必要があると判断すると、アドレスを1および2パラメーターとしてfcomp関数に渡し、fcomp関数は比較結果を返します&lt;0、= 0、&gt; 0 2番目のパラメーターは等しいかそれ以上です。  qsortがi &lt;jであるがfcomp（＆m [i]、＆m [j]）&gt; 0である場合、彼女は単純に配列内の要素を交換します（要素のサイズは知っていますが、内容は重要ではありません）。 <h4> ソート時間10,0001アイテム </h4>  Intel i5プロセッサ（3.3 GHz）を搭載したコンピューターで100001要素を含む配列の並べ替え時間を測定してみましょう。時間は秒単位で示され、分数はパスの数を示します（クイック並べ替えの場合は不明です）。順序付けられた、最初と最後の要素のみが再配置された）絶対的なリーダー。 理想的には、このデータの「グラウンド」です。 しかし、ランダムデータでは、combとqsortによる並べ替えはライバルにチャンスを与えません。 問題のある配列でのバブルソートでは、単純に順列操作の数が桁違いに少ないため、ランダムに比べて速度が2倍になります。 <table><tbody><tr><th> 仕分け </th><th> シンプル </th><th> バブル </th><th> シェーカー </th><th> ヘアブラシ </th><th> 高速（qsort） </th></tr><tr><td> 安定した </td><td>  + </td><td>  + </td><td>  + </td><td>  - </td><td>  - </td></tr><tr><td> ランダム </td><td>  23.1 / 100000 </td><td>  29.1 / 99585 </td><td>  19.8 / 50074 </td><td>  0.020 / 49 </td><td>  0.055 </td></tr><tr><td> 問題のある </td><td>  11.5 / 100000 </td><td>  12.9 / 100000 </td><td>  <b>0.002 / 3</b> </td><td>  0.015 / 48 </td><td>  0.035 </td></tr><tr><td> 逆 </td><td>  18.3 / 100000 </td><td>  21.1 / 100000 </td><td>  21.1 / 100001 </td><td>  0.026 / 48 </td><td>  0.037 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして、原点に戻って、バブルソートと、ソートプロセスを直接見てみましょう。 最初のパスで重い要素（50）が最後まで運ばれる方法をご覧ください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/163/216/d2a/163216d2ae714cd7b261ec3590687caa.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     比較されたアイテムは緑のフレームで表示され、再配置されたアイテムは赤のフレームで表示されます <h4> 公開後の追加 </h4> 私はqsortが悪いとか遅いとは思わない-それは十分に速く、機能的であり、可能であれば使用すべきである。 はい、彼女は比較関数を呼び出すのに時間を費やさなければならず、「インプレース」を比較する「櫛」に道を譲りました。  <b>この遅れは重要ではあり</b>ませ<b>ん</b> （qsortからのバブルの遅れと比較してください。これは配列の成長とともに増加します）。 ここで、数値ではなく、特定のフィールドのある種の複雑な構造を比較し、この構造を1000バイトで構成する必要があります。 配列に10万個の要素を配置し（100mbは何か）、qsortを呼び出します。  fcomp関数（比較関数）は必要なフィールドを比較し、結果はソートされた配列です。 同時に、qsort要素を再配置する場合、1000バイトのフラグメントを3回コピーする必要があります。 そして今、「小さなトリック」-ソース要素への10万リンクの配列を作成し、このリンク配列の先頭をqsortに渡します。  qsortリンクを交換する場合、リンクは1000ではなく4バイト（64ビット8）であるため、これらの4/8バイトを変更する必要があります。 もちろん、パラメータとして要素のアドレスではなく要素のアドレスのアドレスを受け取るため、fcompを変更する必要があります（ただし、これは単純な変更です）。 しかし、今では、いくつかのソート関数を作成できます（それぞれが構造体フィールドでソートします）。 また、必要に応じて、複数のリンクの配列を作成できます。  qsortが提供する多くの可能性があります！ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ところで、オブジェクト自体の代わりにオブジェクト参照を使用すると、qsortが呼び出されるときだけでなく、ベクター、セット、マップなどのコンテナーを使用するときにも役立ちます。 <h4> 比較と交換の数 </h4> 次の表は、比較操作の数/各ソートの交換の数を示しています。  qsortの場合、交換の数は不明であるため、比較の数のみが表示されます。 ランダム配列の場合、qsortの比較の数は最小限であることがわかります。 <table><tbody><tr><th> 仕分け </th><th> シンプル </th><th> バブル </th><th> シェーカー </th><th> ヘアブラシ </th><th> 高速（qsort） </th></tr><tr><td> ランダム </td><td>  5'000'050'000 / 1'131'715'503 </td><td>  4'999'702'086 / 2'507'142'238 </td><td>  3'341'739'679 / 2'507'142'238 </td><td>  4'489'129 / 714'533 </td><td>  1'915'414 </td></tr><tr><td> 問題のある </td><td>  5'000'050'000 / 199'999 </td><td>  5'000'050'000 / 199'999 </td><td>  299'997 / 199'999 </td><td>  4'395'305 / 91'829 </td><td>  1'588'741 </td></tr><tr><td> 逆 </td><td>  5'000'050'000 / 5'000'050'000 </td><td>  5'000'050'000 / 5'000'050'000 </td><td>  5'000'050'000 / 5'000'050'000 </td><td>  4'395'305 / 233'210 </td><td>  1'588'741 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J357628/index.html">Node.js + Io.js = Node.js 4.0.0</a></li>
<li><a href="../J357630/index.html">Tagsistant：セマンティックファイルシステム</a></li>
<li><a href="../J357634/index.html">Androidパート2でアプリケーションを起動します-財務、プロモーション（個人的な経験から）</a></li>
<li><a href="../J357636/index.html">Android Studio 2.0開発環境のリリース（プレビュー）</a></li>
<li><a href="../J357638/index.html">オバマ大統領はコンピューターサイエンスを基礎教育に不可欠であると認識した</a></li>
<li><a href="../J357642/index.html">Portgen-バイパスポートフィルタリング</a></li>
<li><a href="../J357644/index.html">美術としてのプログラミング</a></li>
<li><a href="../J357650/index.html">ジェニファーゼロとその他の失敗した姓</a></li>
<li><a href="../J357652/index.html">大胆なソフトウェアの時代は終わりを迎えていますか？</a></li>
<li><a href="../J357654/index.html">Githubは、Roskomnadzorとの協力により、GNUプロジェクトをホストすることは受け入れられないと宣言しました</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>