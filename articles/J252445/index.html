<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏽 🔭 👨‍👨‍👧‍👧 ビデオストリームの断片化された圧縮方法 ♟️ 🐄 👧🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私は、開発を尊敬されるhabrasocietyの裁判所に提出することにしました-ビデオストリームの断片的な圧縮の方法です。 提案された方法の特徴は、圧縮されたビデオストリームと元のビデオストリームが完全に一致することです。つまり、この方法はロスレス圧縮を実行します。 
  
  
  
  使用され...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>ビデオストリームの断片化された圧縮方法</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> 私は、開発を尊敬されるhabrasocietyの裁判所に提出することにしました-ビデオストリームの断片的な圧縮の方法です。 提案された方法の特徴は、圧縮されたビデオストリームと元のビデオストリームが完全に一致することです。つまり、この方法はロスレス圧縮を実行します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> 使用される用語 </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     メソッド自体を説明する前に、使用する用語に同意する必要があります。 使用されるすべての用語は直感的ですが、それにもかかわらず、厳密に定義する価値があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> ピクセルは画像の最小単位です。 ピクセルの数値は、画面上の1点での画像の輝度関数の値を表します。 輝度をエンコードするために割り当てられたビット数は色深度と呼ばれ、以下ではbppと呼ばれます。 </li><li> フレームは、特定の瞬間におけるすべてのピクセルの集合です。 フレームは、高さN <sub>1</sub>ピクセル、幅N <sub>2</sub>ピクセルのピクセルの<sub>2</sub>次元配列として表されます。 </li><li> ビデオストリーム（フィルム）は、時間順に並べられたフレームのシーケンスです。 フィルム内のフレームの総数は、以下Mで示されます。 </li><li> ウィンドウは、高さn <sub>1</sub>および幅n <sub>2</sub>のピクセルの長方形領域です。 </li><li> フラグメントは、ウィンドウに囲まれたフレームの一部です。 </li><li> 論理的な差は、2を法とする加算演算（排他的OR）を、隣接するフレームの対応するフラグメントの2つのデジタル表現に適用した結果です。 </li><li> 算術差は、隣接するフレームの対応するフラグメントのデジタル表現の算術減算の結果です。 </li><li> 要素-フラグメントまたはさまざまな種類の違いは、タスクの特性に応じて要素として機能します。 要素のデジタル表現は、長さkのビット文字列です。 フラグメントまたは論理差の場合、k = n <sub>1</sub> * n <sub>2</sub> * bpp、算術差k = n <sub>1</sub> * n <sub>2</sub> * bpp + n <sub>1</sub> * n <sub>2の</sub>場合、ウィンドウのピクセルごとに追加の符号ビットが必要です。 </li><li> フィルムの体積（N <sub>f</sub> ）-フィルム内の要素の総数。  N <sub>f</sub> =（N <sub>1</sub> * N <sub>2</sub> * M）/（n <sub>1</sub> * n <sub>2</sub> ） </li><li> 要素頻度-フィルム内のこの要素の出現数とフィルムの体積の比率。 </li><li> 要素ベースは、ビデオストリームに存在するすべての要素とその周波数のセットです。 要素の底のべき乗はN <sub>bで</sub>示されます。 </li><li> 要素コード-データベース内の要素を一意に識別することができるバイナリコード。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> 断片化された圧縮方法の基本的な考え方 </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     断片化された圧縮方法の主なアイデアは、要素のベースから長さN <sub>fの</sub>要素のチェーンの形式でビデオストリームを表すことです。 ビデオストリームは時間の経過とともに非常にゆっくりと変化する意味のある画像（フレーム）のセットであるため、1つのフレームの隣接する要素間および隣接するフレーム内の対応する要素間で有意な相関が予想されます。 これにより、次の2つの効果が得られます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 十分に大きなフィルムの体積であっても、フラグメントのすべての可能な値のセットのパワー（2 <sup>k <sub>f</sub></sup> ）に比べて比較的小さなベースパワー（N <sub>b</sub> ）。 </li><li> フィルムの要素のベースからのさまざまな要素の発生頻度の著しい不均一性。 これにより、ビデオストリームの一連の要素に対して効果的なエントロピーコーディング圧縮アルゴリズムを使用できるようになります。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、断片的な圧縮方法の主なアイデアは、特別に構成された要素のベースから圧縮可能な要素のシーケンスの形式でビデオストリームを表現することです。 著者が行った実験は、この仮説を裏付けています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この方法の概念により、損失なしでも損失ありでもビデオストリームを圧縮できます。 非可逆圧縮の場合、元の画像を滑らかにする前処理（フィルタリング）と、要素のベースを分析し、ランダムノイズと視覚的に冗長な情報の両方をビデオストリームから抽出および削除する後処理の両方が可能です。 前処理と後処理の併用により、目的のプロパティを備えた新しい圧縮ビデオストリームを作成できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フラグメント圧縮方法は、4つのステップのシーケンスとして表すことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 要素のベースの形成。 非可逆圧縮の場合、ビデオストリームフレームの予備フィルタリングが可能です。 </li><li> 受信した要素のベースとその周波数特性の分析。 </li><li> 基本要素の短いコードの構築。 </li><li> 圧縮フィルム転写スキームの形成。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらの手順については、以下で詳しく説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 要素のベースの形成 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     要素のベースを形成するプロセスは、断片化された圧縮方法で最もリソースを消費するステップの1つです。 最終的な圧縮率は、このステップの実行効率に大きく依存します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     速度の要件が非常に高いため、要素のベースを形成するアルゴリズムは複数の段階で実行され、各ステップで異なるアルゴリズムとデータ構造が使用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フレーム要素ベースの形成は、最初の最も簡単なステップです。 この段階で、次のフレームがビデオストリームから受信され、必要に応じてその予備処理が行われます。また、要素のタイプに応じて、対応する「疑似フレーム」が形成されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/705/604/3df/7056043dfccf4b28aaf63616041418a0.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     疑似フレームを表示すると、ウィンドウは幅がn <sub>2</sub>ピクセル、高さがn <sub>1</sub>ピクセルシフトします。 図は、フレームN <sub>1</sub> = 30行x N <sub>2</sub> = 45列の例を示しています。表示は、正方形ウィンドウn <sub>1</sub> = n <sub>2</sub> = 5を使用して実行されます。 図の細い線は個々のピクセルを強調表示し、太い線はウィンドウの境界線を示し、ウィンドウ内の数字は表示時にシリアル番号を示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     要素が論理的または算術的な差異である場合、スキャンにより次の一連の差異が生じます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/4ab/174/894/4ab1748949ca4d878f958f6474ecd109.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ほとんどの実際のビデオでは、隣接するフレームの対応する要素間に有意な相関があると仮定されています。 これは表からも明らかです。ほとんどの要素はゼロの差に対応しています。 メモリを節約するために、結果のフレーム要素ベースが圧縮されます。 まず、いくつかの効率的なアルゴリズムによって並べ替えが行われ、次に一致する要素が1つのレコードに結合されます。 つまり、48個のゼロの差の代わりに、圧縮ベースには1つのレコードしかありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/208/187/6ef/2081876ef3034115833cf2c281de883a.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     第2段階では、フレーム要素の圧縮ベースが要素の特別なバッファに記録されます。これは、多くのフレームベースが蓄積され、1つの大きなブロックでグローバルストレージに書き込まれる個別のメモリ領域です。 バッファーの機能は、その任意の要素がインデックスによってランダムにアクセスできることです。 実際、これはRAMにある要素の単なる大きな配列です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     また、追加の再ソートなしで、フレーム要素ベースが「そのまま」バッファに書き込まれることにも注意してください。 これにより、バッファには要素の順序付けられたシーケンスが多数含まれますが、それ自体は順序付けられません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/d93/78b/41e/d9378b41e3174d6cbfaba930ecd6abc1.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     バッファに次のフレームベースを記録するのに十分なスペースがない場合、実際に検出された要素のリストを更新するプロシージャが呼び出されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     第3段階では、バッファに蓄積された要素は、値でソートされた要素の単純に接続されたリストである特別なグローバルストレージに移動されます。 リストの形式でグローバルな倉庫を表現すると、一定時間のランダムアクセスは許可されませんが、一定の時間でアイテムを追加および削除できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     バッファからグローバルストレージにアイテムを追加する前に、前述のように、バッファのソートおよび圧縮手順が実行されます。 これにより、リストのサイズに比例した線形時間でアイテムを追加できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/cf4/0eb/f97/cf40ebf970dc4896981cc74a661f0a02.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     考慮される3つのステージは、RAMにあるデータで動作します。 最終段階では、ハードドライブに保存されているデータを操作します。 ほとんどの場合、十分に強力な最新のコンピューターを使用すると、RAMの要素のベースを完全に組み立てることができますが、RAMのサイズがそこにあるベース全体に収まらない場合があります（たとえば、数百時間の共通のベースを構築している場合）。 この場合、RAMが不足したときに結果のデータベースをディスクに保存してから、データベースのマージ手順を実行する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、要素のベースを形成するプロセスでは、次の一連のステップが実行されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/7a8/67f/360/7a867f3606b4489a8237fba341149e2c.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 得られた要素のベースとその周波数特性の分析 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     要素のベースの分析には、各要素の個々の値とベースの周波数特性の両方の分析が含まれます。 これにより、まず圧縮方法の効果的な組み合わせ（短いコードとその送信方法の構築）を選択できます。次に、損失のある圧縮の場合、意識的にベースを削減（フィルタリング）できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 基本要素の短いコードを作成する </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     要素のベースには、長さkビットのN <sub>b</sub>行の配列と、ビデオストリーム（フィルム）でのこれらの行の出現頻度の表が含まれます。 この情報は、エントロピーコーディングのよく知られた方法（ハフマンツリー、算術コーディングなど）を適用するのに十分です。 上記のアルゴリズムの効率は非常に高く見積もられていますが、実際の使用には実装上の大きな困難が伴います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     要素の短いコードを構築するために、著者は、割線関数を使用してプレフィックスコードを構築するために以前に提案した方法を提案し、使用します。 このメソッドでは、基本要素の短いコードは、要素自体の行の内容に基づいて構築されます。 著者は、そのようなコードの平均長さがH <sub>b</sub> * 1,049の値を超えないことを証明しました。ここで、H <sub>b</sub>は、ビデオストリーム内の要素の出現頻度によって計算される要素の基底のエントロピーです。 実際のフィルムを使用した数値実験では、H <sub>b</sub>は20を超えることはありません。つまり、H <sub>b</sub> * 1,049 &lt;H <sub>b</sub> +1です。ハフマン。 同時に、割線関数を使用したエンコードには、上記の方法（N b≈107 -10 <sup>9</sup> ）で大型デジタルアレイをエンコードおよびデコードするときに生じる欠点がありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 圧縮された映画伝送スキームの形成 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     圧縮ビデオストリームでは、要素は以前に取得した短いコードに置き換えられます。 圧縮ビデオストリームを再生すると、デコードの問題が発生します。 デコードには、短いコードと基本要素の対応に関する情報が必要です。 このような情報を送信する最も簡単な方法は、要素とその頻度（発生回数）を直接送信することです。 この方法には、ベース自体の転送と、要素ごとに追加の64ビットが含まれます。 データを受信した後、受信側自体は、以前に報告されたアルゴリズムに従ってコードツリーを構築する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ツリーを記録および送信する方法が提案され、葉には要素のベース全体が記録されました。 この場合、伝送ボリュームは、ベースのボリュームにベースの各要素の2つの追加ビット（（k + 2）* N <sub>b</sub> ）を加えたものに等しくなります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ツリーの走査順序について同意しましょう。たとえば、幅の走査を使用します。 分割ツリーノードがある場合、ビット0が送信され、トラバーサル中にリーフが見つかった場合、ビット1と対応するベース要素が送信されます。 その結果、2つの追加ビットのみが各基本要素に追加送信されることを簡単に示すことができます。 図は、説明した方法を使用したバイナリツリーとしてのバイナリツリーの表現を示しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/f55/2d4/10a/f552d410a1614081857933d0c5cc7bfc.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     示された表現は可逆です。記述された方法で構築された各行に対して、初期コードツリーを構築することが可能です。 明らかなメモリの節約に加えて、説明されている送信方法は、デコード中にコードツリーを構築する必要をなくします（自然に復元されます）。 つまり、コードツリーは圧縮中に1回だけ構築されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     したがって、この作業では、ベースエレメントと圧縮エレメントコードのチェーンを含むコードツリーという2つの部分で構成されるビデオストリーム伝送方式を提案しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     圧縮されたビデオストリームのおおよその構造を図に示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/80a/61c/412/80a61c412e204a118c2550ee4b442e5b.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> アルゴリズムパラメータの選択 </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     断片化された圧縮アルゴリズムによって提供される圧縮率は、要素の形成されたベースのプロパティと特性に大きく依存します。 ベースの主な特性は、サイズ（要素の数）と周波数特性（主にエントロピー）です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     達成可能な圧縮率を評価するには、次の式を使用します。 基本要素コードの平均長さをl <sub>sr</sub>とすると、圧縮透過量はV <sub>sr</sub> = N <sub>b</sub> （k + 2）+ l <sub>sr</sub> * N <sub>f</sub>となり、非圧縮フィルムの体積はV <sub>f</sub> = N <sub>f</sub> * kに等しくなります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     圧縮率は次の値です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      R <sub>cr</sub> = V <sub>cf</sub> / V <sub>f</sub> 圧縮率の逆数は圧縮率と呼ばれ、K compressで表されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     努力する主な目標は、K <sub>sr</sub>を最大化することです。 上記の式では、N <sub>1</sub> 、N <sub>2</sub> 、M、bppは元のビデオストリームの特性であり、影響を与えることはできません。 また、 <sub>ベース</sub>のl <sub>cf</sub> 、Nの値は、スキャンウィンドウの領域と構成（n <sub>1</sub> 、n <sub>2</sub> ）に依存します。 つまり 断片的圧縮の方法における唯一の可変パラメーターは、ウィンドウの幾何学的寸法です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     どのウィンドウサイズでも、2 <sup>bpp * n <sub>1</sub> * n <sub>2</sub></sup>に等しい最大ベースサイズがあり、この値は非常に急速に増加します。 もちろん、すべての可能な要素が実際のフィルムにあるわけではありませんが、ウィンドウのサイズが大きくなると、対応する基本要素を表すのに必要なビット数も増えます。 さらに、ビデオストリームで1回しか検出されない要素が大量（合計数の70％以上）に表示されます。 最終的に、これらの効果はすべて圧縮率の低下につながります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一方、ウィンドウサイズが小さすぎると、N <sub>f</sub>が増加し、N <sub>bが</sub>制限されます。これにより、要素がより均等に繰り返され、周波​​数の「歪み」が滑らかになります。 要素がベースに対してより均等に繰り返されるほど、そのエントロピーはlog <sub>2</sub> N <sub>bに</sub>近くなります。 これにより、圧縮率が低下します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ウィンドウ1 * 1とウィンドウN <sub>1</sub> * N <sub>2の2</sub>つの極端なケースを考えます。 最初と2番目の両方のケースで、K cr≈1。 研究の過程で、スキャンウィンドウの面積に対するK <sub>sg</sub>の依存性（n <sub>1</sub> * n <sub>2</sub> ）がほぼ次の形式であることがわかりました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/4e5/3ec/202/4e53ec2029ff4a7db07be1bbff7478e6.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     課題は、圧縮レベルが最大になるポイントを見つけることです。 なぜなら 圧縮レベルもフィルムの特性に依存します。すべてのフィルムに最適な圧縮を与える「理想的な」構成がないことは明らかです。 しかし、実験により、圧縮が最適な比較的小さな領域を見つけることができました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     分析されたすべてのビデオストリームは、機能に応じて2つのグループに分けられました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 自然な撮影。 このグループには、ほとんどの映画、テレビ番組、アマチュア撮影が含まれます。 このグループの映画の特徴は、時間の経過とともにフレームが滑らかに変化することです。 この場合、変更は非常にスムーズで、フレームの中央に集中します。 ほとんどの場合、背景は均一ですが、明るさがわずかに変動する可能性があります。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最適なウィンドウ構成を選択するために、各グループに属するビデオストリームは、断片化された圧縮方法を使用して圧縮されました。 研究中に、1〜8ピクセルの面積を持つすべての可能なウィンドウ構成が分析されました（要素として論理的な違いが使用されました）。 合計で約1万時間のビデオが分析されました。これは約10億フレームです。 結果はグラフで表示されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/0cb/75f/898/0cb75f8989204820b3f9d5fbc6279929.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/2d0/627/2f9/2d06272f95864a8eaa1c16aaf34d4b81.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     提示されたデータから、3、4、または5ピクセルの領域を持つウィンドウを使用することで、最大圧縮率を達成できることが明らかです。 また、ビデオストリームの断片的な圧縮方法を実際に使用する場合、固定ウィンドウ領域では、アスペクト比が2/1に近い長方形のウィンドウを使用するときに最大の圧縮効率が観察されることを考慮する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> さまざまな色空間でのビデオストリームコーディング </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     先に検討した結果は、輝度成分のみを含むビデオストリーム（いわゆるモノクロビデオストリーム）のエンコードの状況に関連していました。 実用上非常に興味深いのは、カラービデオストリームをエンコードできる方法です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     カラービデオストリームをエンコードする最も簡単な方法は、カラーチャネルを個別にエンコードすることです。 独立したカラーチャネル用に収集された要素のベースを1つの共通ベースに結合する方法も検討されました。 トランスミッションのベースのシェアが減少しているという事実にもかかわらず、圧縮効率の増加は無視できました。 また、YIQ空間でのフラグメント圧縮方式の効率は、RGB空間よりもはるかに高いことが示されました。 まず第一に、この効果は色空間の変換から生じる損失に関連しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/b95/a3c/50c/b95a3c50c38a4c40a74a83d6d4c8d32c.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/af2/ae7/be1/af2ae7be1d034ea19ab543c11a0991e0.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     また、色差チャネルの粗い量子化により、YIQ空間での圧縮効率が大幅に向上することも注目に値します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1> ビデオストリームの断片化圧縮の方法の有効性と使用した方法の比較 </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     現在、ビデオストリームを損失なしに圧縮できる方法があります。 そのうちのいくつかは、非常に特殊化されており、1種類のビデオストリーム（画面録画など）に対してのみ有効であり、他の方法はさまざまなビデオストリームに対して有効です。 このセクションは、ビデオストリームの断片化された圧縮の提案された方法の有効性を既知の方法と比較することに専念します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     モスクワ州立大学のグラフィックス＆メディアラボビデオグループ  Lomonosovは、さまざまなパラメーター（圧縮率、リソース消費、圧縮効率など）の可逆ビデオ圧縮アルゴリズムの広範な比較を行いました。 最も重要な特性は圧縮効率です。 この基準に従って、次のコーデックが分析されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> アルパリー </li><li> アリシウフ </li><li> アビズリブ </li><li>  CamStudio GZIP </li><li>  Corepng </li><li>  Fastcodec </li><li>  Ffv1 </li><li> フフィウフ </li><li> ラガリス </li><li> ロコ </li><li> ルゾ </li><li>  MSUラボ </li><li>  Picvideo </li><li> 雪 </li><li>  x264 </li><li> ユルス </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     比較は、標準のテストシーケンスで実行されました。 各ビデオシーケンスは、各コーデックによって個別に圧縮されました。 結果はグラフに表示されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/b01/088/50d/b0108850df1d4f61ba14d651065b82fb.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     分析の便宜上、得られた圧縮係数の値を平均し、得られた平均推定値を以下に示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/b3e/362/9fa/b3e3629faeab4419ac6416845d52c140.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらのテストビデオシーケンスにフラグメント圧縮方式を直接適用しても効果はありません。 これは、テストビデオストリームの継続時間が非常に短く、断片圧縮の方法で圧縮されたフィルムの重要な部分が要素の基本であるという事実によって説明されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/2a9/675/912/2a967591262340ef98a1bd7804e5e588.PNG">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ビデオストリームの十分な期間（5000フレームから）では、断片圧縮の方法の平均圧縮率は3.38であり、これは考慮された最良の方法の圧縮率を超えています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     コミュニティに興味がある場合は、割線ツリーについて説明します。これにより、非常に良い結果を得ることができました。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J252437/index.html">C＃6での予期しない例外フィルターの動作</a></li>
<li><a href="../J252439/index.html">言語によるテストの自動登録</a></li>
<li><a href="../J25244/index.html">目を覚ます時です！</a></li>
<li><a href="../J252441/index.html">再接続-Facebookログインの脆弱性</a></li>
<li><a href="../J252443/index.html">Doxygenのドキュメント</a></li>
<li><a href="../J252447/index.html">Go with FOSDEM 2015のビデオの概要</a></li>
<li><a href="../J252449/index.html">フリーミアムと無料：無料サブスクリプションを廃止した理由</a></li>
<li><a href="../J252451/index.html">MAIN関数からのPerl 6コマンドラインインタラクション</a></li>
<li><a href="../J252455/index.html">GoおよびProtocol Buffersを少し練習します（または、慣れていない人のためのクイックスタート）</a></li>
<li><a href="../J252457/index.html">コメントを残すことができないが、本当にしたい場合は、することができます</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>