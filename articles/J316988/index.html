<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😆 👩 😒 Apache Sparkの非線形回帰。 自分でやる 🍄 ⛳️ 🚲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="信号処理の問題を解決する際、生データを回帰モデルで近似する方法がよく使用されます。 構造に基づいて、モデルは、線形、線形に縮小、および非線形の3つのタイプに分類できます。 Spark ML機械学習モジュールでは、最初の2つのタイプのApache Spark機能は、それぞれLinearRegressi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>Apache Sparkの非線形回帰。 自分でやる</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/316988/"><img src="https://habrastorage.org/files/806/f9d/3f4/806f9d3f420f4ad29d30fbddf489abb7.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     信号処理の問題を解決する際、生データを回帰モデルで近似する方法がよく使用されます。 構造に基づいて、モデルは、線形、線形に縮小、および非線形の3つのタイプに分類できます。  Spark ML機械学習モジュールでは、最初の2つのタイプのApache Spark機能は、それぞれ<strong>LinearRegression</strong>クラスと<strong>GeneralizedLinearRegression</strong>クラスで表されます。 標準ライブラリの非線形モデルのトレーニングは提示されておらず、独立した開発が必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まず、非線形モデルを構築するための理論的基礎を簡単に確認し、次にSpark ML拡張機能の実用的な開発に進みます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> ちょっとした数学 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     線形モデルと比較した非線形モデルの学習は、より複雑なタスクです。 これは、複数の極値の存在および/または応答面の「渓谷」の性質による可能性があります。 非線形関数を使用する主な刺激は、よりコンパクトなモデルを取得できる可能性です。 また、物理学および工学の分野からの多くの分析方程式は、最初は非線形であるため、適切なモデルの使用が強制される場合があることに注意する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     非線形モデルのトレーニングには、さまざまなツールがあり、その選択は特定の関数の種類、適用される制限の種類や種類などに依存します。この記事では、二次誤差関数と1次の準アルゴリズムであるニュートンガウス法の組み合わせを使用しますニュートン型。 ほとんどの場合、このアルゴリズムの収束はかなり良好です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ニュートンガウス法の反復ステップは、次の関係によって決定されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://tex.s2cms.ru/svg/d%3D-(J%5ET%20%20J)%5E%7B-1%7D%20J%5ET%20%20r" alt="d =-（J ^ T J）^ {-1} J ^ T r"> ここで、 <em>J</em>はヤコビ行列、 <em>r</em>は剰余の列ベクトルです <img src="https://tex.s2cms.ru/svg/r_i%3Dy_i-f(w%3B%20x_i)" alt="r_i = y_i-f（w; x_i）">  。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     示された式は論理的に2つの部分で構成されます：ヘッセ行列の近似 <img src="https://tex.s2cms.ru/svg/H%20%5Capprox%20(J%5ET%20%20J)" alt="H \約（J ^ T J）"> および勾配近似 <img src="https://tex.s2cms.ru/svg/%5Cnabla%20f%20%5Capprox%20J%5ET%20%20r" alt="\ nabla f \およそJ ^ T r">  。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ヤコビ行列の行数は、トレーニング例の数<em>n</em> 、列の数は重みベクトル<em>mの</em>サイズによって決まります。  [1]に示すように、ヘッセ行列の近似は、ヤコビ行列の行列の2行を読み取り、それらを乗算することで計算できます。 受け取った <img src="https://tex.s2cms.ru/svg/n%5E2" alt="n ^ 2"> 行列サイズ <img src="https://tex.s2cms.ru/svg/m%20%5Ctimes%20m" alt="m \回m"> 折りたたむだけです。 提案された操作の順列は、全体的な計算の複雑さを変更しませんが、ヤコビ行列全体をロードせず、並列に計算を実行することを許可しません。 同様に、勾配の近似が計算され、長さ<em>mの</em> <em>n個の</em>ベクトルのみが加算されます。 得られたヘッセ行列の反転は、サイズが比較的小さいため、それほど難しくありません。 アルゴリズムの収束を保証するには、計算された行列の正定性を監視する必要があります <img src="https://tex.s2cms.ru/svg/(J%5ET%20%20J)" alt="（J ^ T J）">  、固有値とベクトルを計算することで実現されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     記事[2、3]で、Apache Sparkに上記のアプローチを適用するための一般的なスキームが提案されました。 私の意見では、これらの作品の唯一の欠点は、既存のSpark ML APIとの明確なリンクがないことです。 次のセクションでは、このギャップを埋めようとします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Spark ML APIの実装 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     非線形モデルの実装を成功させるには、基本クラスの構造と目的を理解する必要があります。  Sparkシステムの機械学習APIには2つのバージョンがあります<em>。1.x</em>は<em>mllib</em>パッケージ内にあり、2.xは<em>ml</em>パッケージ内にあります。  Spark MLモジュール[4]のドキュメントでは、APIバージョン1.xからバージョン2.xへの移行は、チェーン（パイプライン）に埋め込み、型指定されたDataFrame構造で動作する可能性を提供することを目的としています。 この例では、新しいクラス構造を使用しますが、必要に応じて、古い構造の下で非常に簡単に実装できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 重要なSpark APIクラス </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <em>org.apache.spark.ml.feature.Instance</em>クラスは、実際のラベル、サンプルの重み、特徴値のベクトルを含むトレーニングサンプルのインスタンスを記述します。 </li><li>  <em>org.apache.spark.ml.regression。{Regressor、RegressionModel}</em>は、拡張する重要なクラスです。  1つ目はモデルビルダーで、2つ目は既にトレーニング済みのモデルです。 </li><li> 導入した特性<em>org.apache.spark.ml.regression.NonLinearFunction</em>を使用して、重みベクトルを選択することを目的とする非線形関数のコントラクトが定義されます。 コントラクトには3つのメソッドのみがあります<em>。eval</em>はある時点での関数の値を返し、 <em>grad</em>は勾配ベクトル、 <em>dim</em>はモデルの次元（重みベクトルの長さ）です。 </li><li>  Breeze線形代数ライブラリ[5]は、行列を使用した操作を引き継ぎ、最適化関数の既製の実装を備えています。  Newton-Gaussアルゴリズムまたは別の1次アルゴリズムを使用するには、損失関数にbreeze.optimize.DiffFunction <em>特性</em>を実装する必要があります。  <em>計算された</em>メソッドは、送信された係数ベクトルに基づいて、ペナルティ関数の値とポイントでの勾配のベクトルの2つの量のタプルを返す必要があります。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 回帰クラスの拡張 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>org.apache.spark.ml.regression.NonLinearRegression</em>クラスは<em>Regressor</em>コントラクトを拡張し、トレーニングの結果として<em>NonLinearRegressionModelの</em>インスタンスを返します。 非線形モデルを作成するには、一意の文字列識別子と<em>NonLinearFunction</em>モデルのカーネル関数を指定する必要があります。 オプションのパラメーターの中には、トレーニング反復の最大数、係数ベクトルの初期近似、および必要な精度をリストできます。 非線形関数には多くの極値があり、特定の核関数の振る舞いに関する先験的な考え方に基づいた初期近似の選択により、グローバル極値の領域に正確に検索を向けることができます。  Breezeライブラリのメモリ消費が制限された（LBFGS）Broyden-Fletcher-Goldfarb-Shannoアルゴリズムの既製の実装を使用することは注目に値します。 モデルトレーニングコードを以下に示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">コードorg.apache.spark.ml.regression.NonLinearRegression＃train</b> <div class="spoiler_text"><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span></span>(dataset: <span class="hljs-type"><span class="hljs-type">Dataset</span></span>[_]): <span class="hljs-type"><span class="hljs-type">NonLinearRegressionModel</span></span> = { <span class="hljs-comment"><span class="hljs-comment">// set instance weight to 1 if not defined the column val instanceWeightCol: Column = if (!isDefined(weightCol) || $(weightCol).isEmpty) lit(1.0) else col($(weightCol)) val instances: RDD[Instance] = dataset.select( col($(labelCol)).cast(DoubleType), instanceWeightCol, col($(featuresCol))).rdd.map { case Row(label: Double, weight: Double, features: Vector) =&gt; Instance(label, weight, features) } // persists dataset if defined any storage level val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK) val costFunc = new SquaresLossFunctionRdd(kernel, instances) val optimizer = new LBFGS[BDV[Double]]($(maxIter), 10, $(tol)) // checks and assigns the initial coefficients val initial = { if (!isDefined(initCoeffs) || $(initCoeffs).length != kernel.dim) { if ($(initCoeffs).length != kernel.dim) logWarning(s"Provided initial coefficients vector (${$(initCoeffs)}) not corresponds with model dimensionality equals to ${kernel.dim}") BDV.zeros[Double](kernel.dim) } else BDV($(initCoeffs).clone()) } val states = optimizer.iterations(new CachedDiffFunction[BDV[Double]](costFunc), initial) val (coefficients, objectiveHistory) = { val builder = mutable.ArrayBuilder.make[Double] var state: optimizer.State = null while (states.hasNext) { state = states.next builder += state.adjustedValue } // checks is method failed if (state == null) { val msg = s"${optimizer.getClass.getName} failed." logError(msg) throw new SparkException(msg) } (Vectors.dense(state.x.toArray.clone()).compressed, builder.result) } // unpersists the instances RDD if (handlePersistence) instances.unpersist() // produces the model and saves training summary val model = copyValues(new NonLinearRegressionModel(uid, kernel, coefficients)) val (summaryModel: NonLinearRegressionModel, predictionColName: String) = model.findSummaryModelAndPredictionCol() val trainingSummary = new NonLinearRegressionSummary( summaryModel.transform(dataset), predictionColName, $(labelCol), $(featuresCol), objectiveHistory, model ) model.setSummary(trainingSummary) }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>train</em>メソッドの与えられたコードは3つの部分に分けることができます：データセットからトレーニング例を取得する。 ペナルティ関数の開始と最適解の検索。 係数のベクトルと学習結果をモデルインスタンスに保存します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  RegressionModelクラス拡張 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>org.apache.spark.ml.regression.NonLinearRegressionModel</em>クラスの実装は非常に簡単です。  predictメソッドは、カーネル関数を使用して、ポイントで値を取得します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span></span>(features: <span class="hljs-type"><span class="hljs-type">Vector</span></span>): <span class="hljs-type"><span class="hljs-type">Double</span></span> = { kernel.eval(coefficients.asBreeze.toDenseVector, features.asBreeze.toDenseVector) }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Spark ML APIの注意すべき唯一の要件は、モデルの直列化可能性の要件です。 抽象クラス<em>org.apache.spark.ml.util。{MLReader、MLWriter}</em> [6]を拡張することにより、コンパニオンオブジェクトで目的の動作が保証されます。 トレーニング済みモデルの状態は、係数ベクトルとカーネル関数の2つの部分で構成されています。 すべてが係数ベクトルですでに発明されている場合、カーネル関数では少し複雑になります。 カーネル関数を直接DataFrameに保存することはできませんが、いくつかの代替オプションがあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     簡単にするために、関数をBase64文字列にバイナリシリアル化するオプションが選択されました。 欠点には、結果の文字列を読む人がアクセスできないこと、および実装のバージョン管理をサポートする必要があることが含まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     より有望なアプローチは、関数をシンボリック形式で保存することです。 これは、R言語の式クラスclass statsパッケージのオブジェクトのイメージで実行できます。たとえば、 <em>log（y）〜a + log（x）</em>です。 この方法は、最初の方法よりも複雑ですが、多くの問題を解決します。機能の人間が読める表現と、下位互換性を維持しながら、異なるバージョンのパーサーでの逆シリアル化の可能性です。 ここで重要な複雑さは、関数のシンボリック式の十分に柔軟なパーサーの開発です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     おそらく有用な改善点は、コア機能を数値的に差別化するためのステップを選択できることでしょう。 モデルの保存の複雑さはそれほど影響を受けません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 二次損失関数の実装 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     トレーニングに必要な最後の要素は損失関数です。 この例では、2つの実現の形で2次損失関数を使用します。  1つはトレーニング例がBreezeマトリックスの形式で指定され、もう1つはRDD [インスタンス] Spark構造の形式で指定されています。 最初の実装は理解しやすく（行列式を直接使用）、小規模なトレーニングセットに適しています。 それは私たちのテストベンチマークとして機能します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">コードorg.apache.spark.ml.regression.SquaresLossFunctionBreeze</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.apache.spark.ml.regression <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> breeze.linalg.{<span class="hljs-type"><span class="hljs-type">DenseMatrix</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">BDM</span></span>, <span class="hljs-type"><span class="hljs-type">DenseVector</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">BDV</span></span>} <span class="hljs-comment"><span class="hljs-comment">/** * Breeze implementation for the squares loss function. * * @param fitmodel concrete model implementation * @param xydata labeled data combined into the matrix: * the first n-th columns consist of feature values, (n+1)-th columns contains labels */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SquaresLossFunctionBreeze</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val fitmodel: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">NonLinearFunction</span></span></span></span><span class="hljs-class"><span class="hljs-params">, xydata: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">BDM</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SquaresLossFunction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * The number of instances. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> instanceCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> = xydata.rows <span class="hljs-comment"><span class="hljs-comment">/** * The number of features. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featureCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> = xydata.cols - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Feature matrix. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">X</span></span>: <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = xydata(::, <span class="hljs-number"><span class="hljs-number">0</span></span> until featureCount) <span class="hljs-comment"><span class="hljs-comment">/** * Label vector. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = xydata(::, featureCount) <span class="hljs-comment"><span class="hljs-comment">/** * The model dimensionality (the number of weights). * * @return dimensionality */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dim</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = fitmodel.dim <span class="hljs-comment"><span class="hljs-comment">/** * Evaluates loss function value and the gradient vector * * @param weights weights * @return (loss function value, gradient vector) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]): (<span class="hljs-type"><span class="hljs-type">Double</span></span>, <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = diff(weights) (<span class="hljs-number"><span class="hljs-number">0.5</span></span> * (rt * r), gradient(weights)) } <span class="hljs-comment"><span class="hljs-comment">/** * Calculates a positive definite approximation of the Hessian matrix. * * @param weights weights * @return Hessian matrix approximation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hessian</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]): <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">J</span></span>: <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = jacobian(weights) posDef(<span class="hljs-type"><span class="hljs-type">Jt</span></span> * <span class="hljs-type"><span class="hljs-type">J</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/** * Calculates the Jacobian matrix * * @param weights weights * @return the Jacobian */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jacobian</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]): <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gradData = (<span class="hljs-number"><span class="hljs-number">0</span></span> until instanceCount) map { i =&gt; fitmodel.grad(weights, <span class="hljs-type"><span class="hljs-type">X</span></span>(i, ::).t).toArray } <span class="hljs-type"><span class="hljs-type">BDM</span></span>(gradData: _*) } <span class="hljs-comment"><span class="hljs-comment">/** * Calculates the difference vector between the label and the approximated values. * * @param weights weights * @return difference vector */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">diff</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]): <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diff = (<span class="hljs-number"><span class="hljs-number">0</span></span> until instanceCount) map (i =&gt; fitmodel.eval(weights, <span class="hljs-type"><span class="hljs-type">X</span></span>(i, ::).t) - y(i)) <span class="hljs-type"><span class="hljs-type">BDV</span></span>(diff.toArray) } <span class="hljs-comment"><span class="hljs-comment">/** * Calculates the gradient vector * * @param weights weights * @return gradient vector */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gradient</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]): <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">J</span></span>: <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = jacobian(weights) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = diff(weights) <span class="hljs-number"><span class="hljs-number">2.0</span></span> * <span class="hljs-type"><span class="hljs-type">Jt</span></span> * r } }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2番目のオプションは、分散環境で実行するように設計されています。 計算には、 <em>RDD.treeAggregate</em>関数が<em>使用されます</em> 。これにより、「Map-Reduce」スタイルのアルゴリズムを実装できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">コードorg.apache.spark.ml.regression.SquaresLossFunctionRdd</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.apache.spark.ml.regression <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> breeze.linalg.{<span class="hljs-type"><span class="hljs-type">DenseMatrix</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">BDM</span></span>, <span class="hljs-type"><span class="hljs-type">DenseVector</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">BDV</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.broadcast.<span class="hljs-type"><span class="hljs-type">Broadcast</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.feature.<span class="hljs-type"><span class="hljs-type">Instance</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.rdd.<span class="hljs-type"><span class="hljs-type">RDD</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Spark RDD implementation for the squares loss function. * * @param fitmodel concrete model implementation * @param xydata RDD with instances */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SquaresLossFunctionRdd</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val fitmodel: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">NonLinearFunction</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val xydata: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">RDD</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Instance</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SquaresLossFunction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * The model dimensionality (the number of weights). * * @return dimensionality */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dim</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = fitmodel.dim <span class="hljs-comment"><span class="hljs-comment">/** * Evaluates loss function value and the gradient vector * * @param weights weights * @return (loss function value, gradient vector) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]): (<span class="hljs-type"><span class="hljs-type">Double</span></span>, <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bcW: <span class="hljs-type"><span class="hljs-type">Broadcast</span></span>[<span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]] = xydata.context.broadcast(weights) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (f: <span class="hljs-type"><span class="hljs-type">Double</span></span>, grad: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]) = xydata.treeAggregate((<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-type"><span class="hljs-type">BDV</span></span>.zeros[<span class="hljs-type"><span class="hljs-type">Double</span></span>](dim)))( seqOp = (comb, item) =&gt; (comb, item) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ((loss, oldGrad), <span class="hljs-type"><span class="hljs-type">Instance</span></span>(label, _, features)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresBdv = features.asBreeze.toDenseVector <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = bcW.value <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> prediction = fitmodel.eval(w, featuresBdv) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> addedLoss: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * math.pow(label - prediction, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> addedGrad: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * (prediction - label) * fitmodel.grad(w, featuresBdv) (loss + addedLoss, oldGrad + addedGrad) }, combOp = (comb1, comb2) =&gt; (comb1, comb2) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ((loss1, grad1: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]), (loss2, grad2: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>])) =&gt; (loss1 + loss2, grad1 + grad2) }) (f, grad) } <span class="hljs-comment"><span class="hljs-comment">/** * Calculates a positive definite approximation of the Hessian matrix. * * @param weights weights * @return Hessian matrix approximation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hessian</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BDV</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]): <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bcW = xydata.context.broadcast(weights) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (hessian: <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>]) = xydata.treeAggregate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>](dim, dim, <span class="hljs-type"><span class="hljs-type">Array</span></span>.ofDim[<span class="hljs-type"><span class="hljs-type">Double</span></span>](dim * dim)))( seqOp = (comb, item) =&gt; (comb, item) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ((oldHessian), <span class="hljs-type"><span class="hljs-type">Instance</span></span>(_, _, features)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> grad = fitmodel.grad(bcW.value, features.asBreeze.toDenseVector) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> subHessian: <span class="hljs-type"><span class="hljs-type">BDM</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = grad * grad.t oldHessian + subHessian }, combOp = (comb1, comb2) =&gt; (comb1, comb2) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (hessian1, hessian2) =&gt; hessian1 + hessian2 } ) posDef(hessian) } }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> プロジェクトの組み立て </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     元のSpark MLプロジェクトからの開発とテストを簡素化するために、 <em>pom.xml</em>を少し変更して借用しました。  Sparkのバージョンをリリースされたバージョンの1つ、この場合は<strong>2.0.1に</strong>修正します。  <strong>org.apache.spark：spark-parent_2.11：2.0.1</strong>からのPOMファイルの継承に注意する必要があります。これにより、Mavenプラグインの構成を再<strong>配置</strong>できなくなります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>SparkContext</em>を必要とするテストを実行するには、 <strong>org.apache.spark</strong>を追加します<em>。spark</em> <strong>-mllib_2.11：2.0.1：test-jar</strong> ：traits <em>org.apache.spark.mllib.util.MLlibTestSparkContext</em> 、 <em>org.apache.spark</em>を依存関係をテストします<em>.ml.util.TempDirectoryは</em> 、対応するテストクラスに実装されています。 また、テストに便利なのは、 <em>SparkFunSuite</em>などのコンテキストでの作業に役立つ<em>org.apache.spark</em>パッケージのSuiteクラスの拡張<em>です</em> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> 結論の権利について </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事では取り上げていない点がいくつかありますが、それらの研究は非常に興味深いようです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 加重トレーニングサンプルの使用; </li><li> ソフト（正規化）とハード（境界条件）の両方の最適化ドメインに対する制限の適用。 </li><li> モデルの統計指標の評価（係数の信頼区間、有意性など）。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     現時点では、上記の側面に関する十分な情報はありませんが、すべての共有ソースに感謝します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     完全なコードは<a href="https://github.com/Unlocker/spark-mllib-ext/">Github</a>で表示できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このソリューションの完全かつ包括的なテストはまだ実施されていないため、改善を検討するためのコンセプトおよびトピックとして資料を扱ってください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     コメントや提案については、プライベートメッセージを使用することをお勧めします。コメントはディスカッションに適しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ご清聴ありがとうございました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> 使用材料 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="http://ieeexplore.ieee.org/document/5451114/">ieeexplore.ieee.org/document/5451114</a> </li><li>  <a href="http://www.nodalpoint.com/nonlinear-regression-using-spark-part-1-nonlinear-models/">www.nodalpoint.com/nonlinear-regression-using-spark-part-1-nonlinear-models</a> </li><li>  <a href="http://www.nodalpoint.com/non-linear-regression-using-spark-part2-sum-of-squares">www.nodalpoint.com/non-linear-regression-using-spark-part2-sum-of-squares</a> </li><li>  <a href="http://spark.apache.org/docs/latest/ml-guide.html">spark.apache.org/docs/latest/ml-guide.html</a> </li><li>  <a href="https://github.com/scalanlp/breeze">github.com/scalanlp/breeze</a> </li><li>  <a href="https://jaceklaskowski.gitbooks.io/mastering-apache-spark/content/spark-mllib/spark-mllib-pipelines-persistence.html">jaceklaskowski.gitbooks.io/mastering-apache-spark/content/spark-mllib/spark-mllib-pipelines-persistence.html</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J316974/index.html">Firebug開発ツールの終了：「Firefox DevToolsを使用」</a></li>
<li><a href="../J316976/index.html">国、地域、都市のデータベース</a></li>
<li><a href="../J316978/index.html">JavaScript様、</a></li>
<li><a href="../J316980/index.html">信頼式</a></li>
<li><a href="../J316986/index.html">Swiftコンパイラのチューニング。 パート1</a></li>
<li><a href="../J316994/index.html">悪いアドバイスまたはひどいリーダーになる方法</a></li>
<li><a href="../J316996/index.html">PhoenixとElixirを使用してブログエンジンを作成する/パート5. ExMachinaを接続する</a></li>
<li><a href="../J3170/index.html">EMIはDRMを放棄したい</a></li>
<li><a href="../J317002/index.html">LLVM用の実際のポインター分析を作成しています。 パート1：プログラム分析の世界の紹介または初デート</a></li>
<li><a href="../J317004/index.html">RubyMine 2016.3：接続モードでのデバッグ、Puppetのサポートの更新、rsyncを介したSDK同期</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>