<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌠 🃏 🔽 .NETパフォーマンス：本物のジェダイの秘Tri 🥐 🎗️ 🚪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本物のJedi .NET、パフォーマンスの第一人者、複数のMicrosoft MVP、 DotNext会議の常任講演者、 Sasha Goldsteinを紹介する必要がありますか？ おそらくそれだけの価値はありません。 そして、突然立った場合は、 こちらをご覧ください 。 
  
 
  
  
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>.NETパフォーマンス：本物のジェダイの秘Tri</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/339230/">本物のJedi .NET、パフォーマンスの第一人者、複数のMicrosoft MVP、 <a href="https://dotnext-moscow.ru/">DotNext会議の</a>常任講演者<a href="https://dotnext-moscow.ru/">、</a> Sasha Goldsteinを紹介する必要がありますか？ おそらくそれだけの価値はありません。 そして、突然立った場合は、 <a href="https://habrahabr.ru/company/jugru/blog/282890/">こちらをご覧ください</a> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/d4c/9c1/f63/d4c9c1f639a6d3c51224ff3fa389d04d.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     会話の中で、Sashaは.NETおよび.NET Core開発者向けの専門的なヒントを共有しています。 アプリケーションのプロファイリングとデバッグの際に何を探すべきか、使用するツールについて説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-Sasha、.NETのパフォーマンスに関する記事とヒントがたくさんあります。</b>  <b>どこからでも例外をスローし、連結の代わりにStringBuilderを使用することは望ましくないという事実から始まり、低レベルの最適化で終わります。</b>  <b>しかし、.NETは絶えず進化しており、新しい機能と新しい問題があります。</b>  <b>最新の.NET 4.7の場合、コードパフォーマンスの最適化に関する実用的なアドバイスはありますか？</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Sasha Goldstein：</b>多くの人は、文字列の連結、例外、またはボックス化/ボックス化解除に関する「明らかな」ヒントにすでに精通していますが、新しいAPIまたはより高いレベルのAPIが表示されると、パフォーマンスに関する誤解が生じます。 多くのコードベースでのLINQの過剰な使用が心配です。  LINQから何年も経っており、通常のループを使用してほとんどのLINQクエリを10倍高速化できることを示す多くのデータがありますが、多くの場合、パフォーマンス重視のコードでLINQを使用することが多くあります。 明確にします：全体としてLINQに反対することはありませんが、そのようなソリューションは、サイクルが100万回実行されるとうまく機能しません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     みんなの頭の中に入れられなかったもう1つのことは、メモリを過剰に割り当てる危険性です。  .NETのガベージコレクターにはいくつかの改善点がありますが、特に古い世代で死んでしまうオブジェクトの場合、割り当てすぎるとなお役に立ちません。 一部のツールでは簡単になりますが、メモリ割り当ての問題に注意を払うように全員に教えることは困難です。 たとえば、Roslynの<a href="https://www.nuget.org/packages/ClrHeapAllocationAnalyzer/">ヒープ割り当てアナライザー</a>または<a href="https://www.jetbrains.com/dotmemory/">dotMemory</a>などのプロファイラー。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後にしたいのは、コンテナテクノロジのために、ワークステーションだけでなくサーバーアプリケーションにとって最小メモリと起動時間が重要になる時期に戻っているということです。  1つの物理ホストでDockerで実行されているマイクロサービスのインスタンスを300個パックする場合、メモリ管理に細心の注意を払い、不要な依存関係を避け、不要な作業を取り除く必要があります。 標準のランタイムとして16コアの32ギガバイトサーバーに慣れると、サービスを「--memory 256m --cpus 0.25」に圧縮しようとします。 ちなみに、「 <a href="https://en.wikipedia.org/wiki/Serverless_computing">サーバーレス</a> 」テクノロジーでも同じ問題に直面していますが、デプロイメントユニットは非常に小さいため、通常はリソースの制約を受けやすくなります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-今日、NETはWindows専用ではありません。</b>  <b>Monoおよび.NET Coreが登場しました。</b>  <b>特にLinuxのネイティブアプリケーションと比較して、パフォーマンスの面でこれらのツールはどれほど優れているか教えてください。</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Sasha Goldstein：</b> Monoはかなり前から存在していましたが、正直なところ、私はMonoを戦闘プロジェクトで使用していません。 彼は成熟した価値のあるランタイムを持っていることを知っていますが、Monoは私が期待していたという認識を受け取りませんでした。 いずれにせよ、私はその有効性に関する勧告を与えることはできません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     今日、.NET Coreについて詳しく説明します。  Linuxでは、.NET CoreはWindowsとほぼ同様のスタックとコードベースを使用します。 コンパイラはWindowsと同じ最適化を実行し、AOT（.NET CoreではCrossgenと呼ばれます）をコンパイルすることでJITコンパイルを回避する方法があります。いくつかの機能を備えたガベージコレクターなどがあります。 質問を提起できる.NET Coreの唯一の部分はPAL（Platform Adaptation Layer）であると言えます。これは、実際にはWindowsバージョンとはまったく異なるコードベースを持つ唯一の場所だからです。 実際、Windowsの同様のAPIと比較して、PALにはパフォーマンスの問題があり、主にLinux APIの誤用または予期しないパフォーマンス動作を伴うLinux APIの使用に関するものでした。 多くの開発者が実稼働環境で.NET Coreを使用し、これらの問題に遭遇するため、これらのしわは時間の経過とともに自然に滑らかになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     成熟するまでに時間がかかる興味深い開発はCoreRT（Windows用.NET Native）です。これは最終的に管理対象アプリケーションの作成を試み、外部依存関係がなく、JITをまったく生成しません。 分離の簡素化（共有なし、インストールなし、依存関係管理なし）に加えて、CoreRTは不要なコードを振り落とすことで起動時間を短縮し、メモリを削減します。 これにより、.NETをネイティブLinuxアプリケーションにさらに近づけることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-.NETの生産性向上に関するほぼすべての記事で言及されている主なヒントの1つは、プロファイラーの使用です。</b>  <b>DotNext 2017 Moscowでは、Linux用の.NET Coreアプリケーションのデバッグとプロファイリングについて説明します。</b>  <b>Visual Studioは.NET Coreのデバッグとプロファイリングをどのように行っていますか？</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Sasha Goldstein：</b> Visual Studioは現在、Linux上の.NET Coreアプリケーションをプロファイルするための機能を提供していません。  Windowsツールキットを使用して.NET Coreアプリケーションをプロファイリングすることはできません。Linuxでプロファイリングを行う必要があり、Windowsで結果を実際に分析する唯一の方法（これになりやすい場合）は、Visual Studio Profilerよりも少し洗練されたツールであるPerfViewを使用することです 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     同様に、Visual StudioはLinux上の.NET Coreアプリケーションカーネルのダンプを開くことができません。  Visual StudioでWindowsダンプファイルを開くときに使用するリッチデバッガーデータは、コアダンプには存在しません。  Visual Studio 2013で導入されたメモリ分析機能は、コアダンプでは機能しません。 実際、WindowsにはLinuxからアプリケーションダンプを開くことができるツールはありません。 これを行うには、現在はるかに多くの機能を提供しているLinuxツールを使用する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     すでに気づいたように、私はそれがあまり好きではありません。 私はとても驚いているとは言えません。  MSがプラットフォームの開発に費やしたすべての努力と、すでにバージョン2.0を使用しているという事実にもかかわらず、プロファイリングとデバッグのための優れたツールはまだありません。  Linuxでの発表から3年後、平均的な開発者が使用できる適切なプロファイラーやデバッガーはありません。 これは重大な制限であり、個人的に私を悩ますことがあります。 実稼働アプリケーションをデバッグまたはプロファイリングしようとすると壁と戦うことがわかっているので、正直に言って、クライアントがLinuxで.NET Coreに切り替えることはお勧めしません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-Linux開発の世界では、perfとftraceが人気があり、アプリケーションのパフォーマンスを分析する良い機会を提供します。</b>  <b>.NET Coreでのデバッグに役立ちますか？</b>  <b>ネイティブLinuxアプリケーションと.NET Coreのアプリケーションでperfまたはftraceを使用する場合、何か違いはありますか？</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>サーシャ・ゴールドスタイン：</b>はい。  Linuxでの.NET Coreアプリケーションのプロファイリングの公式ワークフローは、perfに基づいています。  Microsoftは、perfを実行し、パフォーマンスデータを収集し、それを単一のファイルに結合し、PerfViewを使用してWindowsで開くことができる「perfcollect」と呼ばれるBashスクリプトを提供しています。 この話のばかげたことを一時的に無視し、このプロセスがどのように機能するかについて話しましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perfは、さまざまな操作モードを備えた多目的ツールです。 特に、プロファイラーとして使用できます。 さまざまなシステムイベントに接続し、これらのイベントが発生したときにスタックトレースを収集してから、このトレーススタックのアドレスをメソッド名にマッピングします。 また、いくつかの視覚化機能もありますが、多くの場合、たとえばFlame Graphsに置き換えられます。 現在、perfは単なるCPUプロファイラーではありません。プロセスにアタッチしたり、ミスイベントをキャッシュしたり、ディスクイベントを読み書きしたり、スケジューラーやその他の数千の追加の静的および動的イベントによってコンテキストスイッチにアタッチしたりできます。  Windowsに最も近いのはETWツール（PerfView、Windows Performance Recorderなど）ですが、perfは動的ツール（カーネルまたはユーザースペースライブラリの任意の関数にアタッチ）を提供できます。 ETWはできません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      .NET Coreアプリケーションにperfを使用する場合、克服しなければならない問題が1つあります。 アドレス変換に関連しています。  perfがスタックトレースをキャプチャするとき、スタック上のリターンアドレスをメソッド名にマッピングできる必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      .NET CoreはJITコンパイルを使用するため、このマッピングを実行できる静的な場所はありません（デバッグ情報、シンボル、呼び出し方に関係なく）。 この場合のperfの動作方法は、ターゲットアプリケーションがメソッドアドレスの名前へのマッピングを含む/tmp/perf-$PID.mapという単純なテキストファイルを書き込むことを期待することです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     実際、.NET Coreはこの規則をサポートしています。COMPlus_PerfMapEnabled環境変数を1に設定すると、JITはメソッドがコンパイルされるたびにこのテキストファイルに書き込み、perfはこの情報を使用してアドレスを正常にマップできます。 事前にこれを行う必要があるのは少し残念です-環境変数を設定しておらず、既に実行中のプロセスのプロファイルを作成したい場合は不運です-しかし、たとえばNode.jsも機能するので、これは多かれ少なかれ受け入れられると思います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ストーリーには別の工夫があります。今回はAOTでコンパイルされたビルドです。  AOTコンパイルにCrossgenを使用する場合（.NET Coreは、ディストリビューションのパッケージマネージャーから取得する.NET Coreパッケージの一部のアセンブリでそれを使用します）、これらのアセンブリのデバッグ情報を取得する別の方法が必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Crossgenでコンパイルされたアセンブリでこれを指定すると、Crossgenツール自体がこの情報を生成できます。 これまでのところ、いいですか？ そうでもない。 まず、Crossgenは.NET Coreと共にインストールされないため、ソースからCoreCLRをコンパイルして取得するか、バカなNuGetリカバリトリックを使用する必要があります。 第二に、Crossgenは、perfが期待するものと互換性のない形式でデバッグ情報を提供するため、出力をフォーマットしてメインペフトマップファイルと組み合わせる必要があります。  3番目に、現在、perfは、Crossgenのように、ディスクに書き込まれたメモリパーティションのperf-mapsファイルの表示をサポートしていません。 したがって、これらのアセンブリの適切なperf-mapを取得できたとしても、perfはそれらを無視します。 幸いなことに、この場合でも機能する他のツールがあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ところで、.NET Coreプロセスを「ライトアップ」して動作させるツールは他にもたくさんあります。  DotNextレポートでは、perfをBCCのBPFベースのツールと共に使用します。 数か月前に、BPFでのJVMプロファイリングに関する<a href="https://jpoint.ru/">JPoint</a>会議でBPFとBCCについて話し合いました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-LTTngについて質問があります。</b>  <b>公式文書によると、LTTngではパフォーマンスが最前線にあります。</b>  <b>.NET Coreアプリケーションをトレースする場合、このルールは維持されますか？</b>  <b>トレースポイントまたはkprobesを使用する場合、LTTngの制限はありますか？</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Sasha Goldstein：</b> 「and」にドットを付けましょう。  LTTngは、2つの動作モードを持つ強力なLinuxトレースフレームワークです。 トレースポイントに接続できるカーネルモジュールがあります。これは、カーネル全体に散在する静的に定義されたトレース位置です：スケジューライベント、ディスクアクセス、プロセス実行など。 さらに、LTTngには、ユーザーアプリケーションのイベントを追跡するために使用できるユーザー空間ライブラリがあります。これは、Linuxで.NET Coreが使用するものです。 どちらの場合も、LTTngは共有メモリバッファー、コンパクトなバイナリ形式、ディスクへの高速書き込みにより、高いイベントレートに最適化されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ご存知かもしれませんが、Windows上の.NETには、パフォーマンスのプロファイルとシステムの動作の理解に使用できる多くのETWイベントがあります。 これらには、GCイベント、アセンブリ、JITコンパイル、オブジェクト作成などが含まれます。  Linuxでは、もちろんETW（Windowsのイベントトレース）は利用できないため、MicrosoftはLTTngの使用を選択しました。 同じイベントを取得しますが、それらはETWではなくLTTngを介して生成されますが、いくつか注意点があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最初に、環境変数を設定する必要があります（COMPlus_EnableEventLog = 1）。 これが行われない場合、LTTngはイベントをまったく生成しません。 第二に、LTTngはユーザー空間イベントのスタックトレースをサポートしていません。 これは、GCイベントをインターセプトできますが、それらが呼び出された呼び出しスタックがないことを意味します。 アセンブリロードイベントをキャッチできますが、このアセンブリをロードしたコードがわかりません。 これらは、実際のトラブルシューティングシナリオでこれらのイベントの使用を制限する非常に痛い瞬間です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-Linux用のLLDBデバッガーは、Windows用のWinDbgと非常に似ています。</b>  <b>彼にとっては、SOS拡張機能も利用可能で、マネージコードをデバッグできます。</b>  <b>現在、.NET Codeアプリケーションのデバッグにどの程度適用できますか？</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Sasha Goldstein：</b> LLDBは非常に強力なデバッガーであり、Microsoftはlibsosplugin.soライブラリを提供しています。これはLinux用のSOS.dllのバージョンです。 ほぼ同じコマンドセットを同じセマンティクスで提供します。これは、SOSに精通している場合に適しています（ただし、WinDbgとは大幅に異なる独自のLLDBコマンドを学習する必要があります）。 しかし、これはこの会話のトピックではありませんか？  libsospluginを使用したLLDBの場合、次の障害が発生します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  LLDBプラグインは、LLDBの特定のバージョンと密接に関連しています。  libsosplugin.soはCLRに同梱されているため、Microsoftがビルドプロセスで使用するLLDBバージョン用にビルドされています。これは、執筆時点ではLLDB 3.6でした。 これはかなり古いLLDBビルドであり、多くの既知のバグがあり、実際、ソースコードからコンパイルせずに多くの最新のディストリビューションにインストールすることはほとんど不可能です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  4.0より前のLLDBは、オンデマンドで生成されたカーネルダンプを理解しないため、クラッシュの結果として作成されたコアダンプを開くか、実行中のプロセスに参加できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li> カーネルダンプを開くか、実行中のプロセスに参加する場合、OSスレッドIDを.NET管理対象スレッドIDにマップするようにSOSプラグインに教える必要があります。  400個のスレッドがある場合、これは非常に迷惑です（このためのスクリプトがあります）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-高品質のマルチスレッドアプリケーションの開発は困難な作業です。</b>  <b>しかし、さらに複雑なのは、そのようなアプリケーションのボトルネックとエラーの検索です。</b>  <b>開発者は、.NET用のマルチスレッドアプリケーションのデバッグとプロファイリングに何を使用できますか？</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>サーシャ・ゴールドスタイン：</b>あなたが好きな限りそれについて話すことができるので、簡単に説明します。 最新のツールを使用して自動化できるいくつかの重要な方法があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> どのコードが頻繁に問題を引き起こしているのかを理解する（ブロックするだけでなく、ブロックする）。 これは、コンテキスト切り替えイベントを分析することで実行できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li> 異なるスレッド間のワークロードの分散を理解する。 これは多くの場合、Visual Studio Concurrency VisualizerやdotTraceのタイムライン関数などのツールを使用して視覚的に行われます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li> さまざまなタイプのオーバーサブスクリプションの理解-プロセッサの制約（コンテナなどによる）、優先度の問題、またはすべてのスレッドに十分な数のコアがないこと。 これは、自動タスクスイッチングイベントを分析し、スレッドがCPUで処理される時間のヒストグラムを作成するか、これを防ぐ内部的な理由がない限り、サービスの順番を待つことで実行できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-DotNext 2017に向けてどのようなレポートを準備しましたか？</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Sasha Goldstein：</b>モスクワで、Linuxでの.NET Coreアプリケーションのプロファイリングとデバッグについて説明します。 これは何ヶ月にも及ぶ研究の結果です。  .NET Coreアプリケーションの一般的なパフォーマンスの問題のライブデモと共に、上記のツールと方法のいくつかについて説明します。 特別なボーナスとして、これらのツールのいくつかを使用して、Dockerコンテナで実行されている.NET Coreアプリケーションのプロファイルを作成する方法を紹介します。 私のデモはすべて<a href="https://github.com/goldshtn">GitHub</a>で入手できるため、会議後にデモを試すことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして、完全な没入を望む人のために、モスクワは11月11日に、 <a href="https://dotnext-moscow.ru/2017/msk/trainings/m4aetwwkioiwk4yaaouaq/">製品の</a>パフォーマンス問題を監視および解決するためのツールとアプローチに特化した8時間の実践トレーニング「 <a href="https://dotnext-moscow.ru/2017/msk/trainings/m4aetwwkioiwk4yaaouaq/">.NETアプリケーションの生産パフォーマンスとトラブルシューティング</a> 」を開催します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <hr>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私たちと同様に.NETのインテリアが好きな人は、30人以上のスピーカーが.NETプラットフォームの現在と未来、パフォーマンスの最適化とマルチスレッド、内部のプレゼンテーションを<a href="https://dotnext-moscow.ru/">行うDotNext 2017モスクワ</a>会議での他の専門家のスピーチに興味を持つかもしれません.NETおよびCLRプラットフォームデバイス。.NETコードのプロファイリングとデバッグについて。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J339218/index.html">2回目のReactOSハッカソンの結果：GitHubに切り替えます</a></li>
<li><a href="../J339220/index.html">ビデオゲームIDソフトウェアの開発の魔法</a></li>
<li><a href="../J339222/index.html">交換、所有権履歴、および仲裁の節約：ビットコインユーザーのための5つの便利なサービス</a></li>
<li><a href="../J339224/index.html">Whatsappの中身は？</a></li>
<li><a href="../J339226/index.html">RAIFチャンピオンシップの参加者はM.Videoビジネスデータにアクセスできます</a></li>
<li><a href="../J339232/index.html">Angular + Ag-Gridでの迅速なアプリケーション開発</a></li>
<li><a href="../J339236/index.html">簡単なウェブサイトはありますか？ そして、私がチェックしたら？</a></li>
<li><a href="../J339242/index.html">トラフィックの傍受について：暗号化されたHTTPSトラフィックの4〜10％が今日傍受されます</a></li>
<li><a href="../J339246/index.html">Bashのいくつかの事前ガジェットタスク</a></li>
<li><a href="../J339248/index.html">Skyengの最初のハッカソン：2日間で15の作業プロジェクト</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>