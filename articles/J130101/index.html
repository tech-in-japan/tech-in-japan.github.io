<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌦️ 🥓 🍊 ノンブロッキングキュー：スレッド間のメッセージング 👩🏿 ⛓️ 💛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このようなモジュールを作成するというアイデアは、企業製品のPLMを生み出しました。 設計ドキュメントを調べて、コードが呼び出されたタスクをブロックすることは決してなく、通常はできるだけ時間をかからないようにと言われました。これはシステム構築の特性です  、ウォッチドッグなど タスクには、ログ、高度な...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>ノンブロッキングキュー：スレッド間のメッセージング</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> このようなモジュールを作成するというアイデアは、企業製品のPLMを生み出しました。 設計ドキュメントを調べて、コードが呼び出されたタスクをブロックすることは決してなく、通常はできるだけ時間をかからないようにと言われました。これはシステム構築の特性です <a name="habracut"></a>  、ウォッチドッグなど タスクには、ログ、高度な診断など、あるタスクから別のタスクへの特定のメッセージの転送が含まれていました。 受信者タスクは、結果をファイルに書き込むために作成されました。これは、ファイルへの書き込みについて元のタスクに疑問の余地がないことは明らかだからです。 そして、1つのソース（プロデューサー）と1つのコンシューマーがあり、ミューテックスやセマフォが存在しても元のタスクには影響しませんが、それらを完全に放棄することにしました。 繰り返しになりますが、将来、タスクを他のいくつかのシャッフルに拡張することが可能になったため、あるタスクが別のタスクを待機する状況は制限されていますが（ソースコードはセマフォを使用して情報メッセージを交換します）、非常に望ましくありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     当初は、各要素にソースまたはコンシューマが属するかどうかを決定するビットが含まれる静的な循環バッファを作成することになっていた。 アルゴリズムは非常に単純で、ソースはビットがゼロのセルにデータを書き込み、変更を「公開」して、このビットにユニットを書き込み、次の要素に進みます。 一方、このビットが1に等しい要素を持つコンシューマは、メッセージを読み取り、ビットがゼロにリセットされます。 競合状態はありません。すべてが順調です。 しかし、最初のトラフィックテストでは、ソースが1つのスライスで約3万〜4万要素を理論的に生成できることが明らかになりました。 もちろん、これらの行の生成を除いて、彼はまだ何かをしているので、実際にはもっと少なくなりますが、バッファーのサイズを決定することはできません。これで十分です。 この理由の1つは、ファイルへの書き込み速度が不安定であることです。一部のシステムでは、ハードドライブの代わりにCFカードが使用されます。 そして、私は本当にメッセージを失いたくありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     インターネットで大騒ぎして、次のソリューションに出くわしました。これはタスクで実装しました： <a href="http://drdobbs.com/architecture-and-design/210604448">drdobbs.com/architecture-and-design/210604448</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アルゴリズムの詳細は十分に説明されているため、ここでは繰り返しません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私が行った2つの変更： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1）消費者ではなく、ソースが要素をリリースする理由を理解できませんでした。 消費者が要素をリリースしても、競合状態は発生しません（ところで、このフレーズをロシア語に翻訳するにはどうすればよいですか？）。 これにより、消費された要素がすぐに削除されるため、消費者から負荷の一部が削除され、使用されるメモリが削減されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2）また、トラフィックテスト、またはプロファイラーは、mallocが比較的高価な操作であることを明らかにしました。 ソースメッセージの最大サイズがわかっているため、1つの操作でメモリ割り当てをすぐに8つの要素にグループ化することが決定されました。 これにより、特にプロセッサの負荷が半分になり、元のタスクに追加されて、速度が2倍以上向上しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここでは、ソースコードがプラス以外のSにあったことを直ちに予約する必要があります。これは、秘密保持契約のため、公開できません。  MallockはC-Sharpには適用されないため、2番目のポイントは適用されません。 そして、私はすでに私の自由時間にs-sharpeを勉強していて、自分で書いています。 彼らは私に仕事を提供しましたが、私はこの魔法の言語の経験不足だけを経験したわけではなく、それ以来ずっとやっています。 まあ、ポイントに近い。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Cでの非ブロッキングキューの実装＃ </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最初のステップは、キューの要素を記述することです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>        クラスqueItem
         {
          パブリックオブジェクトメッセージ。
           public queItem next;

           public queItem（オブジェクトメッセージ= null）
           {
             this.message = message;
             next = null;
           }
         }
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして実際にはターン自体： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>       class locklessQueue //スレッド間ロックレスキュー
       {
         queItem first;
         queItem last;
       }
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここで、最初はコンシューマーに属し、最後の要素の次はソースに属します。  firstもlastもnullであってはならないため、コンストラクタは「すでに消費された」状態で空の要素を作成します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>         public locklessQueue（）
         {
          最初=新しいqueItem（）;
           last = first;
         }
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     キューに追加し、それに応じてキューから抽出するその他の方法。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>         public voidproduce（オブジェクトメッセージ）
         {
           last.next = new queItem（メッセージ）;
           last = last.next;
         }

        パブリックブール消費（オブジェクトメッセージの出力）
         {
           if（first == last || first.next == null）
           {
            メッセージ= null;
             falseを返します。
           }
           message = first.next.message;
           first = first.next;
           trueを返します。
         }
       }
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ConcurrentQueueクラスはすでに4.0に含まれているため、結果のクラスだけでは十分な基盤がありません。これは完全にスレッドセーフであるだけでなく、結果のクラスとは異なり、同時に複数のスレッドをキューに追加および削除できます。 また、ブロックオプションと比較して、キューの処理が1.5〜3倍速くなります。  <a href="http://geekswithblogs.net/BlackRabbitCoder/archive/2010/06/07/c-system.collections.concurrent.concurrentqueue-vs.-queue.aspx">pruflink</a> <a href="http://geekswithblogs.net/BlackRabbitCoder/archive/2010/06/07/c-system.collections.concurrent.concurrentqueue-vs.-queue.aspx">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </a> ログコレクターの場合、ConcurrentQueueクラスで十分です。 しかし、アプリケーションのタスクを拡張しましたが、ConcurrentQueueは私に合わず、アドレスレスです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> スレッド間メッセージング </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="http://dl.dropbox.com/u/26488961/messenger.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各スレッドは、名前で別のスレッドにメッセージを送信できる必要があります。 私の場合、これらはtcpソケットハンドラー（クライアントまたはサーバー）とスレッドハンドラー自体です。 どのプロセッサを送信する必要があるかを見つける方法は、このノートの外に残します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     残念ながら、サブ問題の1つを解決できませんでした-ブロックせずに、交換の参加者として新しいスレッドを追加します。  ConcurrentQueueのソースコードを見たいのですが、その解決策が答えを見つけるのに役立つかもしれません。 明確に、真実は開始メッセージを送信するために、または非同期メソッドからのメッセージのために使用することができますが、今のところ、古典的な場合とほぼ同じブロッキングソリューションを提供します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     先を見据えて、この決定には明らかな欠点があると思います。別のスレッドを実行する必要があるキューを処理する場合、これはブロックの欠如に対する支払いです。 個別のスレッドは明らかにプロセッサの負荷を追加しますが、ブロッキングがないため、各メッセージの処理が高速化されます。 生産性がどれだけ向上/悪化し、どのように拡大するかを評価することは困難です。おそらく、今後このような研究を行うでしょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そのため、参加者スレッドごとに2つのキューを作成する必要があります。1つのキューではメッセージを送信し、他のキューから読み取ります。 これら2つのキューのプロキシコンテナ： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>    クラスthreadNode
     {
      パブリック文字列tName;
       public int tid;
       locklessQueue outgoing = new locklessQueue（）;  //メッセンジャーからノードへ 
       locklessQueue incoming = new locklessQueue（）;  //ノードからメッセンジャーへ

      パブリックthreadNode（文字列tName、int tid）
       {
         this.tid = tid;
         this.tName = tName;
       }

       public void enqueue（messengerItem message）// Nodeによって呼び出されます
       {
         incoming.produce（メッセージ）;
       }

       public bool dequeue（out messengerItem message）// Nodeによって呼び出されます
       {
        オブジェクトメッセージ;
         bool result = outgoing.consume（out msg）;
         message = messengerItemとしてのmsg;
        結果を返す;
       }

       public void transmit（messengerItem message）// Messengerによって呼び出されます
       {
         outgoing.produce（メッセージ）;
       }

       public bool retrieve（out messengerItemメッセージ）//メッセンジャーによって呼び出されます
       {
        オブジェクトメッセージ;
         bool result = incoming.consume（out msg）;
         message = messengerItemとしてのmsg;
        結果を返す;
       }
     }
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ご覧のとおり、次のクラスで表されるmessengerItem型のオブジェクトはキューに入れられています： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>    クラスmessengerItem
     {
      からの公開文字列。
      パブリック文字列
      パブリックオブジェクトメッセージ。

       public messengerItem（string from、string to、オブジェクトメッセージ）
       {
         this.from = from;
         this.to = to;
         this.message = message;
       }
     }
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Messenger.send（...）;を記述して、コードのどこからでもメッセージを送信できるように、メインクラスを静的にしました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>  パブリックスタティッククラスメッセンジャー
   {
     static Dictionary &lt;int、threadNode&gt; byTID = new myDictionary &lt;int、threadNode&gt;（）;
     static辞書&lt;string、threadNode&gt; byRegName = new myDictionary &lt;string、threadNode&gt;（）;
     static Mutex regMutex = new Mutex（）;  //一度に登録できるタスクは1つだけです
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ストリームからメッセージを送信するときに必要なノードを検索するには、辞書を使用します。キーは管理対象スレッドIDで、キーは登録時に指定された名前です。 あるノードから別のノードにメッセージを転送するために、私は自分のスレッドを開始します。ここではシェルを提供しません。つまり、無限ループで記述されたmessengerFunctionをプルし、戻り値がfalseの場合にThread.Sleepを呼び出してスライスを提供します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>    静的boolメッセンジャー関数（）
     {
       bool acted = false;
       messengerItemアイテム;
       threadNode dst;
      辞書&lt;string、threadNode&gt; tmp = byRegName;
       foreach（tmp.ValuesのthreadNodeノード）
       {
         if（tmp！= byRegName）
          休憩;
         if（node.retrieve（out item））
           if（item！= null）
           {
             acted = true;
             if（tmp.TryGetValue（item.to、out dst））
             {
               dst.transmit（アイテム）;
               sent = true;
             }
           //そうでなければ破棄
           }
       }
      リターンが行動した。
     }
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     メッセンジャーにフローを登録するには、現在ブロックしている次の関数が使用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>     
     static public void register（string tName）{if（tName == null || tName == ""）return;  int tid = Thread.CurrentThread.ManagedThreadId;  myDictionary &lt;int、threadNode&gt; newbyTID = new myDictionary &lt;int、threadNode&gt;（）;  myDictionary &lt;string、threadNode&gt; newbyRegName = new myDictionary &lt;string、threadNode&gt;（）;  threadNode newnode =新しいthreadNode（tName、tid）;  newbyTID.Add（tid、newnode）;  newbyRegName.Add（tName、newnode）;  regMutex.WaitOne（）;  foreach（byTID.ValuesのthreadNodeノード）{newbyTID.Add（node.tid、node）;  newbyRegName.Add（node.tName、node）;  } byTID = newbyTID;  byRegName = newbyRegName;  regMutex.ReleaseMutex（）;  } </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     また、同様の関数を使用して、ストリームの最後で登録を解除します。そのコードは省略します。 残っているのは、ストリームでメッセージを送受信する機能だけです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>     static public void send（文字列宛先、オブジェクトメッセージ）
     {
       int tid = Thread.CurrentThread.ManagedThreadId;
       threadNodeノード。
       if（byTID.TryGetValue（tid、out node））
         node.enqueue（新しいmessengerItem（node.tName、宛先、メッセージ））;
     }

    静的なパブリックブール受信（オブジェクトメッセージの送信、文字列送信者の送信）
     {
       int tid = Thread.CurrentThread.ManagedThreadId;
       threadNodeノード。
       if（！byTID.TryGetValue（tid、out node））
       {
        送信者= null;
        メッセージ= null;
         falseを返します。
       }
      他に
       {
       messengerItemアイテム;
       bool result = node.dequeue（out item）;
       if（！結果|| item == null）
       {
        送信者= null;
        メッセージ= null;
       }
      他に
       {
        メッセージ= item.message;
        送信者= item.from;
       }
      結果を返す;
       }
     }
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後の関数は、ループ内のハンドラースレッド、メッセージの処理、または受信されない場合はThread.Sleep（）の実行によって使用されます。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J130093/index.html">WinAPIを理解する</a></li>
<li><a href="../J130094/index.html">Facebookで問題を解決するためにSikuliを使用する特殊なケース</a></li>
<li><a href="../J130095/index.html">スパイウェアの使用で告発されたドイツの警察</a></li>
<li><a href="../J130096/index.html">MySQLデータベース用のディスクシステムの選択</a></li>
<li><a href="../J130098/index.html">プレックスメディアセンター</a></li>
<li><a href="../J130102/index.html">銀行のプラスチックカードをよく使用しますか？</a></li>
<li><a href="../J130103/index.html">セミナー「メトリックスの使用とは？」サンクトペテルブルクで</a></li>
<li><a href="../J130104/index.html">モルドバで最初のスタートアップインキュベーター-「Simpals Garage」</a></li>
<li><a href="../J130105/index.html">スパムの送信方法</a></li>
<li><a href="../J130108/index.html">最も豊かな中国の村の住民は、超高層ビルを建てました</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>