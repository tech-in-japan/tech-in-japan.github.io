<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔐 👩🏼‍🤝‍👨🏾 👩🏽‍🌾 （自己）プロセッサの識別。 パート2 毛深いCPUID 🤷🏿 🐒 🎾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最初の部分では、特定のプロセッサに存在する拡張機能を識別する必要性について話しました。 これは、実行可能コード（オペレーティングシステム、コンパイラ、またはユーザーアプリケーション）が使用できるハードウェア機能を確実に判断できるようにするために必要です。 また、以前の記事で、いくつかの一般的な汎用C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>（自己）プロセッサの識別。 パート2 毛深いCPUID</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> 最初の<a href="http://habrahabr.ru/company/intel/blog/220203/">部分で</a>は、特定のプロセッサに存在する拡張機能を識別する必要性について話しました。 これは、実行可能コード（オペレーティングシステム、コンパイラ、またはユーザーアプリケーション）が使用できるハードウェア機能を確実に判断できるようにするために必要です。 また、以前の記事で、いくつかの一般的な汎用CPUアーキテクチャを比較しました。 それらを識別するための可能性は大きく異なります：ISA拡張に関する完全な情報を提供するものもあれば、ベンダーとリビジョンを区別するために数個に制限されるものもあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このパートでは、インテル®IA-32アーキテクチャーの1つの命令、CPUIDについて説明します。これは、プロセッサーで宣言された拡張機能のリスト用に特別に導入されたものです。 彼女が登場する前に何が起こったのか、彼女はどのような驚きが待っているのか、どのソフトウェアが彼女の解釈を解釈できるのかを伝える方法を知っていることについて少し。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/405/58e/893/40558e8933ddba33adc65d42a514e763.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <sup>画像ソース：[1]</sup> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 物語 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最初の部分で述べたように、次の傾向があります。プロセッサの性質が「埋め込まれる」ほど、そのアーキテクチャに埋め込まれる識別の機会が少なくなります。 何らかの理由で、組み込みシステムの作成者は、バイナリコードの移植性について心配しません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Intel 8086も例外ではありませんでした。1970年代のマイクロプロセッサは、「計算機」シリーズ8008、8080、8085から発展しました。最初は、識別手段は組み込まれていませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      808386から、モデル、ステッピング、およびファミリに関する情報が、リブート（RESET信号の受信）の直後にEDXレジスタで報告されるようになりました。 バイト0x0f 0xa2でエンコードされたCPUID命令は、プロセッサ80486で導入されました。CPUIDの存在は、可能であればフラグレジスタのビット21に書き込むことで認識できます。 古いCPUでの作業をサポートするには、8086から80386のプロセッサを区別するために非常に洗練された方法を使用する必要がありました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">CPUIDアルゴリズム戦争（1996）</b> <div class="spoiler_text">  1996年の記事[2]で、Robert Collinsは、当時存在していたすべてのIntel IA-32製品を区別するアルゴリズムを提案しました。 彼は、普遍的ではないため、PUSH SP命令の動作の違いのみに基づいて、Intelの公式の識別方法に満足していません（これについては以下で詳しく説明します）。 ロバートは自身の研究で、次の追加のトリックを使用することを提案しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> すべてのプロセッサに存在しない命令を実行し、＃UD例外をキャッチします。 どの命令が例外をスローしなかったかを知ると、プロセッサフ​​ァミリを決定できます。 ただし、8086/8088では、サポートされていないチームの動作が定義されていないため、このアプローチは機能しません。 </li><li>  PUSH SP命令の動作は、8086と80286で異なります。最初のCPUでは、SPレジスタの値は、値が変わるまでスタックにヒットします。  80286で、このエラーは修正されました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「iAPX 286は、PUSH SPのスタックにiAPX 86/88とは異なる値をプッシュします。」 </li><li>  80186も間違ったSP値をスタックにプッシュしますが、CPUIDは引き続きサポートします。 </li><li>  8086プロセッサでオフセット0xffff（つまり、アドレス指定された最後のバイトから始まる）のセグメントにワード（16ビット）を書き込むと、このワードの2番目のバイトがオフセット0でメモリに入り、80186でこのバイトが海外に移動しますオフセット0x10000のセグメント。 </li><li> 一部のIntel PentiumクローンはCPUIDをサポートしていましたが、フラグレジスタのビット21を使用してこれを報告しませんでした。これはドキュメントと矛盾するか、ロード後にこの命令のサポートを動的に有効にすることを許可しました。 </li><li> 同じ「番号」を持つプロセッサモデル（たとえば、80386 DXと808386 SX、CX、EX、SLまたはIntel Pentium P5、P54C、OverDrive）を区別するには、サポートされている拡張機能の違いを慎重に検討する必要がありました。 </li><li>  80386 DXとSXは、CR0レジスタの変更されたビットの数の違いによって区別できます。 </li><li>  I / Oポートで文書化された一連の操作（IN / OUT命令）を使用して、一部の識別情報を取得できます。 </li><li>  80486モデルの違いは、80487数学コプロセッサーの可用性を確認することで取得できます。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      80386のステップ実行に関する情報を取得するには、RESETの直後にEDX値を読み取る必要があります。 しかし、現時点では、BIOSが動作を開始し、制御がユーザーコードに転送される前に、おそらくこのレジスタが上書きされます。 ただし、ここでロバートは、リブートプロセスを欺いて制御を得るために、悪名高いA20ラインを操作するトリッキーなスキームを発明し、説明しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     元の記事に記載されている手法は、主にIntel CPUでテストされました。 この記事では、著者は他のメーカーのx86クローンの信頼できる分類を許可していないことを認めています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> インターフェース </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     システムプログラマの場合、拡張機能を識別する作業は通常、レジスタEAX（リーフ、英語リーフ）およびECX（サブリスト、英語サブリーフ）に入力値を設定し、CPUIDを実行し、4つのレジスタEAX、EBX、ECX、EDXで結果を読み取ることで構成されます。 出力レジスタの個別のビットフィールドには、特定のプロセッサコアの関連するアーキテクチャパラメータの値に関する情報が含まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     入力シートと出力の4つのレジスタのすべての有効な組み合わせがCPUIDテーブルを形成します。 最新のプロセッサでは、4つの32ビット列からなる約12行が含まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この表の公式に説明されているすべてのフィールドについては詳しく説明しません。 興味のある人はいつでもIntel SDMで見つけることができます[1]（忍耐強くお勧めします-CPUIDについての約40ページのテキスト）。 さらに、既に発表されているが物理製品でまだリリースされていないISA拡張については、対応する新しいCPUIDフィールドが[3]にあります。 代わりに、この命令の出力から抽出できる情報を分類します。 テーブルのビットフィールドを示すために、 <b>CPUID.leaf.subleaf.reg [bitstart：bitend]</b>の表記を使用します。 たとえば、CPUID.0.EBX [31：0]-これらは、シート0を入力として受け取ったCPUIDの実行後のEBX出力レジスタのビット0〜31です（EAX = 0）。 サブリスト（入力ECX値）は無視されるため、指定されません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> シート領域 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     サポートされていない入力EAXおよびECX値は例外を発生させませんが、代わりに4つすべてのレジスタまたは「ガベージ」（仕様に応じた別のシートの値）にゼロを返します。 シートとサブシートの許容可能な組み合わせは、3つの連続した領域を形成します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/831/6e5/84c/8316e584c0e50103656e7ba0ffbc895f.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 通常の領域-ゼロから始まり、CPUID.0.EAX [31：0]に等しい最大値までの番号を持つすべてのシート。 最大シート数は常に増加しており、長い間トップ10を超えています。 </li><li> 拡張領域-0x80000000から始まり、CPUID.0x80000000.EAX [31：0]に等しい最大値までのすべてのシート。 かなり長い間、この最大値は0x80000008のままです。 ドキュメンタリーの証拠は見つかりませんでしたが、拡張シートの範囲の外観は、AMDによるIA-32アーキテクチャの64ビット拡張の導入に関連していると感じています。 </li><li> シート範囲0x40000000-0x4fffffffは予約済みと見なされます。  CPUIDによって返される値は常にゼロになることが約束されています。 ただし、これは、一部のユーザーがニーズに応じて使用することを妨げません。 たとえば、KVM仮想マシンは、シート0x40000000で4つの数値[0、0x4b4d564b、0x564b4d56、0x4d]を返します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">非表示のテキスト</b> <div class="spoiler_text"> これはASCII文字列「KVMKVMKVM」です </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  ISA </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      CPUIDでエンコードされた開業医にとって最も重要なデータは、サポートされている命令セットのフラグです。 従来、CPUID.1.ECXおよびCPUID.1.EDXのビットがこのために割り当てられていました。 以下にいくつかの例を示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  CPUID.1.ECX [0]-SSE3-ベクトル命令。 </li><li>  CPUID.1.ECX [9]-SSSE3-その他のベクトル命令。 </li><li>  CPUID.1.ECX [7]-EIST-強化されたIntelSpeedStep®、プロセッサーの周波数を動的に変更します。 </li><li>  CPUID.1.EDX [25]-SSE-より多くのベクトル命令。 </li><li>  CPUID.1.EDX [26]-SSE2-再びベクトル命令。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ただし、現在、シート1の容量が使い果たされているため、ISA拡張は他のシートのビットで示すことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  CPUID.6.EAX [1]-Intel Turbo Boost、オーバークロックで「箱から出して」。 </li><li>  CPUID.7.0.EBX [4]-ハードウェアロックエリア、CPUID.7.0.EBX [11]-制限付きトランザクションメモリ- <a href="http://software.intel.com/node/475111">トランザクションメモリ</a>をサポートするIntelの2つの拡張機能。 </li><li>  CPUID.0x80000001.ECX [5]-LZCNT、最上位ゼロビットの数をカウントするための命令で、BSRと同様（多すぎる）。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> ブランド文字列 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     もちろん、ベンダーは、製品のIDで名前を永続化する機会を逃しません。 そして、これを数字としてだけでなく、ASCII文字列を入力することをお勧めします（少なくとも、Unicodeではありません）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      IA-32では、CPUIDテキストは少なくとも2つのグループのシートにあります。  CPUID.0.EBX、ECX、EDXには、各ベンダーに固有の12バイトのASCII文字列が含まれています。  Intelの場合、これはもちろん「GenuineIntel」です。 また、CPUID.0x80000002-0x80000004の3枚のシートは、いわゆるブランド文字列をASCIIでエンコードするために最大48バイトを提供します。 これは、Linuxで<b>cat / proc / cpuinfo</b>をリストするときに表示されるものです。 また、その形式は多少標準化されていますが、「ベンダーブランドのCPUシリーズ@周波数」ですが、プログラムコードの内容を決定することは強くお勧めしません。 その内容は非常に大きく異なる可能性があります：周波数はMHzまたはGHzで示すことができます（ただし、実際には動的チューニングにより完全に異なる場合があります）、スペースは位置を変更でき、シミュレーターまたは仮想マシンはそこに何でも代用できます。 ブランド文字列からのすべての情報は、より信頼性の高い方法でプログラムで見つけることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> キャッシュ </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     タイプ、量、容量、ジオメトリ、コア間の分離可能性などのキャッシュに関する情報は、BLASライブラリ（基本線形代数システム）などの高性能数学ソフトウェアのチューニングに役立ちます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     当初、キャッシュの構成はシート2で説明されていました。 その中の情報をエンコードするためのフォーマットは、最も柔軟ではなく、将来的には、いくつかのレベルのキャッシュのボリュームと構成の絶え間ない変更をサポートすることができませんでした。 現在、シート2の情報の使用は推奨されていません。0xFF-kiが存在する場合があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     シート0x80000006が拡張範囲内にあるという事実から判断すると（まだ文書による証拠が見つかっていないかどうかはわかりませんが）、Intelによって追加されたわけではありません。 これを使用して、ソフトウェア開発者が必要とするキャッシュの構造に関するデータをシート2の情報に追加する試みが行われました。 同時に、再び、成長のためのスペースを提供する意図はありませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     シート4は、キャッシュデータの最新かつ最も柔軟な表現です。 この価格は、ECLエンコードサブシートの概念を追加したものです。 各サブリストは、データ、コード、または結合された1つのキャッシュを記述し、そのレベル、容量などを決定します。  4枚目のシートは長時間続きますか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> トポロジー </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここで言う「トポロジ」とは、もちろん数学のセクションではなく、現在のプロセッサにおける個々のコアとハイパースレッド（Intel HyperThreadingがサポートされている場合）の相対的な位置に関する情報を意味します。 最新のIntelサーバープロセッサでは、次の階層レベルが区別されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  SMTはハイパーストリームのレベルであり、個々のアーキテクチャ状態（レジスタ）を含むエンティティですが、アクチュエータを他のストリーム（1つのコアの一部）から分離する可能性があります。 </li><li> コア（コア）-コンピューティングデバイス（加算器、乗算器など）の個々のセットを含むエンティティ。  1つのコアには、1つ、2つ（ハイパースレッディングを備えたCPUの場合）または4つ（Xeon Phiの場合）のハイパースレッドを含めることができます。 </li><li> パッケージ（パッケージ）は、ストアで購入され、マザーボードのソケット（ソケット）に挿入されるハードウェアです。 少なくとも1つのコアがあります。 マルチプロセッササーバーシステムは、複数のパッケージを持つことができます。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「論理プロセッサ」の概念は、システムに存在する最低レベルに対応しています。 オペレーティングシステムが認識するのはそれらです。 それらの間のプロセス移行のコスト、データ転送の遅延、キャッシュ効果、NUMAメモリ構成などは、2つの論理プロセッサが相対的であるかどうか（つまり、それらが同じコアまたはパッケージの一部であるかどうか）に依存します。 そのため、トポロジデータがCPUIDシート0xBとそのサブシートに含まれています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さらに、周辺機器や他のプロセッサから割り込みを配信するタスクに対処するために、各論理プロセッサにはいわゆる機能があります。  APIC ID-システム内の一意の番号。 トポロジは、これらの数値が多くのアクティブな原子核に発行される法律に影響を与えます。 それらは常に一貫しているわけではありません。 たとえば、ハイパースレッディングがオフになっているシステムでは、すべてのAPIC IDが均等になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     クラシックAPIC IDはCPUID.1.EBX [31:24]フィールドに保存されます。 これは8ビットのみであり、これにより論理プロセッサの数が256に制限されますが、これはもちろん現代の現実では十分ではありません。 そのため、CPUID.0xB.EDX [31：0]に保存されているX2APIC IDという拡張子があります。 これらの32ビットは、より長い期間にわたって十分だと思います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各論理プロセッサの「座標」は、そのパッケージのトポロジで一意です。 このため、複数のCPUIDシートを連続して読み取るスレッドにアフィニティを提供するように注意してください。そうしないと、異なるコアから値を取得するリスクが生じます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 編集可能なフィールド </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     トポロジに問題がほとんどない場合は、CPUIDテーブルの内容自体がシステム操作中に動的に変化する可能性があることを急いで報告します。 もちろん、すべてのフィールドを変更できるわけではありません。 それでも、BIOS設定から、OSが使用されているCPUの機能の一部を見るかどうかに直接影響を与えることができます。 そのうちのいくつかだけをあげます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  CR4レジスタのビット18はCPUID.1：ECX.OSXSAVE [27]に影響し、XSAVE命令のサポートを示します。 </li><li>  IA32_MISC_ENABLEレジスタフィールドは、いくつかのCPUIDフィールドに一度に影響します。ビット3-TM1およびTM2フィールド、ビット16-EISTフィールド、ビット34-XDフィールド（実行無効）など。 </li><li>  IA32_MISC_ENABLEレジスタのビット22を含めると、通常、3番目より古いCPUIDテーブルのすべてのシートが「カットオフ」されます（明らかに、これはWindows NT4との互換性のために行われました。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 雑多 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このセクションでは、CPUIDチームの歴史と仕事に関連する他の興味深い点を集めました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6> プロセッサーのシリアル番号 </h6>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Pentium IIIの実行中、各プロセッサはCPUID.3.ECXおよびCPUID.3.EDXに含まれる一意のシリアル番号を受け取りました[7]。 このような機能が、コピーからのソフトウェア保護のニーズにどのように役立つかは容易に想像できます。 しかし、1999年に欧州共同体<a href="http://en.wikipedia.org/wiki/Pentium_III">は</a> 、そのような機能がそのようなシステムのユーザーのプライバシーを損なうことを合理的に恐れて<a href="http://en.wikipedia.org/wiki/Pentium_III">抗議しました</a> 。 すでにIntel Pentium IVでシリアル番号が削除され、シート3はゼロを返します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6> ベンダーとCPUID </h6>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     非常に興味深い表[5]は、異なるベンダーがCPUIDの異なるシートに保存する（または過去に保存する）ものを示しています。 たとえば、AMD K8プロセッサが文字列<a href="http://rutube.ru/video/f177a08f6624db5577efb14398826daa/">IT'S HAMMER TIMEを</a>返した特定のミステリーレベル0x8fffffffが記述されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  ISAウォーズのAgner Fog </h6>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      IA-32命令セットの拡張の歴史は、いくつかの企業間の競争を背景にしています[4]。 新しい命令を追加することは常にCPUIDに影響を及ぼし、常に正しく実行する方法について全員が同意できるとは限りません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6> 彼らはCPUIDを台無しにしました！  IA32_BIOS_SIGN_ID </h6>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      CPUID命令は、その簡潔なインターフェイスと驚きがないため、常に気に入っていました。入力に1つのレジスタ、出力に4つのレジスタがあります。 その動作には例外がなく、メモリアクセスも、フラグレジスタの読み取り/変更もありません。プレフィックスの影響を受けず、すべてのプロセッサモードで動作します。  IAC-32 CISC動物園と比較すると、ほぼ理想的でした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ...シートとシートをエンコードするには、入力用に2つのレジスタをファイルする必要が<i>ある</i>ことが判明するまで。 さて、あまり良くありません。 さて、少なくとも出力レジスタは事前に知られており、常に変更されます... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして、 <i>時には</i> CPUIDが別のレジスタ（IA32_BIOS_SIGN_ID）を変更し、現在のプロセッサマイクロコードプログラムの署名をその中に保存することが判明しました。 これは、プロセッサのファームウェアが以前に更新された場合に発生します。 何らかの理由で、この手順に関する情報はマニュアル[1]に記載されているように千ページに散らばっていたため、非常に長い間私を避けていました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  CPUIDを読み取るためのソフトウェア </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     他のいくつかのアーキテクチャとは異なり、IA-32ではCPUID命令は特権がありません。  OSカーネルだけでなく、ユーザーソフトウェアによって実行できます。 したがって、通常のプログラムは、CPUが実行する機能を自由に探索できます。 もちろん、紛らわしいバイナリ情報CPUIDを人間に優しい形式で表すために、多くのツールが作成されています。 ここにいくつかリストします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  CPU-Z <a href="http://www.cpuid.com/softwares/cpu-z.html">www.cpuid.com/softwares/cpu-z.html</a>  Windows用の非常に人気のある識別アプリケーション。 私の好みに合わせて、あまりにも簡潔。 </li><li>  CPUIDエクスプローラー。  <a href="http://www.flounder.com/cpuid_explorer2.htm">www.flounder.com/cpuid_explorer2.htm</a> より詳細で、したがってWindows用の便利なアプリケーション。 残念ながら、長い間更新されていないため、最新のCPUIDフィールドについては知りません。 ちなみに、これはこのタイプのすべてのプログラムに共通の問題です-それらは非常に早く廃止されます。 </li><li>  Windows用インテル®プロセッサー識別ユーティリティー： <a href="http://www.intel.com/support/processors/tools/piu/sb/CS-014921.htm">www.intel.com/support/processors/tools/piu/sb/CS-014921.htm</a> ただし、Intelの公式アプリケーションはあまり能力がありません。 </li><li>  Intel Open-source Technology Centerのmsr-tools： <a href="https://01.org/msr-tools">01.org/msr-tools</a>  CPUID値とMSRレジスタを取得するためのプログラム。 私が理解できない理由のために、CPUIDを読み取るにはルート権限が必要です。 さらに、命令を直接呼び出す代わりに、最も信頼性の高いLinuxカーネルインターフェイスは使用されません。 </li><li>  Linux用の別のcpuid： <a href="http://www.etallen.com/cpuid.html">www.etallen.com/cpuid.html</a> 私が見つけることができる最高のサンプル。 すべての論理プロセッサ上のすべてのフラグに関する詳細情報を出力します。 </li><li> 私は自分の自転車ggg-cpuid [6]を書き始めました。 他のアプリケーションとは異なり、私のプロジェクトの目標は、IA-32だけでなく、さまざまなアーキテクチャのプロセッサで識別情報を収集できるようにすることです。  IA-32、IA-64、およびARMで動作するようになりました。 可能な限り、時間のあるところで、さまざまなシステムを追加します。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 文学 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Intel Corporation。 インテル®64およびIA-32アーキテクチャーソフトウェア開発者マニュアル。 ボリューム<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">1〜3、2014。www.intel.com / content / www / us / en / processors / architectures-software-developer-manuals.html</a> </li><li> ロバート・R・コリンズ。  CPUIDアルゴリズムの戦争。 博士  Dobbs Journal、1996年11月<a href="http://www.drdobbs.com/database/cpuid-algorithm-wars/184410005">。www.drdobbs.com/ database / cpuid-algorithm-wars / 184410005</a> </li><li> インテル®アーキテクチャー命令セット拡張プログラミング参照。  <a href="https://software.intel.com/en-us/intel-isa-extensions">software.intel.com/en-us/intel-isa-extensions</a> </li><li> アグナー・フォグ。 命令セットの戦争を停止します。  AgnerのCPUブログ。  <a href="http://www.agner.org/optimize/blog/read.php%3Fi%3D25">www.agner.org/optimize/blog/read.php?i=25</a> </li><li>  x86アーキテクチャのCPUID。  <a href="http://sandpile.org/x86/cpuid.htm">sandpile.org/x86/cpuid.htm</a> </li><li> グリゴリー・レヒストフ。  Intel IA-32、IA-64、およびその他のシステム用のCPU識別ツールのセット。  <a href="https://github.com/grigory-rechistov/ggg-cpuid">github.com/grigory-rechistov/ggg-cpuid</a> </li><li>  Intelプロセッサの識別とCPUID命令。  AP-485アプリケーションノート、1999年<a href="http://netwinder.osuosl.org/pub/misc/docs/i386/24161812.pdf">。netwinder.osuosl.org/ pub / misc / docs / i386 / 24161812.pdf</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J220831/index.html">PHDays IVでのハッキングの専門家：ロックされたドアへの鍵の作成、ブラウザーの破壊、「スマートホーム」からの脱出</a></li>
<li><a href="../J220837/index.html">iTweenを使用した基本的なアニメーション</a></li>
<li><a href="../J220843/index.html">商業ナノテクノロジー</a></li>
<li><a href="../J220845/index.html">Reactjsガンマジェネレーター</a></li>
<li><a href="../J220849/index.html">スーパーコンピューターLomonosovのサンプルペン</a></li>
<li><a href="../J220853/index.html">金曜日の発表#FailOverConf。 そして参加者へのパン</a></li>
<li><a href="../J220859/index.html">Kerio Control 8.3リリースの新機能</a></li>
<li><a href="../J220865/index.html">一握りのリレー、または電磁リレー上のコンピューター。 パート1-ALU</a></li>
<li><a href="../J220873/index.html">ビデオ、写真、マクロ撮影用の自家製リングLED照明器</a></li>
<li><a href="../J220875/index.html">iBeaconの選択と注文の経験</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>