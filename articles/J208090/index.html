<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌵 👌🏻 ⏹️ パターン認識に関するいくつかの言葉 🚖 👨🏻‍🎓 🐤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私は長い間、画像認識の基本、基本的な方法のガイド、使用するタイミング、解決するタスク、夕方に膝の上でできること、チームなしで考えない方が良いことを含む一般的な記事を書きたいと思っていました20で。 
  
  
  
  
  
 
  
 光学認識に関する記事をかなり前に書いているので、月に数回、...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>パターン認識に関するいくつかの言葉</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> 私は長い間、画像認識の基本、基本的な方法のガイド、使用するタイミング、解決するタスク、夕方に膝の上でできること、チームなしで考えない方が良いことを含む一般的な記事を書きたいと思っていました20で。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/e3d/36e/ae7e3d36eb6c065eb592ca44d59d51f3.jpg" alt="画像"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     光学認識に関する記事をかなり前に書いているので、月に数回、このトピックに関する質問をするさまざまな人々を書いています。 異なる世界で彼らと一緒に住んでいるような気分になることがあります。 一方では、人は関連するトピックの専門家である可能性が高いことを理解していますが、光学認識方法についてはほとんど知識がありません。 そして最も厄介なことは、彼が近くの知識の分野からの方法を適用しようとしているということです。これは論理的ですが、画像認識では完全に機能しませんが、これを理解しておらず、非常に基本的なことから何かを話し始めると非常に気分を害します。 そして、基本から言うと、多くの時間はそこにしばしばありますが、それはまだ悲しいことです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事の目的は、画像認識方法を扱ったことのない人が、被写体に対応する世界の特定の基本的な絵を頭の中に作成し、掘る方向を理解できるようにすることです。 ここで説明する方法の多くは、レーダーおよび音声処理に適用されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私は、潜在的な顧客、または光学認識の作業を開始したい人に常に伝え始めるいくつかの原則から始めます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> 問題を解決するときは、常に最も単純なものから始めてください。 人をフォローするよりも、人にオレンジ色のマークを付ける方がはるかに簡単で、カスケードで人を強調します。 超解像アルゴリズムを開発するよりも、高解像度のカメラを使用する方がはるかに簡単です。 </li><li> 光学式認識方法における問題の厳密な説明は、システムプログラミングタスクよりも桁違いに重要です。TORの1つの余分な単語で作業の50％を追加できます。 </li><li> 認識の問題に普遍的な解決策はありません。 単に「碑文を認識する」アルゴリズムを作成することは不可能です。 道路標識とテキストシートは、根本的に異なるオブジェクトです。 おそらく一般的なアルゴリズムを作成できます（ <a href="http://habrahabr.ru/post/208330/">ここに</a> Googleの良い例があります）が、それは大規模なチームの多くの作業を必要とし、多数の異なるサブプログラムで構成されます。 </li><li>  OpenCVは多くの方法があり、ほとんどすべてのタスクのボリュームの50％を解決できる聖書ですが、OpenCVは実際にできることのほんの一部にすぎません。 ある研究では、結論は次のように述べています：「問題はOpenCVメソッドによって解決されないため、解決できません。」 これを避けるようにしてください。怠け者ではなく、OpenCVテンプレートを使用せずに、毎回現在のタスクを一から真面目に評価してください。 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ある種の普遍的なアドバイスをしたり、任意のコンピュータービジョンの問題の解決策を構築できるような構造を作成する方法を伝えることは非常に困難です。 この記事の目的は、使用できるものを構造化することです。 既存のメソッドを3つのグループに分けてみます。 最初のグループは、事前フィルタリングと画像準備です。  2番目のグループは、フィルタリング結果の論理処理です。  3番目のグループは、論理処理に基づく意思決定アルゴリズムです。 グループ間の境界は非常にarbitrary意的です。 問題を解決するために、すべてのグループからメソッドを適用することは常に必要というわけではありません; 2つ、時には1つでも十分です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここに記載されているメソッドのリストは完全ではありません。 私が書いていないコメントに重要なメソッドを追加し、それぞれに2〜3個の付随する単語を割り当てることをお勧めします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> パート1.フィルタリング </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このグループでは、画像を分析せずに画像上の関心のある領域を選択できるメソッドを配置します。 これらの方法のほとんどは、画像のすべてのポイントに何らかの均一な変換を適用します。 フィルタリングレベルでは、画像分析は実行されませんが、フィルタリングを通過するポイントは特別な特性を持つ領域と見なすことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> しきい値の二値化、ヒストグラム領域の選択 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最も単純な変換は、しきい値による画像の2値化です。  RGB画像とグレースケール画像の場合、しきい値は色の値です。 このような変換で十分な理想的な問題があります。 白い紙の上のオブジェクトを自動的に選択するとします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/b22/e12/c6d/b22e12c6d33eb898e34b373475be35d8.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/488/3fc/968/4883fc968b29368610812ce4069374bd.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2値化が発生するしきい値の選択により、2値化のプロセス自体が大きく決まります。 この場合、画像は中間色で2値化されています。 通常、2値化は、しきい値を適応的に選択するアルゴリズムを使用して実行されます。 そのようなアルゴリズムは<a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D0%25BE%25D0%25B6%25D0%25B8%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">予想</a>か<a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">モードの</a>選択であるかもしれません。 また、ヒストグラムの最大ピークを選択できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/218/61b/6f8/21861b6f804cbee1bb4d114e5172ba25.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      RGBではなく<a href="http://ru.wikipedia.org/wiki/HSV_(%25D1%2586%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C)">HSV</a>で画像を表示している状況を含め、ヒストグラムを操作する場合、2値化は非常に興味深い結果をもたらします。 たとえば、興味深い色をセグメント化します。 この原理に基づいて、 <a href="http://robocraft.ru/blog/computervision/402.html">タグ</a>検出器と人間の<a href="http://wiki.technicalvision.ru/index.php/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2586%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">皮膚</a>検出器の両方を構築することができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e74/fa9/aab/e74fa9aab389c80be4e817b979536be1.jpg" alt="画像"><img src="https://habrastorage.org/getpro/habr/post_images/060/88f/03f/06088f03f4428973e5820898caa5b22b.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> クラシックフィルタリング：フーリエ、ローパスフィルター、ハイパスフィルター </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     レーダーおよび信号処理からの古典的なフィルタリング方法は、多くのパターン認識タスクに正常に適用できます。 レーダーでの従来の方法は、純粋な画像ではほとんど使用されませんが、 <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5">フーリエ変換</a> （より具体的には<a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%259F%25D0%25A4">FFT</a> ）です。  1次元フーリエ変換を使用する数少ない例外の1つは、 <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BA%25D0%25BE%25D1%2581%25D0%25B8%25D0%25BD%25D1%2583%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">画像圧縮</a>です。 画像を分析するには、通常、1次元の変換では十分ではありません。リソースを集中的に使用する<a href="http://wiki.technicalvision.ru/index.php/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5._%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25B2_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">2次元の変換</a>を使用する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/82a/cb7/df3/82acb7df3dd93ca01b7b06d44d7024f7.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     実際に計算する人はほとんどいません。通常、既製のフィルターを使用して関心領域の<a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BA%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7)">畳み込み</a>を使用すると、高周波数（高域）または低周波数（低域）に合わせてはるかに速く簡単に使用できます。 もちろん、そのような方法ではスペクトルの分析はできませんが、特定のビデオ処理の問題では、結果ではなく分析が通常必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/afb/21e/10e/afb21e10e2fe6350aabf6e5e9fc07527.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/3df/044/d41/3df044d411cdbb4b3489a7e38c0752ab.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     低周波数（ <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%2593%25D0%25B0%25D1%2583%25D1%2581%25D1%2581%25D0%25B0">ガウスフィルター</a> ）と高周波数（ <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%2593%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2580%25D0%25B0">ガボールフィルター</a> ）を強調するフィルターの最も簡単な例。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     各画像ポイントに対して、ウィンドウが選択され、同じサイズのフィルターで乗算されます。 この畳み込みの結果は、新しいポイント値です。 ローパスフィルターとハイパスフィルターを実装すると、このタイプの画像が取得されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/40c/7f0/e01/40c7f0e012381013b5405ae7dae3faab.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/222/113/772/2221137721f1b755fd4c0410c491c671.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> ウェーブレット </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、信号との畳み込みに任意の特性関数を使用するとどうなりますか？ その後、 <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582">ウェーブレット変換</a>と呼ばれます。 ウェーブレットのこの定義は正しくありませんが、多くのチームでは、ウェーブレット解析は、このパターンのモデルとの畳み込みを使用して、画像内の任意のパターンの検索を指すと伝統的に開発されてきました。 ウェーブレット分析で使用される一連の古典的な関数があります。 これらには、 <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582_%25D0%25A5%25D0%25B0%25D0%25B0%25D1%2580%25D0%25B0">Haar</a> <a href="http://en.wikipedia.org/wiki/Morlet_wavelet">ウェーブレット、Morlet</a> <a href="http://en.wikipedia.org/wiki/Mexican_hat_wavelet">ウェーブレット、Mexican hatウェーブレット</a>などが含まれます。 以前の記事（ <a href="http://habrahabr.ru/post/198338/">1、2</a> ）のいくつかがあったHaarプリミティブは、このような2次元空間の関数に関連しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/dd0/3af/963/dd03af9639fa83ed93d60e3d92402a25.jpg" alt="画像"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/508/e71/2d2508e71a8ad542e7cd1f9265936298.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/8ec/7c9/513/8ec7c951329026bdb3fa107c8962a170.png" alt="画像"><img src="https://habrastorage.org/getpro/habr/post_images/55e/e9b/1d9/55ee9b1d9d489a87a7ead47c03b38615.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     上記は、古典的なウェーブレットの4つの例です。  3次元Haarウェーブレット、2次元Meyerウェーブレット、Mexican Hatウェーブレット、Daubechiesウェーブレット。 ウェーブレットの拡張解釈を使用する良い例は、目のグレアを見つける問題です。グレア自体はウェーブレットです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/fa0/dbb/528/fa0dbb5283a281adb910d7a1b9860bdd.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     古典的なウェーブレットは通常、 <a href="http://habrahabr.ru/post/169615/">画像</a>を<a href="http://habrahabr.ru/post/169615/">圧縮し</a>たり、それらを分類するために使用されます（以下で説明します）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 相関関係 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ウェーブレットのこのような自由な解釈の後、私の側では、それらの根底にある実際の相関に言及する価値があります。 画像をフィルタリングする場合、これは不可欠なツールです。 古典的なアプリケーションは、ビデオストリームを<a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2580%25D1%2580%25D0%25B5%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F_%25D1%2586%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D1%258B%25D1%2585_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">相関</a>させてシフトまたは光ストリームを見つけることです。 ある意味では、最も単純なシフト検出器は差分相関器です。 画像が相関しない場合、動きがありました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/64f/21f/2b1/64f21f2b185d9e6ae442a81140599b48.jpg" alt="画像"><img src="https://habrastorage.org/getpro/habr/post_images/650/7d6/0f3/6507d60f3c2d772be9a46923164e214f.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/c9f/196/cfd/c9f196cfd69ec31a9e337c8fd13cf5b8.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 関数フィルタリング </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フィルタの興味深いクラスは、関数のフィルタリングです。 これらは、画像内の単純な数学関数（線、放物線、円）を検出できる純粋に数学的なフィルターです。 蓄積画像が構築され、元の画像の各点に対して、それを生成する多くの関数が生成されます。 最も古典的な変換は、直線の<a href="http://ru.wikipedia.org/wiki/%25CF%25F0%25E5%25EE%25E1%25F0%25E0%25E7%25EE%25E2%25E0%25ED%25E8%25E5_%25D5%25E0%25F4%25E0">ハフ</a>変換です。 この変換では、各点（x; y）に対して、線y = ax + bの点のセット（a; b）が描かれます。 美しい写真になります： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/f4d/046/1f8/f4d0461f88459af23e8505b5ddfee8ec.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      （最初のプラスは、写真とその定義でキャッチを最初に見つけて説明する人に、2番目のプラスは、ここに示されていることを最初に言う人にあります） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ハフ変換を使用すると、パラメーター化可能な関数を見つけることができます。 たとえば、 <a href="http://locv.ru/wiki/6.6.2_%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A5%25D0%25B0%25D1%2584%25D0%25B0_%25D0%25B4%25D0%25BB%25D1%258F_%25D0%25BE%25D0%25BA%25D1%2580%25D1%2583%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">circles</a> 。 任意の<a href="http://habrahabr.ru/post/141438/">形状</a>を検索できる変更された変換があります。 この変換は数学者に非常に愛されています。 しかし、画像を処理する場合、残念ながら常に機能するとは限りません。 非常に遅い速度、2値化の品質に対する非常に高い感度。 理想的な状況であっても、他の方法で対処することを好みました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     直線のハフ変換<a href="http://wiki.technicalvision.ru/index.php/%25D0%25A1%25D0%25B2%25D1%258F%25D0%25B7%25D1%258C_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25A5%25D0%25B0%25D1%2584%25D0%25B0_%25D1%2581_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC_%25D0%25A0%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BD%25D0%25B0">の類似物は</a> <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A0%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BD%25D0%25B0">ラドン変換</a>です。 これはFFTを介して計算され、多くのポイントがある状況でパフォーマンスが向上します。 さらに、2値化されていない画像にも適用できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> ループフィルタリング </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フィルタの別のクラスは、境界線と<a href="http://ru.wikipedia.org/wiki/%25C2%25FB%25E4%25E5%25EB%25E5%25ED%25E8%25E5_%25E3%25F0%25E0%25ED%25E8%25F6">輪郭の</a>フィルタリングです。 アウトラインは、画像の操作からその画像内のオブジェクトの操作に移行する場合に非常に役立ちます。 オブジェクトが非常に複雑であるが、十分に区別されている場合、多くの場合、オブジェクトを操作する唯一の方法はその輪郭を選択することです。 回路のフィルタリングの問題を解決するアルゴリズムがいくつかあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%259A%25D1%258D%25D0%25BD%25D0%25BD%25D0%25B8">カメラマンキャニー</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25BB%25D1%258F">ソーベル演算子</a> </li><li>  <a href="http://wiki.technicalvision.ru/index.php/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D1%258B_%25D0%259C%25D0%25B0%25D1%2580%25D1%2580%25D0%25B0_%25D0%25B8_%25D0%259B%25D0%25B0%25D0%25BF%25D0%25BB%25D0%25B0%25D1%2581%25D0%25B0">ラプラス演算子</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D1%258E%25D0%25B8%25D1%2582%25D1%2582">オペレータープレウィット</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BA%25D1%2580%25D1%2591%25D1%2581%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25A0%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582%25D1%2581%25D0%25B0">ロバーツ演算子</a> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最もよく使用されるのはケニーです。彼はうまく機能し、その実装はOpenCVで行われています（Sobelもありますが、輪郭をより悪く探しています）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/72c/1b1/ec6/72c1b1ec63f3c30867bd7b9745f7e482.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/a4e/1ca/144/a4e1ca1441026ec7f96395b714a1adc0.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> その他のフィルター </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フィルターは上にありますが、その修正はタスクの80-90％を解決するのに役立ちます。 ただし、それらのほかに、ローカルタスクで使用されるよりまれなフィルターがあります。 このようなフィルターは多数ありますが、それらすべてを提供するわけではありません。 反復フィルター（たとえば、 <a href="http://habrahabr.ru/post/155759/">外観のアクティブモデル</a> ）は、ラドン変換の分野での古典的なウェーブレットフィルター処理と分析の合金である<a href="http://www.myshared.ru/slide/103352/">リッジ</a>変換と<a href="http://fetmag.mrsu.ru/2009-2/pdf/curvelet-irlyanov.pdf">曲線</a>変換と同様に興味深いものです。  <a href="http://yudin-niip-rggru.narod.ru/htm/pdf/BeamletsMultiscaleImageAnal.pdf">ビームレット変換</a>は、ウェーブレット変換と論理解析の境界で美しく機能し、輪郭を強調できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/19b/6bc/73e/19b6bc73eafb6f9f3556a04beb2513e2.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     しかし、これらの変換は非常に具体的であり、まれなタスクに適しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> パート2.フィルタリング結果の論理処理 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フィルタリングは、処理に適したデータのセットを提供します。 しかし、多くの場合、このデータを処理せずにそのまま使用することはできません。 このセクションでは、画像からオブジェクトのプロパティ、またはオブジェクト自体に切り替えることができるいくつかの古典的な方法があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 形態学 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私の意見では、ろ過から論理への移行は数学的形態学の方法です（ <a href="http://wiki.technicalvision.ru/index.php/%25D0%259C%25D0%25BE%25D1%2580%25D1%2584%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8_%25D0%25BD%25D0%25B0_%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%25D1%2585">1、2、3</a> ）。 実際、これらはバイナリイメージの構築と収縮の最も単純な操作です。 これらの方法を使用すると、利用可能な要素を増減することにより、バイナリイメージからノイズを除去できます。 数学的モルフォロジーに基づいた輪郭アルゴリズムがありますが、通常、何らかのハイブリッドアルゴリズムまたはアルゴリズムを組み合わせて使用​​します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e55/34d/6bf/e5534d6bf4f92bb6dcfab74c740bf210.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 輪郭解析 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フィルタリングのセクションでは、すでに境界生成アルゴリズムについて言及しています。 結果の境界は、非常に単純に輪郭に変換されます。 ケニーのアルゴリズムの場合、これは自動的に行われますが、他のアルゴリズムの場合、追加の二値化が必要です。  <a href="http://wiki.technicalvision.ru/index.php/%25D0%2592%25D1%258B%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B8_%25D0%25BE%25D0%25BF%25D0%25B8%25D1%2581%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2583%25D1%2580%25D0%25BE%25D0%25B2">バグ</a>アルゴリズムなどにより、バイナリアルゴリズムの輪郭を取得できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     輪郭は、オブジェクトの固有の特性です。 多くの場合、これにより輪郭に沿ってオブジェクトを識別できます。 これを行う強力な数学的装置があります。 この装置は輪郭解析（ <a href="http://robocraft.ru/blog/computervision/640.html">1、2</a> ）と呼ばれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/254/667/6b9/2546676b92cc3e1e41b07fded672288e.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     正直に言うと、輪郭解析を実際の問題に適用することに成功したことはありません。 理想的な条件が必要です。 境界線がないか、ノイズが多すぎます。 しかし、理想的な条件で何かを認識する必要がある場合、輪郭解析は素晴らしいオプションです。 非常に高速で、美しい数学と明確なロジックが機能します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 特徴点 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://en.wikipedia.org/wiki/Feature_detection_(computer_vision)">特別なポイントと</a>は、オブジェクトをオブジェクト自体または類似のオブジェクトクラスにマップできるようにするオブジェクトの固有の特性です。 そのような点を強調する方法は数十あります。 隣接するフレームの特異点を強調表示するメソッドもあれば、長時間にわたって照明を変更するとき、オブジェクトを回転させたときにも残る特別なポイントを見つけることができるメソッドもあります。 それほど安定していないが、すぐに計算される特異点を見つけることができる方法から始めましょう。次に、複雑さを増していきます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>ファーストクラス。</b>  <b>数秒間安定している特別なポイント。</b> このようなポイントは、ビデオの隣接するフレーム間でオブジェクトを誘導したり、隣接するカメラの画像を縮小したりするのに役立ちます。 これらのポイントには、画像の局所的な最大値、画像内の<a href="http://en.wikipedia.org/wiki/Corner_detection">角度</a> （最高の検出器、おそらく<a href="http://www.intuit.ru/studies/courses/10621/1105/lecture/17983">ハリス</a>検出器）、分散の最大値に到達する点、特定の勾配などが含まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>2番目のクラス。</b>  <b>オブジェクトの照明と小さな動きを変更するときに安定している特別なポイント。</b> このようなポイントは、主にトレーニングとその後のオブジェクトタイプの分類に役立ちます。 たとえば、歩行者分類器または顔分類器は、そのような点に特化して構築されたシステムの製品です。 前述のウェーブレットのいくつかは、そのようなポイントの基礎になる場合があります。 たとえば、Haarプリミティブ、グレアの検索、他の特定の機能の検索。 このようなポイントには、有向勾配のヒストグラム（ <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%25BD%25D0%25B0%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25B4%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2">HOG</a> ）の方法で見つかったポイントが含まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>3年生。</b>  <b>安定したポイント。</b> 私は、完全な安定性を提供する2つの方法と、それらの変更についてのみ知っています。 これらは<a href="http://habrahabr.ru/post/103107/">SURF</a>と<a href="http://habrahabr.ru/post/106302/">SIFT</a>です。 画像を回転させても特別なポイントを見つけることができます。 このようなポイントの計算には、他の方法と比較して時間がかかりますが、かなり時間がかかります。 残念ながら、これらの方法は特許を取得しています。 ロシアでは、特許アルゴリズムはnizyaですが、国内市場で使用してください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://www.youtube.com/embed/v-869dTqeV0%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700256,15700259,15700262,15700265,15700271,15700280,15700283&amp;usg=ALkJrhi6Eu4T-GXc86Wq2vi8zSQ9FwMC4A" frameborder="0" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> パート3.トレーニング </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ストーリーの最後の部分は、画像を直接操作するのではなく、意思決定を可能にする方法に専念します。 これらは主に機械学習と意思決定のさまざまな方法です。 最近YandyksはHabrにこのテーマの<a href="http://habrahabr.ru/company/yandex/blog/208034/">コース</a>を投稿しました。非常に良い選択があります。 これはテキスト版です。 トピックに関する真剣なレッスンのために、それらを見るのを強くお勧めします。 ここでは、特にパターン認識で使用されるいくつかの基本的な方法を特定しようとします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     状況の80％で、認識問題のトレーニングの本質は次のとおりです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     オブジェクトのいくつかのクラスがあるテスト選択があります。 写真の中の人の存在/不在とします。 各画像には、Haar、HOG、SURF、または何らかのウェーブレットなど、何らかの機能によって強調表示された一連の機能があります。 学習アルゴリズムは、新しい画像を分析し、どのオブジェクトが画像上にあるかを判断できるモデルを構築する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これはどのように行われますか？ 各テスト画像は、特徴空間のポイントです。 その座標は、画像内の各標識の重みです。 サインを次のようにします。「目の存在」、「鼻の存在」、「両手の存在」、「耳の存在」など。人間。 そのようなスペースにいる人にとって、ポイント[1; 1; 1; 1; ..]は正しいでしょう。 サルの場合、ポイント[1; 0; 1; 0 ...]で、ウマの場合[1; 0; 0; 0 ...]。 分類器は例のサンプルでトレーニングされます。 しかし、すべての写真ですべての手が目立ったわけではなく、他の人には目がありませんでした。3番目の猿では、分類エラーのために人間の鼻がありました。 人の訓練された分類器は、次のような方法で記号のスペースを自動的に分割します。最初の記号が0.5 &lt;x &lt;1の範囲にある場合、2番目は0.7 &lt;y &lt;1などです。これは人です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     本質的に、分類子の目的は、属性オブジェクトに分類オブジェクトに特徴的な領域を描画することです。 これは、2次元空間での分類子の1つ（AdaBoost）の答えに対する一貫した近似がどのように見えるかです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="http://img-fotki.yandex.ru/get/6730/6107910.16/0_746ae_ecf49235_M.png" alt="画像"><img src="https://habrastorage.org/getpro/habr/post_images/8c9/170/ced/8c9170ced44434893558479b0fb621c4.png" alt="画像"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/f73/6a6/7ecf736a6d7b99d851f8f406dddfc973.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/a0e/01f/89f/a0e01f89f928f26d28dce8868705d902.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     非常に多くの分類子があります。 それぞれが独自のタスクでより良く機能します。 特定のタスクの分類子を選択するタスクは、主に芸術です。 トピックに関するいくつかの美しい写真を以下に示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5> 単純な場合、1次元の分離 </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     例として、属性空間が1次元であり、2つのクラスを分離する必要がある場合の分類の最も単純なケースを調べてみましょう。 状況は見かけよりも一般的です。たとえば、2つの信号を区別したり、パターンをパターンと比較したりする必要がある場合です。 トレーニングサンプルを用意します。 この場合、X軸に沿った類似性の測度と、Y軸に沿ったそのような測度を持つイベントの数の画像が取得されます。 目的のオブジェクトが自分自身に似ていると、左のガウス型になります。 好きではない場合-右。  X = 0.4の値はサンプルを分割するため、誤った決定により、誤った決定が行われる可能性が最小限に抑えられます。 分類の問題は、このようなセパレーターの検索です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/27c/11b/960/27c11b960e46d4c38bbb71e42f32c111.png" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ちょっとした発言。 エラーを最小化する基準は常に最適とは限りません。 次のグラフは、実際の虹彩認識システムのグラフです。 このようなシステムの場合、基準は、部外者がオブジェクトに誤ってパスする可能性を最小限に抑えるように選択されます。 このような確率は、「第1種の間違い」、「誤報の確率」、「誤反応」と呼ばれます。 英文学では「False Access Rate」。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/ce6/d35/fdb/ce6d35fdbec30f6903ca88177ba631b9.gif" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  3つ以上の測定がある場合はどうすればよいですか？ </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     たくさんのアルゴリズムがあります。 でもたくさん。 それぞれについて詳しく知りたい場合は、上記のリンク先のVorontsovコースを読み、Yandyksの講義をご覧ください。 どのアルゴリズムがどのタスクに最適であるかを言うことは、多くの場合事前に不可能です。 ここでは主なものを強調します。90％で初心者が最初のタスクを支援し、プログラミング言語での実装がインターネットで確実に見つかります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>k-means</b> （ <a href="http://habrahabr.ru/post/146556/">1、2、3</a> ）は、最も単純な学習アルゴリズムの1つです。 もちろん、これは主にクラスタリング用ですが、トレーニングもできます。 オブジェクトのグループに十分な間隔の重心があり、大きな交差点がない場合に機能します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>AdaBoost</b> （ <a href="http://cmp.felk.cvut.cz/~sochmj1/adaboost_talk.pdf">1、2、3</a> ）AdaBustは最も一般的な分類子の1つです。 たとえば、Haarカスケードはその上に構築されます。 通常、バイナリ分類が必要なときに使用されますが、他のクラスの指導を妨げるものはありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      SVM（ <a href="http://habrahabr.ru/post/105220/">1、2、3、4</a> ）多くの実装を持つ最も強力な分類子の1つ。 原則として、私が遭遇した学習の問題に関して、彼はアダバストと同様に働きました。 十分に高速であると考えられていますが、そのトレーニングはAdabustaのトレーニングよりも複雑であり、正しいカーネルを選択する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まだニューラルネットワークと回帰があります。 しかし、それらを簡単に分類し、それらがどのように異なるかを示すためには、これよりはるかに多くの記事が必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ________________________________________________ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     数学や説明に飛び込むことなく、使用したメソッドの概要を簡単に把握できたことを願っています。 たぶんこれは誰かを助けるでしょう。 もちろん、この記事は不完全であり、ステレオ画像の操作についても、カルマンフィルターを使用したOLSについても、適応型ベイジアンアプローチについての言葉もありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この記事が気に入ったら、既存のImageRecognitionタスクをどのように解決するかの例を選択して、2番目のパートを実行してみます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> そして最後に </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     何を読む？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1）かつてB. Yanaの「Digital Image Processing」という本が本当に好きで、それは簡単かつ明確に書かれていますが、同時にほとんどすべての数学が紹介されています。 既存の方法に慣れるのに適しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2）このジャンルの古典はRゴンザレス、R。ウッズの「デジタル画像処理」です。 なんらかの理由で、最初のものよりも難しくなりました。 はるかに少ない数学ですが、より多くの方法と写真。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      3）「マシンビジョン問題の画像の処理と分析」-PhysTechの部門の1つで教えられたコースに基づいて書かれています。 多くの方法とその詳細な説明。 しかし、私の意見では、本には2つの大きなマイナス点があります。本はそれに付属するソフトウェアパッケージに非常に焦点を当てています。本では、単純な方法の説明が数学的な野生になりすぎて、方法の構造図を作成するのが難しいことが多い しかし、著者はほぼすべてのコンテンツが<a href="http://wiki.technicalvision.ru/">表示される</a>便利なサイトを作成しました<a href="http://wiki.technicalvision.ru/">-wiki.technicalvision.ru</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      4）何らかの理由で、画像認識と機械学習の授業中に生じる世界の絵を構築しリンクする良い本は、ジェフ・ホーキンスによる「インテリジェンスについて」であるように思えます。 直接的な方法はありませんが、直接的な画像処理方法がどこから来たのかを考える多くの考えがあります。 それを読むとき、あなたはすでに人間の脳を動かす方法を見たことを理解しますが、ビデオ処理のタスクで。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J208074/index.html">Snapchatはユーザーのデータ漏洩を確認したが、謝罪しなかった</a></li>
<li><a href="../J208078/index.html">Google VP9 Video Codecは、ほとんどのメーカーからサポートを受けています</a></li>
<li><a href="../J20808/index.html">Yahoo! Go 3.0beta</a></li>
<li><a href="../J208086/index.html">NSAは、あらゆる種類の暗号化を解読するために量子コンピューターに取り組んでいます（しかし、これまでのところ成功していません）</a></li>
<li><a href="../J208088/index.html">ソロモンの並べ替え</a></li>
<li><a href="../J208092/index.html">OpenCVカスケードHaarの学習</a></li>
<li><a href="../J208096/index.html">FirefoxでRC4暗号化を無効にする</a></li>
<li><a href="../J208100/index.html">IT製品とIT会社の名前の選び方</a></li>
<li><a href="../J208104/index.html">開いているファイルを復元しますが、Linuxファイルシステムから削除します</a></li>
<li><a href="../J208106/index.html">Cisco TelePresenceの紹介</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>