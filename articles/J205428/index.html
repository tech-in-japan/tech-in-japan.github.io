<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏼 🧑🏻‍🤝‍🧑🏻 🤷🏼 認識におけるフィンガー線形回帰 👩🏽‍🤝‍👨🏼 🤼 ▫️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="認識問題では、重要な役割はオブジェクトの重要なパラメーターの選択とその数値の評価によって演じられます。 それでも、良い数値データを受け取った後でも、それらを正しく使用できなければなりません。 問題のさらなる解決は簡単であるように思われ、数値データから認識結果を取得するために「一般的な考慮事項から」し...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>認識におけるフィンガー線形回帰</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"><img align="right" alt="   " title="フィンガー線形回帰" src="https://habrastorage.org/getpro/habr/post_images/397/c30/f7f/397c30f7f15c5c68834c1471b1f64206.jpg"> 認識問題では、重要な役割はオブジェクトの重要なパラメーターの選択とその数値の評価によって演じられます。 それでも、良い数値データを受け取った後でも、それらを正しく使用できなければなりません。 問題のさらなる解決は簡単であるように思われ、数値データから認識結果を取得するために「一般的な考慮事項から」したい場合があります。 しかし、この場合の結果は最適にはほど遠いです。 この記事では、認識問題の例によって、最も単純な数学モデルを簡単に適用し、それによって結果を大幅に改善する方法を示したいと思います。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> パターン認識問題について </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D0%25BF%25D0%25BE%25D0%25B7%25D0%25BD%25D0%25B0%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2">パターン認識</a>のタスクは、オブジェクトを特定のクラスに割り当てるタスクです。 クラスが属するかどうかを判断するために、特定のオブジェクトパラメータのセットが使用されます。 たとえば、目の間の距離、肌の色、鼻の長さ、虹彩パターン、特徴的な音声の頻度、指の数などのいくつかのパラメータで人を認識することができます。 <img align="right" title="分類タスク" src="https://habrastorage.org/getpro/habr/post_images/774/33f/22b/77433f22bf4f8273fc986380098ac829.jpg"> これらのパラメーターは、固定次元の数値ベクトルとして表すことができます（数値パラメーターの場合、これは簡単です。虹彩/顔の画像の色/パターンなどについては、これを行う方法を理解する必要があります）。 つまり、特定の数のクラスX <sub>1</sub> 、X <sub>2</sub> 、... X <sub>N</sub>があり、パラメータ値のセットで記述されたプロトタイプがあります <img src="https://habrastorage.org/getpro/habr/post_images/8f5/994/04f/8f599404f573f8c2e9d69dee1e3e9c6c.gif">  、そして、彼がこれらのクラスのいずれかに属しているかどうかについて彼に言いたい。 通常、クラスはこのクラスのいくつかのサンプルの形式で提示されます。たとえば、異なる角度からのオブジェクトの視覚画像、さまざまなパラメーター測定、虹彩写真のさまざまなコピーなどです。 次に、認識の最も簡単な方法は、受信したオブジェクトを各クラスの各サンプルと比較し、最も近いオブジェクトまでの距離に応じてそれが彼であるかどうかを決定することです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一見すると、タスクは無数のクラスを持つ分類タスクのように聞こえます。オブジェクトの各タイプは個別のクラスであり、新しいオブジェクトは各クラスと比較する必要があります。 <img title="マルチクラス分類問題" align="right" src="https://habrastorage.org/getpro/habr/post_images/dc2/122/36a/dc212236a5a83e8a19a0c5793642765a.jpg"> これは、特にクラスの数に制限がない場合、かなり難しいタスクです。たとえば、人を認識する場合、データベースにいない人、つまり別のクラスの人が通過できます。 しかし実際には、調査対象のオブジェクトとクラスサンプルとの差dxを計算し、それが同じオブジェクトであるか異なるかを判断します。 たとえば、指紋で人を認識したい場合、結果の指紋を特定のデータベースからのすべての指紋と比較し、指紋の各ペア間の類似性の尺度を計算し、最も類似した指紋のこの類似性の尺度について、同じであると判断します印刷物が非常に類似している場合、または最も類似した印刷物がまだ類似していない場合、この人物がデータベースにない場合。 つまり、分類器はオブジェクトxのパラメーターを入力として受け入れませんが、2つのオブジェクトのパラメーターの差dx = x-x <sup>i</sup> （各コンポーネントの差のモジュールを取り、減算順序が重要でないようにすることをお勧めします）、これらのパラメーターの特性（類似性の尺度）を提供します）、決定を下すことができます：これらは同じオブジェクトまたは異なるオブジェクトです。 <img title="2クラス分類問題" align="right" src="https://habrastorage.org/getpro/habr/post_images/ddf/fdf/862/ddffdf862c5e9142219fd0a63ce04d83.jpg"> これは、「同一のオブジェクトのペア」と「異なるオブジェクトのペア」という2つのクラスを持つ分類問題と見なすことができます。 さらに、「同一のペア」のクラスはゼロに近くグループ化され、異なるものは-反対に、傍観者のどこかになります。 従来、分類子は類似性の数値的尺度（たとえば、0から1）を提供する必要があります。これは、これらが異なるオブジェクトである可能性が高いほど大きくなります。 さらに、システムの要件に応じて、 <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D1%2588%25D0%25B8%25D0%25B1%25D0%25BA%25D0%25B8_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B8_%25D0%25B2%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B3%25D0%25BE_%25D1%2580%25D0%25BE%25D0%25B4%25D0%25B0">第1種および第2種のエラーが</a>依存する決定を行うためのしきい値が決定されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> しない方法 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最初に、これらのパラメーターを見て、差分ベクトルのノルム、つまりコンポーネントの平方和のルートを見つけたいだけです。 <img src="https://habrastorage.org/getpro/habr/post_images/510/f7d/9f5/510f7d9f5f5085128a186fed8b626218.gif">  。 つまり、パラメーターが座標と見なされる場合、サンプル間のユークリッド距離として。 小さいほど、これら2つのオブジェクトは「類似」している、つまり、同じである可能性が高くなります。 これは正しいですが、いくつかの制限があります。すべてのパラメーターは無相関（相互に独立）でなければならず、それらは同じ分布でなければなりません（それらは同等でなければなりません）。 通常、これは当てはまりません（たとえば、身長と体重は独立していると見なされるべきではなく、鼻の形は口の形や髪の長さよりもはるかに信頼性の高い特性です）。 次に、より重要なパラメーターを強化し、重要性の低いパラメーターを弱めるために、異なるコンポーネントに異なる重みを選択しましょう。 <img src="https://habrastorage.org/getpro/habr/post_images/7fc/a33/ebf/7fca33ebf9be4964be2d94a091b76b54.gif">  。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここで非常に正しい考えに至ります。すべての種類の係数を頭からではなく、実践から、つまりデータセットでうまく機能するように選択する必要があります。 機械学習では、これは<a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581_%25D1%2583%25D1%2587%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BC">「教師による学習」</a>と呼ばれます：一連のデータ（異なるクラスと同一のクラスのオブジェクト、それらがどのクラスに属するかを最初に知る）が取得され、「トレーニングサンプル」と呼ばれます。可能な限り最適に機能しました（これを「トレーニング」と呼びます）。 次に、「テストサンプル」と呼ばれる別のデータセットにモデルを適用することで、モデルがどのように機能するかを確認し、どの程度うまくいったかを結論付けることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そのため、重みを決定します。 これを行うには、テストサンプルからオブジェクトのすべてのペアを調べ、各コンポーネントについて、同じペアと異なるペアの平均値と分散を計算します。 しかし、これで次に何をするかは明確ではありません。 重みは大きくする必要があり、平均値間の距離は大きくなります（ <img src="https://habrastorage.org/getpro/habr/post_images/91c/607/695/91c607695a7ea1bdf5ac08bc8e8a765e.gif">  ）さらに、分散が非常に大きい場合、つまり、情報よりもコンポーネントの方がノイズである可能性が高い場合、それらを小さくする必要があります。 この段階での私の最適化の試みはすべて、最も重要なコンポーネントの1つを使用する必要があり、残りを考慮する必要がないという事実につながりました。これは明らかに良い結果をもたらさないでしょう。 最後に、分散をスコアし、各コンポーネントについてカウントしました <img src="https://habrastorage.org/getpro/habr/post_images/ce6/03c/1e2/ce603c1e28b7a945bc582ff63636822a.gif">  、指数kは経験的に選択され、さまざまなパラメーターのセットに対して、最良のインジケーターは0.01と4の両方に等しくなることが判明しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     はい、そのような方法は、単にベクトルのノルムを計算するよりもはるかに良い結果をもたらしました。 しかし、彼には少なくとも2つの重大な欠点があります。 最初に目を引くのは、指から吸い込まれる重みの公式です。これは、最適性に疑問の余地がないことを意味します。 第二に、すべてのコンポーネントは別々に独立して考慮されます。つまり、それらの非相関が暗示されますが、これは一般に正しくありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 線形回帰 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     正しいアプローチは、問題を数学的に形式化し、ある意味で最適なソリューションを見つけることです。 ご存知のように、最も単純な関数は線形関数ですので、次の形式の関数を探します。 <img src="https://habrastorage.org/getpro/habr/post_images/cc6/7eb/2cf/cc67eb2cf7c3fea925bce60c735f8521.gif">  （はい、見た目は同じ重量に非常に似ています）。 <img align="right" title="最大差と分割線の方向" src="https://habrastorage.org/getpro/habr/post_images/108/bd6/aba/108bd6abae7394fd2771d985ceb228e2.jpg"> そのような関数を見つけることを線形回帰と呼びます。 係数b <sub>0</sub> 、b <sub>1</sub> 、... b <sub>n</sub>は、最小二乗法によるこの関数がテストサンプルの正しい値に最適になるように選択します。 正しい値は、同一のオブジェクトの場合はY = 0、異なるオブジェクトの場合はY = 1です。 ゼロ差分ベクトルでは同じオブジェクトが保証されているため、b <sub>0</sub>の値は<sub>0</sub>に等しくなるように直感的に思われます。 しかし、推測ゲームをプレイして、b <sub>0を</sub>正直に計算しません。 したがって、基本的には、n次元空間で方向を決定します。この方向では、同じペアと異なるペアが最も強く異なります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B5%25D1%2581%25D1%2581%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7">（ソース）</a>二乗誤差の合計は次のように決定されます。 <img src="https://habrastorage.org/getpro/habr/post_images/81b/502/6e7/81b5026e714158e396441411c471188f.gif">  。 以下、Mはテストサンプル内のオブジェクトの数、上付き文字はサンプル内のオブジェクトの数、下付き文字はオブジェクトのコンポーネントの数を示します。 この誤差は、各成分に関する導関数がゼロに等しくなる点で最小化されます。 初等数学は、システムAb = fに導きます。ここで、Aは行列（n + 1）*（n + 1）です。 <img src="https://habrastorage.org/getpro/habr/post_images/3e2/4bc/a58/3e24bca580667aa8b5d301c500d2bd09.gif">  、 <img src="https://habrastorage.org/getpro/habr/post_images/f09/e5e/467/f09e5e4674288ef49fd007e905030bb9.gif">  、 <img src="https://habrastorage.org/getpro/habr/post_images/732/c9f/0b2/732c9f0b26efe4871d0d667f2c42bc9e.gif">  、i、k = 1..n。 <img src="https://habrastorage.org/getpro/habr/post_images/6da/504/3be/6da5043be5184e00d420f65f244d6d6a.gif">  、 <img src="https://habrastorage.org/getpro/habr/post_images/fde/2cd/e47/fde2cde477cc75f924ab853018e214cf.gif">  。 テストサンプルから行列要素を計算し、システムを解き、係数を取得し、関数を作成します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     係数b <sub>iの</sub>一部がゼロ未満であることが判明するのは奇妙に思えるかもしれません。つまり、オブジェクトがこのパラメータでより強く異なる場合、それらはより類似しています。 実際、これには何の問題もありません。異なるパラメーター間の相関を調べただけです（たとえば、大まかに言えば、このパラメーターは別のパラメーターでのみ成長し、3番目のパラメーターを補正します）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私の経験では、このような関数は、ランダムに選択された重みよりも、同一のオブジェクトと異なるオブジェクトのペアを区別することを示しています。 この機能はある意味で最適であるため、これは驚くことではありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 問題？ </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     どのような問題が発生する可能性がありますか？ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最初に、n個のパラメーターの関数の係数を決定するには、サイズ（n + 1）*（n + 1）の行列を計算する必要があります。つまり、256x256画像のすべてのピクセルを個別のパラメーターとして表示することはできません。十分なメモリがありません。 ここでは、次元、特に<a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B2%25D0%25BD%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2582">PCA</a>を縮小する従来の方法に頼ることができます。 <img align="right" title="SVMでのディメンションのアップグレード" src="https://habrastorage.org/getpro/habr/post_images/312/473/878/312473878a42890bcf1bf679d6545d4b.jpg"> または、いくつかの最も重要なパラメーターを選択することができます（たとえば、異なる平均値が同じ、または大きすぎる分散の平均値を超えないパラメーターをふるいにかけます）。 そして、誰も記事を完全に読んでいないので、例えば7で終わるような、最も美しい数字を持つオプションを選ぶことをお勧めします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     別の問題は、線形近似では不十分で、関数のクラス分離が不十分すぎる場合です。 その後、より複雑な分類<a href="http://ru.wikipedia.org/wiki/AdaBoost">子-adaboost</a> 、 <a href="http://ru.wikipedia.org/wiki/SVM">SVM</a> +カーネルトリック（ <a href="http://habrahabr.ru/post/105220/">トピックに関する記事</a> ）などを適用できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「教師による指導」のすべてのシステムの別の重要な問題は、 <a href="http://ru.wikipedia.org/wiki/%25CF%25E5%25F0%25E5%25EE%25E1%25F3%25F7%25E5%25ED%25E8%25E5">再訓練</a>です。 大まかに言って、多くの異なるパラメーターがある場合、トレーニング中に、実際にはそうではないパターン（ランダムな変動）を見つけることができます。 次に、トレーニングセットの外側をチェックすると、この疑似パターンは存在しなくなり、認識結果に悪影響を及ぼします。 ウィキペディアでは、正規化、相互検証など、これに対処する方法に言及しています。 <img align="right" title="放射がある場合とない場合の線形近似" src="https://habrastorage.org/getpro/habr/post_images/c7d/ca5/63c/c7dca563c708c3a9b1de7c54b6319024.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     エラーのあるサンプルで学習すると、結果が悪化する可能性もあります。 トレーニングサンプルに多くの誤った値がある場合、最終結果に大きく影響する可能性があります。 従来、これは次のように解決されます。トレーニングが行われ、その後、このモデルで大きなエラーを生成するオブジェクトはトレーニングサンプルから破棄されます。 新しい「間引かれた」トレーニングサンプルが再びトレーニングされます。 必要に応じて、手順を数回繰り返すことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> 結論 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アウトラインの比較、テールの検出、または指のカウントのためのトリッキーなシステムを思いついたとしても、おそらく評価関数を構築して決定を下す必要があるパラメーターのベクトルがあり、有用な機械学習が必要になります。 そして、最も単純な数学的モデルでさえ、何らかの方法で最適であるため、「一般的な考慮事項」よりもはるかに良い結果をもたらします。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J205412/index.html">Google Analytics 注意ボット</a></li>
<li><a href="../J205414/index.html">45歳になったコンピューターのマウス</a></li>
<li><a href="../J205418/index.html">PHP +プロローグ会話ボット</a></li>
<li><a href="../J205424/index.html">Google Playでの非独占的なアプリケーションの宣伝</a></li>
<li><a href="../J205426/index.html">Pythonプロファイリングとデバッグ、デバッグ</a></li>
<li><a href="../J205432/index.html">Viks Bluetooth Vibro-Bracelet VI-T2：呼び出しに応答しない女性のためのアクセサリー</a></li>
<li><a href="../J205434/index.html">印刷-刑務所に</a></li>
<li><a href="../J205436/index.html">設計エンジニアの目を通したフリーランスエンジニアリングまたはフリーランス</a></li>
<li><a href="../J205440/index.html">好奇心2013：湖、地質、放射線</a></li>
<li><a href="../J205444/index.html">2GISダイヤラ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>