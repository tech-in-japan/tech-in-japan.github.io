<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👦‍👦 🖖🏻 🧜 Oracle RAC 概要/パート2 🍦 🛎️ 👙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Real Application Cluster （ RAC ）に関する記事の続き。 終了 
  
 
  
 記事の始まり 
  
 
  
  
  
 
  
  クラスターが上昇し、すべてが回転したと考えています。  
  
  ノードの相互作用。 キャッシュ融合。  
  
 多くのデータ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>Oracle RAC 概要/パート2</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/72121/">  <strong>Real Application Cluster</strong> （ <strong>RAC</strong> ）に関する記事の続き。 終了 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://habrahabr.ru/blogs/oracle/72122/">記事の始まり</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> クラスターが上昇し、すべてが回転したと考えています。 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> ノードの相互作用。 キャッシュ融合。 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     多くのデータベースインスタンス、多くのディスク。 ユーザーのリクエストが注がれた...ここに彼らは、私たちが待っていた顧客です。  =） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     データベースのボトルネックはディスクI / Oです。 したがって、すべてのデータベースは、遅延書き込みを使用して、可能な限りまれにディスクにアクセスしようとします。  RACでは、すべてが単一インスタンスデータベースの場合と同じです。RAMの各ノードには<strong>SGA</strong> （ <strong>システムグローバルエリア</strong> ）があり、その内部には<strong>データベースバッファキャッシュ</strong>があり<strong>ます</strong> 。 一度ディスクから読み取られたすべてのブロックはこのバッファーに分類され、可能な限り長くそこに保存されます。 ただし、キャッシュは無限ではないため、保存されたブロックの重要性を評価するために、 <strong>TCA</strong> （タッチカウントアルゴリズム）が使用され、ブロックへの呼び出しの数がカウントされます。 キャッシュで最初にヒットすると、ブロックはコールドエンドに配置されます。 ブロックにアクセスする頻度が高いほど、ブロックはホットエンドに近くなります。 ブロックが「古い」場合、キャッシュ内の位置が徐々に失われ、別のレコードに置き換えられる危険があります。 ブロックの上書きは、使用頻度の低い順に始まります。 ノードのキャッシュはノードのパフォーマンスにとって非常に重要です。したがって、クラスターで高いパフォーマンスを維持するには、キャッシュを共有する必要があります（誰が知っているように）。 クラスターノードのキャッシュに保存されたブロックは、 <strong>ローカル</strong>ブロックの役割を持つことができます。 彼自身の使用のために、いくつかはすでに<strong>global</strong>とマークされます。彼は、 <strike>歯</strike>で<strike>歯を</strike>食いしばって、クラスター内の他のノードと共有します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     クラスター内の共有キャッシュテクノロジーは、 <strong>キャッシュ融合</strong> （キャッシュ合成）と呼ばれます。 各ノードのCRSは同期LMSnプロセスを生成します。 <strong>サービス</strong>としての共通名は<strong>GCS</strong> （ <strong>グローバルキャッシュサービス</strong> ）です。 これらのプロセスは、このインスタンスで読み取ったブロック（グローバル）をバッファーキャッシュからネットワーク経由でアクセスしたインスタンスにコピーし、未確認のトランザクションをロールバックする役割も果たします。  1つのコピーには、最大36個（GCS_SERVER_PROCESSES）を含めることができます。 通常、2つのコアごとに1つのLMSnが推奨されます。そうしないと、リソースを大量に消費します。  LMONおよびLMDプロセスによって各ノード上で表される<strong>GES</strong>サービス（ <strong>グローバルエンキューサービス</strong> ）は、それらの調整を担当します。  LMONはクラスター全体のグローバルリソースを監視し、隣接ノードにアクセスしてブロックを取得し、GCSリカバリを管理します。 ノードがクラスターに追加またはクラスターから離脱すると、ロックとリソースの再構成が開始されます。  LMDはホストリソースを管理し、共有ブロックとキューへのアクセスを制御し、GCSへのリクエストをブロックし、LMSnリクエストキューのメンテナンスを管理します。  LMDの責任には、複数のクラスターノードでのグローバルデッドロックの解決も含まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="http://img203.imageshack.us/img203/9505/grd.jpg"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ただし、クラスターリソースの調整とキャッシュの組み合わせにおける特別な役割は<strong>GRD</strong> （ <strong>グローバルリソースディレクトリ</strong> ）テーブルに割り当てられ、 <strong>GRD</strong> （ <strong>グローバルリソースディレクトリ</strong> ）テーブルでは、どのインスタンス、どのブロック（またはそのコピー）が利用可能か、インスタンスがブロックを保持するモード、ブロックロール、SCNで常に固定されます 単一インスタンスバージョンでは、SCNはデータベースに加えられた変更の増分カウンターにすぎません。 クラスタでは、ノード間でSCNを同期する必要があります。 ミリ秒単位で指定されたMAX_COMMIT_PROPOGATION_DELAYパラメーターの値に応じて、2つのSCN同期方法があります。 <ol><li>  100を超える場合、SCNはインスタンスで並行して生成（増分）されます。 これらのSCNは、相互接続を介して転送される各メッセージに埋め込まれます。定期的に、Oracleはアイドル時に相互同期のために現在のSCN値のインスタンスをポーリングします。 通常、間隔は最大700ミリ秒です。  「後期」コミットの長いトランザクションに使用できます。 </li><li>  = 0（デフォルト）の場合、いずれかのインスタンスでCOMMITが発生するとすぐに、現在の番号に関するアラートがすぐに他のユーザーに送信されます。 交換は非常に頻繁に（1秒未満まで）発生するため、相互接続を介して大量のトラフィックが生成されます。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     その結果、RACのSCNは、クラスターで既知の最大のSCNに定期的に同期されます。 ブロックに加えられた変更の記録が時系列に配置されるようにSCNが必要です。これは、トランザクションを復元するときに必要です（ロールフォワード）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      GRDテーブルはクラスターノード間で分散されます。 各ノードはクラスターリソースの配布に参加し、GRDのその部分を更新します。  GRDテーブルの一部はリソースに関連しています-オブジェクト：テーブル、インデックスなど。 ノード間で常に同期（更新）されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ノードがディスクからデータブロックを読み取ると、ノードはこのリソースのマスターになり、GRDテーブルの一部に対応するマークを作成します。 ブロックはローカルとしてマークされます、なぜなら これまでのところ、ノードは単独で使用しています。 このブロックが別のノードに必要な場合、GCSプロセスはテーブル内のこのブロックをグローバル（クラスターに対して「公開」）としてマークし、要求されたノードに渡します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td>  DBA </td><td> 場所 </td><td> モード </td><td> 役割 </td><td>  SCN </td><td>  PI / XI </td></tr><tr><td>  500 </td><td> ノード番号3 </td><td> 共有した </td><td> ローカル </td><td>  9996 </td><td>  0 </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>では、すべて一緒にしましょう！</em> マスターノードのGRDでは、クラスターインスタンス間のブロックの分散を調整するために、各ブロックに追加情報が記録されます。 <ul><li> データブロックアドレス（DBA）：物理ブロックアドレス </li><li> 場所：このブロックが利用可能なノード </li><li> リソースモード：現在ブロックを所有しているユーザーとそのブロックに適用される操作によって決定されます <ul><li>  null：ノードはこのブロックの変更を要求しません（選択のみ） </li><li> 共有：ブロックは、複数のノードで読み取り専用の複数アクセスによって保護されます。 </li><li> 排他的：ノードはこのブロックを変更しようとしています（または既に変更されています）。 クラスターには、同じブロックの以前の（合意された）バージョンが含まれている場合がありますが、変更することはできません。 </li></ul></li><li> リソースの役割：ブロックがノードキャッシュに保存されるモード <ul><li> ローカル：ノードがブロックをディスクから読み取り、まだ誰とも共有していない場合。 </li><li> グローバル：ノードが最初にこのブロックによって読み取られたが、特定のモードで要求元ノードに渡された後。 これで、同じブロックが他のノードに存在できるようになりました。 </li></ul></li><li> システム変更番号（SCN）：ブロックが変更されたときのRACのSCN </li><li> 画像：複数のブロックがクラスター全体のグローバルキャッシュに同時に保存されている場合に、ブロックのコピーを特徴付けます <ul><li> 過去の画像（PI）：グローバルなダーティブロック（変更後の古いバージョン）。ノードがネットワークを介して別のノードに転送した後にノードのキャッシュに保存されます。 ブロックは、それ以降のバージョンがディスクに書き込まれるまでメモリに保持され、ブロックが不要になったときにGCSから通知されます。 </li><li> 現在のイメージ（XI）：このブロックのクエリチェーンの最後のクラスターノードに含まれるブロックの現在の最後のコピー。 </li></ul></li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     データベースの最も重要な原則（単一インスタンス）のいくつかは、RACにも当てはまります。 <ul><li> キャッシュを使用したアクティブな作業により、ディスクへのアクセスを可能な限り少なくする </li><li>  <strong>一貫性読み取り</strong> （ <strong>CR</strong> ）、読み取りの一貫性、つまり 誰も、（並列）セッションで未確認のトランザクションのデータを確認しません </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      RAC環境と通常の単一インスタンスデータベースの違いは、ロックはすべての要望にもかかわらず<strong>、行レベルではなくブロックレベルで</strong>実行される<strong>ことです</strong> 。 つまり インスタンスはブロック全体（コンテンツおよび他の誰かに必要なデータ）をブロックできます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     クラスタライフの典型的な状況をいくつか説明しましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <strong>読み取り/読み取り動作（転送なし）</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     テーブルAのデータを、ノード番号4を最初に検討します。 彼はこのテーブルのマスターであり、GRDの対応する部分を担当しています。 <ol><li> テーブルAからの読み取り要求がノード3に届きました。ノード3にはキャッシュに必要なブロックがありません。  GRDから、彼はテーブルAのマスターがノード番号4であることを知り、それにアクセスします。 </li><li> ノード4は、要求されたブロックのGRDをスキャンします。 彼が彼のキャッシュにあった場合、彼は単にそれを渡すでしょう。 しかし、正しいブロックがそこになかったと仮定します。 ノード4はノード3を送信して、ディスクからこのブロックを独立して読み取ります。 </li><li> ノード3自体はディスクからそれを読み取りますが、これまではそれ自体のみで、ブロックなしで共有（ローカル）されますが、その後、このテーブルのマスター（共有）を介して他のノードへのアクセスを提供できます。 </li><li> ノード3は、ノード4を使用してテーブルAのマスターにレポートし、GRD（ノード4）に対応するエントリを作成します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td>  DBA </td><td> 場所 </td><td> モード </td><td> 役割 </td><td>  SCN </td><td>  PI / XI </td></tr><tr><td>  500 </td><td> ノード番号3 </td><td> 共有した </td><td> ローカル </td><td>  9996 </td><td>  0（XI） </td></tr></tbody></table></li></ol></li><li>  <strong>読み取り/読み取り動作（転送）</strong> <ol><li> ここで、同じブロックを読み取る要求がノード番号2にあるとします。 ノード2は、GRDのローカルコピーから、マスターノード4がこのリソース（テーブルA）を担当し、それにアクセスしていることを認識しています。 </li><li>  GRDテーブルのノード4は、ブロックがノード3にあることを認識し、読み取りモードでブロックをノード2と共有するよう指示します。 </li><li> このようなコマンドを受信したノード3は、ブロックのコピーをノード2に送信します。 メッセージヘッダーで、彼はコピーを共有していることも示し、このブロックのコピーも残します。 </li><li> ノード番号2はブロックを受信し、GCSを介してマスターノード番号4に目的のブロックを受信したことを通知します。 マスターがGRDを更新します（ノード＃4）： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td>  DBA </td><td> 場所 </td><td> モード </td><td> 役割 </td><td>  SCN </td><td>  PI / XI </td></tr><tr><td>  500 </td><td> ノード番号2 </td><td> 共有した </td><td> ローカル </td><td>  9996 </td><td>  0（xi） </td></tr><tr><td>  500 </td><td> ノード番号3 </td><td> 共有した </td><td> ローカル </td><td>  9996 </td><td>  0（xi） </td></tr></tbody></table></li></ol></li><li>  <strong>読み取り/書き込み動作</strong> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後に、ユーザーはブロックに関してテーブルAを変更することにしました。 ユーザーをノード番号1に接続します。 <ol><li> ノード1は、マスターブロックの排他モード要求をノード4に送信します。 </li><li> ノード4は、ブロックを保持するすべてのノード（ノード3を除く）にメッセージを送信し、ブロックを完全にローカルモード（nullモード、ローカルロール）にします。 グローバルキャッシュ内に存在しなくなり、ロックが解除され（現在は書き換え可能）、キャッシュには一貫した読み取り要求のためにのみ保存されます。 </li><li> マスターは、ノードの1つ（ノード3）に、このブロックを排他モードでノード1に転送するように要求します。 </li><li>ノード3はブロックをノード1に送信し、ブロックが排他モードに転送されていることを示します。したがって、ブロック自体はグローバルキャッシュから削除されます。 ノード3はブロックからロックを削除し（現在は書き換え可能）、一貫した読み取り要求のためにのみキャッシュに残します。 </li><li> 要求元のノードNo. 1は、最終的にそのブロックを受け取り、必要な変更を行い、新しいSCNを割り当てます。 マスターブロック4に受信ブロックが変更されたことを通知し、さらに、メッセージにはノード3がこのブロックを閉じたという情報が含まれます。 </li><li> ノード4は、ノード3のブロックの削除を確認します。 そして今、ノード4のGRDには以下が含まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td>  DBA </td><td> 場所 </td><td> モード </td><td> 役割 </td><td>  SCN </td><td>  PI / XI </td></tr><tr><td>  500 </td><td> ノード番号1 </td><td> 共有した </td><td> ローカル </td><td>  10010 </td><td>  0（XI） </td></tr></tbody></table></li></ol></li><li>  <strong>書き込み/書き込み動作</strong> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次に、テーブルAのブロックで更新を行う必要があります。同時に、リソースのマスターは常に1つのノードであり、GCS（グローバルキャッシュサービス）はリソースロックメカニズムを使用して順番に動作します。 <ol><li> ノード番号2の更新要求を受け取りました。この要求は、このブロックをすでにグローバルキャッシュから削除しています。 ノードは、ブロックの排他モードを要求してマスターノードに戻ります。 </li><li> ノード4は、現在のブロックホルダーに、ノード2にブロックの画像（現在の画像）を提供するように依頼します。 </li><li> ノード1、ブロックに適用された変更を含むREDOログがディスクにフラッシュされたことを確認した後（重要：そのトランザクションは引き続き実行できます！）、そのコピーのイメージを過去のイメージに転送します（ノード2が追加するため）変更）、彼はもう修正できなくなります。 また、ブロックを排他モードで要求元のノード2に送信し、さらにPIブロックを保持していることをメッセージに含めます。 </li><li> 要求元のノードNo. 2はブロックを受け取り、必要な変更を行い、新しいSCNを割り当てます。 マスターノードNo.4に受信ブロックが変更されたことを通知します。さらに、メッセージには、ノードNo.2がブロックを排他モードで保持し、ブロックNo.1には以前のバージョンが含まれているという情報が含まれます（SCN = 10010）。 </li><li> ノード4はGRDに変更を加えます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td>  DBA </td><td> 場所 </td><td> モード </td><td> 役割 </td><td>  SCN </td><td>  PI / XI </td></tr><tr><td>  500 </td><td> ノード番号1 </td><td> 共有した </td><td> グローバル </td><td>  10010 </td><td>  1（PI） </td></tr><tr><td>  500 </td><td> ノード番号2 </td><td> 排他的 </td><td> ローカル </td><td>  10016 </td><td>  0（xi） </td></tr></tbody></table></li></ol></li><li>  <strong>書き込み/読み取り動作</strong> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     別の状況：ノードの1つでブロックが変更され、現在の最新バージョンはディスクに保存されているものとはまったく異なります。 <ol><li> テーブルAからノード3を選択する要求が来て、マスターリソースにアクセスします。 </li><li>  GRDのマスターノードは、ブロックの最新バージョンがノード2に含まれていることを検出し、そこにブロックをノード3に転送する要求を送信します。 </li><li> ノード番号2で、ブロックが受信され、排他モードで保存されました。 ブロックの処理が停止するとすぐに、ノード2が共有モードに転送し、ブロックのコピーを過去のイメージとしてマークし（SCN = 10016）、ノード3に転送します。 </li><li> ノード4はGRDに変更を加えます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><td>  DBA </td><td> 場所 </td><td> モード </td><td> 役割 </td><td>  SCN </td><td>  PI / XI </td></tr><tr><td>  500 </td><td> ノード番号1 </td><td> 共有した </td><td> ローカル </td><td>  10010 </td><td>  1（PI） </td></tr><tr><td>  500 </td><td> ノード番号2 </td><td> 共有した </td><td> グローバル </td><td>  10016 </td><td>  1（PI） </td></tr><tr><td>  500 </td><td> ノード番号3 </td><td> 共有した </td><td> グローバル </td><td>  10016 </td><td>  0（xi） </td></tr></tbody></table></li></ol></li><li>  <strong>ディスクへの書き込み動作</strong> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     データをディスクにフラッシュするときだとしましょう。 それは遅れないので、常に来ます： <ul><li> バッファ内のダーティデータの量が特定の値（しきい値）を超えます。 バッファを解放するために、これらの変更されたデータを書き込む必要があり、新しい何かがバッファに導入される可能性があります。 </li><li> バッファの空き容量がなくなったとき </li><li>  DBWRは、変更されたデータをバッファからディスクに定期的にフラッシュします（LOG_CHECKPOINT_TIMEOUT）。 </li><li> ちなみに、これは別のパラメーターで制御できます：fast_start_mttr_target = 3 sec（デフォルト）、これはチェックポイントの頻度、つまり  REDOログバッファおよびバッファキャッシュに蓄積されたディスクレコードをフラッシュする頻度。 これは、障害発生時にノードトランザクション（ロールフォワード）の回復に約3秒かかるために必要です。 </li></ul><ol><li> 古くなったブロックを持つノード＃1がディスクに書き込もうとしていると仮定すると、マスターリソースノード＃4にアクセスし、そのブロックのSCNを提供します。 </li><li> ノード4は、最後のバージョンがノード2によって保持されていることをGRDから学習します。 彼は、ディスクに書き込むためにノード番号2を求めます。 </li><li> ノード2はディスクに記録しますが、誰もブロックを変更できません。 彼らはGRDで列に並ぶ必要があります。 これは共有共有ブロックで発生します（廃止されたローカルブロックは破棄され、考慮されません）。 </li><li> ノード2はデータをディスクに書き込みます。 </li><li> ノード2は、データがディスクに書き込まれたことをマスターに通知します。 彼のブロックはローカルの役割になります（このブロックが残っているのは彼だけです）。 </li><li> そのようなメッセージを受信すると、GCSはPIをクリアするためにすべてのノードに信号を送信し、誰かが排他モードでブロックを保持した場合、ローカルロールに切り替わります。 </li><li> これで、このブロックをディスクから読み取るか、メモリ内でそれを含むノードにアクセスできます。 </li></ol></li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ディスクへの記録の必要なしでは発生しません。 ブロックのコピーは、最も頻繁に使用されるノードに常に保存されます。 特定のブロックがまだグローバルキャッシュにない場合、要求時にマスターは対応するノードにディスクからブロックを読み取り、他のノードと共有するように要求します（必要に応じて）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     上記に基づいて、キャッシュ融合には2つのシナリオが含まれることが明らかになります。 <ol><li> 関係する2つのノードがあります：ターゲットノードがマスターキャッシュに格納されたブロックを必要としたとき。 </li><li> 関係する3つのノードがあります。マスターが中間ノードに要求を送信し、中間ノードがブロックを必要なノードに渡します。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     クラスター内にノードがいくつあるかは関係ありません。ホップ（ブロック転送に参加しているノード）の数<strong>が3を超えることはありません</strong> 。 この事実は、RACクラスターが多数のノードに簡単に拡張できることを説明しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 火をつけて、助けが必要です！ ワークロードの分散。 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     説明したCache-fusionデバイスは、ノードのロードに（自動的に）反応する機能をクラスターに提供します。 これが、 <strong>ワークロードの分散</strong>または<strong>リソースのリマスターの</strong> <strong>仕組み</strong>です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     たとえば、ノードNo.1を介して1500人のユーザーがリソースAにアクセスし、ほぼ同時に100人のユーザーがノードNo.2を介して同じリソースAにアクセスする場合、最初のノードがより多くのリクエストを持ち、より頻繁にドライブ。 したがって、ノード1はリソースAへのリクエストのマスターとして定義され、GRDはノード1から作成および調整されます。 ノード2が同じリソースを必要とする場合、ノード2にアクセスするには、ノード1のGCSおよびGRDとアクションを調整して、相互接続を介してリソースを受け取る必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     リソースの分布がノード番号2を優先して変化する場合、プロセス番号2と1は相互接続を介してアクションを調整し、ノード番号2はリソースAのマスターになります。 彼は今、より頻繁にディスクにアクセスします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これは<strong>、</strong>リソースの<strong>親和性</strong>と呼ばれます。 リソースはそのノードに割り当てられ、そのノードでさらに受信およびブロックするアクションが実行されます。 リソースアフィニティポリシーは、ノードのアクティビティを調整して、リソースがより必要な場所にアクセスできるようにします。 ここに、簡単に言えば、 <strong>ワークロードの分布</strong>全体があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     再配布（リマスタリング）は、ノードがクラスターに追加またはクラスターから離脱するときにも発生します。  Oracleは、遅延リマスターと呼ばれるアルゴリズムに従ってリソースを再割り当てします。  Oracleは、リソースのアクティブな再配布をほとんど行いません。 ノードが落ちた場合、Oracleは、障害が発生したノードに属するリソースを残りの1つ（負荷が少ない）に投げるだけです。 負荷を安定化させた後、GCSとGESは、リソースをより自動で（自動的に）再配分（ワークロードの分散）します。 ノードが追加されると、同様のアクションが発生します。ほぼ等しい量のリソースが既存のノードから分離され、新規参入者に割り当てられます。 その後、ワークロードの分散が再び発生します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     原則として、動的な再配布を開始するには、特定のノードのワークロードが他のノードのワークロードを10分以上超える必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> ここで弾丸が飛んだ、そして…え？ 回復。 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     突然、一部のノードがハートビートに応答しませんでした。それを検出した最初のノードのCSSDプロセスは「アラームを鳴らし」、マスターノードに報告します（まだ接続されている場合は、マスター自体の責任を引き継ぐ必要があります）。 マスターはすべてのノードで「投票」手順を開始し、クラスターの生き残ったノードは投票ディスクでマークされ始めます。 欠落しているノードがここにトレースを残さない場合、マスターはクラスターから欠落を除去するプロセスを開始します。  REDOログファイルは2回読み取られます。1回はREDOレコードで、2回目は（再度）既にUNDOレコードで、データベースをできるだけ早くクエリで使用できるようにします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> フォールドノードのリソースを含むGRDテーブルの一部は「凍結」されています。 </li><li> 接続されていないノードは「欠落」とマークされているため、残りのノードは相互接続を介して無駄に接続しません。 </li><li> 損失を最初に発見したノードは、消失したノードで処理された情報の復元を開始します。 <ul><li> 独自のトランザクションを処理するペースを短縮し、コンピューティングリソースを復旧に投入します </li><li> 一般的なファイルストレージ（datastorage）を指し、見つからないノードに属するオンラインREDOログ自体に適用し始めます。  SCNブロックのシリアル番号を指定して、それらをバッファーに保存されているものとマージし、キャッシュ内でロール（ロールフォワード）します。 同時に、ノードは、後のバージョンがすでにディスクにフラッシュされている古いブロック（PI）レコードをスキップします。 クラスター内の読み取りブロックに対応するリソースのマスターがある場合、ノードは読み取りブロックのリストを報告し、マスターがこれらのリソースにロックを設定して、ノードがそれらのリソースにアクセスしないようにします（復元中）。 </li><li> その後、REDOログの2回目の読み取りで、すでに取り消しエントリを考慮して、コミットされていないトランザクションをロールバック（ロールバック）します。 これは、高速リカバリテクノロジー、つまり トランザクションは、別のバックグラウンドプロセスによってロールバックされます。  Oracleは、これらのブロックのリクエストが到着するとすぐに、コミットされていないブロックによってロックされたブロックを一貫した状態に、以前の値に戻します。 または、それらは、この非常に並行したバックグラウンドプロセスによって復元されます。 したがって、ロックはクラスター内で既に削除されており、新しいユーザー要求を実行できます。 </li></ul></li><li> フォールドノードに属していたGRDテーブルの一部は、リカバリノードで解凍されます（現在はリソースのマスターです）。 したがって、クラスターでは、「フォール」の時点で、欠落しているノードで処理されたトランザクションの状態が復元されます。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4> しかし、これらすべてのプロセスが行われている間、せっかちなクライアントは何かを提供します。 </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> ノードがお互いを保存しながら...フェールオーバー。 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>フェールオーバー</strong>は、クラスター内のノード障害状況の処理です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     クラスター環境のもう1つの層、つまりクライアントがデータベースにアクセスするためのパブリックネットワークについて説明します。 物理サーバーでは、少なくとも2つのネットワークカードが望ましい： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> 最初のネットワークカードには静的IPが割り当てられます。静的IPを介して、ノードはクラスター内の隣接ノードとメッセージを交換します（相互接続）。 </li><li>  2番目のネットワークカードには、論理仮想IP（仮想IP）が割り当てられます。これにより、クライアントはクラスターノードに要求を送信します。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>仮想IP</strong> （ <strong>VIP</strong> ）-外部ネットワークインターフェイス上のノードに割り当てられた論理ネットワークアドレス。  CRSがこのVIPの作業を静かに開始、停止、および別のノードに転送する機能を提供します。 各ノードのリスナー（接続を受け入れるプロセス）は、そのVIPをリッスンします。 ノードが使用できなくなるとすぐに、そのVIPはクラスター内の別のノードによって取得され、一時的に自身とフォールドノードの要求を処理します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これは、トランザクションが実行されたノードが落ちた場合に、クライアントのダウンタイムを減らすために行われます。 結局、クライアントは数分間TCPタイムアウトを待つことができます。 この場合、VIPはすぐに別のノードによって「ピックアップ」され、 <strong>TAF</strong> （ <strong>透過的アプリケーションフェイルオーバー</strong> ）テクノロジーを使用して、2つのシナリオに従ってさらにイベントを開発できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <strong>データベースVIP</strong> ：クライアントはVIPを介して接続しますが、すでに別のノードに接続しています。 一時的に交換するノードは「ログオンに失敗しました」と応答します。VIPがアクティブであるにもかかわらず、必要なデータベースインスタンスがその背後にありません。 そして、クライアントはすぐに再試行しますが、構成内のリストからクラスターの別のインスタンス/ノードに再試行します。 </li><li>  <strong>アプリケーションVIP</strong> ：以前と同じ。 ただし、このVIPでのみ、どのノードでスピンしているかに関係なく、アプリケーションにアクセスできます。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     データベースVIPは、自分のサイトでのみアプリケーションを提供できます。アプリケーションが移行した場合、それらは拒否します。 移行後もアプリケーションVIPは、ノードによって提供される機能を実行します（ポジティブ）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ノードが復元されてオンラインになると、CRSはこれを認識し、ノードを交換するノードでオフラインにリセットするよう要求し、VIPアドレスを所有者に返します。  VIPはCRSを指し、データベースインスタンスに障害が発生してもスローされない場合があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     フェイルオーバーでは、選択されたクエリのみが、オープンカーソル（結果を返す）とともに転送されることに注意することが重要です。 トランザクションは移行されません（PL / SQL、一時テーブル、挿入、更新、削除）。常に再起動する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TAFを構成するには2つの方法があります。 <ul><li>  <strong>接続時フェイルオーバーとクライアント負荷分散</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この場合、クライアントは常に、ネットワーク接続構成リストから接続するクラスターノードをランダムに選択します。 要求を実行しているノードが失敗した場合、TAFに従って、クライアントは別のクラスターノードを選択して再接続します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  <strong>事前接続</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この場合、要求は1つのインスタンスでのみ実行されますが、クラスターとの接続を確立するとき、クライアントは常にすべてのノードに接続します。 ノードに障害が発生した場合、リクエストを別のノードに転送するだけです。 フェールオーバーは高速ですが、クラスターのすべてのノードで接続リソースを消費します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     クライアント接続には再試行と遅延のオプションがあります。 これらは、ノードが落ちた場合にクライアントが（サイレントに）再接続を試行する回数と、設定する遅延を構成できます。 おそらく最も興味深いのは、ノードがクラッシュした場合に、OracleがONS（Oracle Notification Services）の一部であるFAN（Fast Application Notification）を介してクライアントに通知できることです。 クライアントがOracleへの接続に「厚い」ドライバーを使用する場合、データベースにアクセスする前に、TAF（フェイルオーバー）の場合にイベントが来るコールバック関数（コールバック）を登録できます。 これは、ユーザーの画面に「小さなヒッチ」として表示され、リクエストを手動で再開するプロセスを制御できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> そこに行かないで、ここに行く...負荷分散。 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     操作を実行すると、Oracleは<strong>AWR</strong> （ <strong>自動ワークロード・リポジトリ</strong> ）で問合せパフォーマンス（「デバッグ」など）に関連する情報を収集します。  SYSAUX表領域に格納されます。 統計収集は60分ごとに開始します（デフォルト）：I / O待機、待機イベント、セッションごとに使用されるCPU、データファイル（最も頻繁にアクセスされるファイル）のI / Oレート。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     クラスター内のノード間の負荷分散（負荷分散）の必要性は、一連の基準、つまりノードへの物理接続の数、プロセッサー負荷（CPU）、およびトラフィックによって決まります。 ノードでの平均クエリ実行時間による負荷分散が不可能なのは残念ですが、原則として、これは何らかの方法でノードで使用されるリソース、したがって残りの空きリソースに関連しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>クライアントの負荷分散</strong>については、上記で少し述べました。 クライアントは、構成内のリストからランダムに選択されたクラスターノードに接続できます。  <strong>サーバー側の負荷分散</strong>を実装するため<strong>に、</strong>別のプロセスPMON（プロセスモニター）がクラスターノードの読み込みに関する情報を収集します。 この情報を更新する頻度は、クラスターの輻輳に依存し、約1分から10分までの範囲です。 この情報に基づいて、クライアントが接続されているノードのリスナーは、最も負荷の少ないノードにリダイレクトします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Oracleは、負荷分散に最も関連する基準を選択するDBAを提供します。 <ul><li> 経過時間に基づく（CLB_GOAL_SHORT）：ノードでの平均クエリ実行時間に基づく </li><li> セッション数に基づいて（CLB_GOAL_LONG）：ノードへの接続数による </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アプリケーションに接続プールがある場合、Oracleは<strong>ランタイム接続負荷分散</strong> （ <strong>RCLB</strong> ） <strong>オプションを提供します</strong> 。 通常のオプションの代わりに、どのノードの負荷が少ないかを予測し、そこにリクエストを送信しようとすると、ノードへのロードに関するアプリケーションの通知メカニズム（イベント）を使用します。 そして、このデータに基づいて、アプリケーション自体がリクエストの送信先を決定します。 通知は、ONS（Oracle Notification Service）を介して発生します。  RCLBはクラスターノードから定期的にフィードバックを受け取り、接続プールは各インスタンスが完了できる接続の割合を示す相対的な数値に基づいてクライアントに接続を分散します。  RACが転送するこれらのメトリック（平均ノード負荷）、各ノードはAWRで構築されます。 それらに基づいて、必要なロードアドバイザリが形成され、AQ（高度なクエリ）キューに配置され、そこからONSを介してクライアントにデータが送信されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     通知は、次のいずれかのメカニズムで作成されます。 <ul><li> クエリ実行の遅延時間に注目（GOAL_SERVICE_TIME） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     以前の要求の処理の時間遅延が考慮されます。 </li><li> サーバーの負荷に焦点を当てる（GOAL_THROUGHPUT） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     帯域幅とCPU使用率を考慮 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://habrahabr.ru/blogs/oracle/72122/">記事の始まり</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J72112/index.html">新しいMicrosoft Surface Travel Agentツール</a></li>
<li><a href="../J72113/index.html">電子書籍用の太陽電池</a></li>
<li><a href="../J72118/index.html">ブラウザとピクセル</a></li>
<li><a href="../J72119/index.html">充電せずに12時間！</a></li>
<li><a href="../J7212/index.html">悪の愛</a></li>
<li><a href="../J72122/index.html">Oracle RAC 概要/パート1</a></li>
<li><a href="../J72123/index.html">壊れたiPod、またはウィンチェスターで何をすべきか</a></li>
<li><a href="../J72125/index.html">YiiのTwig、Smarty、Quickyのレンダリング</a></li>
<li><a href="../J72127/index.html">OpenLaszloでリッチインターネットアプリケーションを作成します。 Vkontakteアプリケーション用のフレームワーク開発の例</a></li>
<li><a href="../J72128/index.html">A-DATA SH93：防水外部ドライブ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>