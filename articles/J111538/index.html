<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏼 💴 ⏏️ フラクタル風景を構築するためのダイヤモンド正方形アルゴリズム 🏠 👨🏽‍💻 📦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="多くの人が非常に珍しいMinecraftゲームに精通していると思います（右はその中で生成されたマップの例です）。プレイヤーは地球の（ほぼ）無限の表面にいて、最小限の制限で彼の周りの世界を探索できます。 
  
 
  
 ゲームの作者であるノッチは、どのようにして彼のランダムな「世界」を地球の広大さ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>フラクタル風景を構築するためのダイヤモンド正方形アルゴリズム</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"> <a href=""><img src="https://habrastorage.org/storage/fe971240/ff0111e1/e8b0482c/fcd1ee86.jpg" align="right" alt="Cartographで作成されたMinecraftマップ" title="カートグラフで作成されたMinecraftマップ"></a> 多くの人が非常に珍しい<a href="http://minecraft.net/">Minecraft</a>ゲームに精通していると思います（右はその中で生成されたマップの例です）。プレイヤーは地球の（ほぼ）無限の表面にいて、最小限の制限で彼の周りの世界を探索できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ゲームの作者であるノッチは、どのようにして彼のランダムな「世界」を地球の広大さに似せたものにしたのでしょうか？ このトピックでは、この種の人工的なランドスケープを構築する方法の1つを検討し（また、他のいくつかの方法を簡単に説明します）、パフォーマンスを著しく低下させることなくランドスケープのサイズを大幅に増加できるこのアルゴリズムの小さな改善についても説明します 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     内部には、いくつかのスキームと美しい写真、かなりの数の文字、アルゴリズムの実装例へのリンクがあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 行動計画 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一般的にランドスケープ生成とはどういう意味ですか？ 実際にMinecraftなどのコンピューターゲームのレベルの作成（ほぼリアルタイム）について話す場合、このプロセスは次のポイントで構成されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <b>高さマップを作成します</b> 。 最初に、平坦な2次元グリッドを作成し、各セルに特定の高さを割り当てます。 どうやって？ これについては後で説明します。 ちなみに、グリッドは長方形である必要はありません。たとえば、三角形<a href="http://ibiblio.org/e-notes/VRML/Terra/Terra.htm">で</a>構成されるグリッドの同様のアルゴリズムを<a href="http://ibiblio.org/e-notes/VRML/Terra/Terra.htm">ここで</a>説明し<a href="http://ibiblio.org/e-notes/VRML/Terra/Terra.htm">ます</a> 。 ただし、ほとんどの場合、正方形のピクセルセルで構成されるグリッドの方が便利です。 高さマップとともに、水で覆われたエリアも定義されます-少なくとも海と海（通常、特定のレベルより下にあるセルは水になります）。 </li><li><img src="https://habrastorage.org/storage/694bf417/2bd7e8fe/47ea1f86/057bf768.png" align="right" alt="高さと湿度によるバイオーム分布" title="高さと湿度によるバイオーム分布">  <b><a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D0%25BE%25D0%25BC">バイオーム</a>分布</b> 。 ここでは、地理の知識が必要になります（ただし、ランドスケープを作成するプロセス全体でこれが必要です）。 ツンドラがどこにあるべきか、砂漠がどこにあるか、そして熱帯雨林がどこにあるかを決定するために、すでに作成された高さマップと、例えば、水空間またはいくつかの所定のポイント（赤道/極）までの距離が役立ちます。 次に、バイオームは他の多くのパラメーターを設定します-例えば、草地、岩場の数、植物、川や湖の数など。 </li><li> 地球、海洋、海も作成し、地理的ゾーンを分散させました。 何を忘れましたか？ もちろん<b>、川をしましょう</b> ！ 山から流れて海に流れ込む、または空洞に湖を形成する水自体に加えて、地表面への影響をエミュレートする必要があります-川底が形成され、砂や柔らかい土壌が河川に沿って運ばれ、湖や他の水域のビーチが形成されます。 残念ながら、他のタイプの<b>侵食</b>と同様に、 <b>水侵食</b>と呼ばれるこのプロセスは、この記事の範囲外にする必要があります。 それでも、参考文献のリストには、このトピックに関する非常に優れた資料へのリンクがいくつかあります。 </li><li>  <b>追加のアクション</b> 。 実際、景観はすでに作成されていますが、改善できるものはまだ多くあります。たとえば、Minecraftでは、地下空間が完全に自然の洞窟で覆われ、多くの樹木が表面に生えています。 さらに、もちろん、バイオームによっては、動植物を多様化することが可能です-目標が現実に起きていることにできるだけ近づくことである場合。 </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後に、生成されたランドスケープを描画するだけで済みます。 ここで詳細を1つだけ確認します。上記の三角形のグリッドは、3次元マップの従来の視覚化の場合に役立ちますが、 <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BE%25D0%25BA%25D1%2581%25D0%25B5%25D0%25BB%25D1%258C">ボクセル</a>の使用は正方形のセルには非常に役立ちます。 ただし、これはまったく別の話です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 高さマップを作成する方法 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     それでは、ランドスケープを構築する上で最も重要な段階を見てみましょう。地表の各ポイントの高さを決定します。 最も一般的なアイデアは、両方の座標を調べて<i>マップ[x] [y] =ランダム（）にする</i>ことです。奇妙なことに、許容できる結果が得られないため、もっとsomethingなものを使用する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  「手動で」丘を作成する </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     かなり単純なアルゴリズム：最初から、すべてのポイントは同じレベルにあり、任意の場所（高さの異なる丘）に何らかの「バルジ」を追加し始めると考えています。 慎重にこれらの丘を互いの上に敷設した結果（および、上記の少しのノイズが追加された可能性があります）、すでに真実に似たものを得ることができます。 ただし、以下にリストしたアルゴリズムを使用すると、はるかに現実的なランドスケープを実現できます。そのため、「丘」方式については説明しません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> ボロノイ図に基づく風景 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     実際、最近まで、次のアプローチは私にはまったく知られていませんでしたが、非常に印象的な結果を出すことができたことに非常に驚きました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/a683ff85/ef3fbe3f/9b942e2c/19c32c5c.jpg" alt="ボロノイ図" title="ボロノイ図" align="right"> それはすべて、誤ってマップ上にポイントを投げることから始まります。 次に、これらの点から<a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE">ボロノイ図</a> （および、それに応じて<a href="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay三角形分割</a> ）が構築され<a href="http://en.wikipedia.org/wiki/Lloyd%27s_algorithm">、ロイドの緩和の</a>いくつかの反復が実行されて、小さすぎるポリゴンが削除されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     前の段落が明確でない場合-怖くない、その本質は右の図のようなグリッドについて作成することになります。 その主な特性は不規則性です。 これにより、基礎に基づいて構築されたランドスケープが「正方形」に見えすぎないようにできます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href=""><img src="https://habrastorage.org/storage/81042320/0aa94e02/caa1e210/b3d11377.jpg" alt="結果として生じる風景" title="結果として生じる風景" align="left"></a> それ以上のアクションは簡単です。水で満たすポリゴンをランダムに選択し、残りのポリゴンに属するポイントの高さをsea-okiyanaまでの最短距離に等しくします。 同じノイズ（高度自体とポリゴンの境界の両方）を追加するために残ります-そして、非常に素晴らしい島（または規模に応じて本土）を取得します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私はこのアルゴリズムの実装を扱っていませんでした。そして、記事を簡単にするために、いくつかの詳細と中間のものを省略しました。 詳細な記事（写真とほとんどの情報の出典）は<a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">ここ</a> （英語）にあります。また、プロセスのすべての段階を非常に明確に示す素晴らしい<a href="">swfデモ</a>もあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> ダイアモンドスクエアアルゴリズム </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最も一般的で最も現実的な結果をもたらすのは、1次元中点変位アルゴリズムを2次元平面に拡張したダイアモンドスクエア（またはスクエアダイアモンド）アルゴリズムです。 その助けを借りて得られた風景は、原則としてフラクタルと呼ばれますが、確かに、実際にはそれほど自己類似ではありません-反対に、以下で見るように、あまり快適ではない特性は、大規模に比較的滑らかになることです、小さなものは一種のサンドペーパーに変わります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/33bc0cc2/2710b7d2/f41b7a20/f7fbb8f7.png" alt="真夜中の変位夜の地平線" title="真夜中の変位夜の地平線" align="left"><img src="https://habrastorage.org/storage/72a3c934/f2df0720/2067fdec/95dfcbf6.png" alt="中点変位アルゴリズム" align="right"> より単純な中点変位アルゴリズムから始めましょう。 既に述べたように、2次元の平面ではなく、1次元のセグメント上で機能します（したがって、たとえば、それを使用して水平線を作成できます）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアルゴリズムがフラクタルに関連しているという事実は、その再帰的な動作です。 最初に、セグメントの両端の高さを何らかの方法で設定し、中央のポイントで2つのサブセグメントに分割します。 このポイントをランダムな値でシフトし、取得したサブセグメントごとにパーティションとシフトを繰り返します。 など-セグメントの長さが1ピクセルになるまで。 これがアルゴリズム全体です（右の図を参照）。 ああ、はい-重要な注意：ランダムな変位は、パーティションが作成されるセグメントの長さに比例する必要があります。 たとえば、長さ<i>lの</i>セグメントを分割します-中央のポイントは高さを持つ必要があります 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>h</i> =（ <i>h <sub>L</sub></i> + <i>h <sub>R</sub></i> ）/ 2 +ランダム（ <i>-R</i> * <i>l</i> 、 <i>R</i> * <i>l</i> ） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      （ <i>h <sub>L</sub></i>と<i>h <sub>R</sub></i>はセグメントの左端と右端の高さで、定数<i>R</i>は結果のポリラインの「粗さ」を決定し、このアルゴリズムの主要なパラメーターです）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/6f10a87f/ca5eb342/eaa5cd2e/fe6fa0c5.png" alt="二次元の中点変位" title="二次元の中点変位" align="left"> このアルゴリズムを2次元の高さマップに一般化してみましょう。 まず、マップ全体の4つの角にランダムな高さを割り当て、それを（便宜上、正方形のマップで作業し、その辺は2のべき乗であると仮定して）4つの等しい正方形に分割します。 それらのそれぞれで、角度の1つの意味が知られています。 残りはどこで入手できますか？ <img src="https://habrastorage.org/storage/35df2fa7/3d2e47a7/6ae410a9/8f627db1.gif" alt="二次元の中点変位の結果" title="二次元の中点変位の結果" align="right">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1次元の中点変位の場合と同様に、すべて同じ補間-中心の点は、4つのコーナー点すべての高さを平均して得られ、大きな正方形の側面の各中点は、対応する辺の端にある1組の点を平均します。  （正方形の辺に比例する範囲内で）中心点をランダムに上下にシフトするために、少しノイズを導入し、結果のサブ正方形に対して再帰的にアクションを繰り返すことができます。 それだけですか？ これですべてですが、すべてではありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これはまだダイアモンドスクエアではありません-このアルゴリズムは、原則として、中点変位アルゴリズムとも呼ばれます。比較的許容できる結果が得られるという事実にもかかわらず、結果の画像でその「まっすぐな」性質に簡単に気付くことができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/40a707db/06476d56/98bd3b4e/45d2891d.png" alt="ダイアモンドスクエアアルゴリズムの進捗" title="ダイアモンドスクエアルゴリズムの進進" align="right"> ダイアモンドスクエアアルゴリズム（「実際の」フラクタルランドスケープを取得できるアルゴリズム）は、2つのステップで構成されるという点で2次元の中点変位とは異なります。 最初は、いわゆるです。  「Square」-同様に、角度を平均し、実際の変位を加算することにより、正方形の中心点を決定します 'a-ランダム偏差。  2番目のステップ「ダイヤモンド」は、辺の中央にあるポイントの高さを決定するように設計されています。 ここでは、2つのポイント、つまり「上」と「下」（垂直側のポイントについて説明します）ではなく、「左」と「右」のポイントのペア、つまり「正方形」のステップで得られた2つの中心点を平均します。 前のステップで取得したこれらの2つの高さはすでにカウントされていることに注意することが重要です。したがって、計算は「レイヤー」で実行し、最初にすべての正方形に対して「正方形」ステップを実行し、次にすべての菱形に対して「ダイヤモンド」ステップを実行し、より小さな正方形に。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     説明はわかりにくいかもしれませんので、添付のスキームを注意深く検討することをお勧めします。各スキームでポイントの高さがどのように計算されるか、より明確にする必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     深さを歩くのではなく幅を歩く必要があることに加えて、別の微妙な点があります-風景の端の状況です。 実際、ダイヤモンドの段階では、アルゴリズムは現在の正方形の外側にあるポイントの高さを使用し、場合によってはマップ全体を使用します。 になる方法  2つのオプションがあります（もちろん、独自に考え出すこともできます）：これらの高さを0（または1、または他の定数。これは、私たちの風景の端を水に浸すのに便利です）に等しいか、飛行機が折り畳まれていると想像してくださいトーラス（トロイダル惑星、うーん...）とマップの<i>左</i>境界線の左に64ピクセルある点の高さを見つけようとすると、 <i>右</i>境界線から64ポイント離れた点の高さを見つけます。 それは非常に簡単に実装されます（ただし、最初のオプションとして）-マップのサイズに等しいモジュロ座標を取ることで助けられます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/37879634/a3fdfd9b/5a995a17/c358aa93.jpg" align="right" alt="ダイアモンドスクエアアルゴリズムの結果" title="ダイアモンドクレクタアルゴリズムの結果"> したがって、これらは、人工的に生成された景観の高度マップを構築するための基本的なアルゴリズムです。 私の意見では、最も現実的な結果はそれらの最後のダイアモンドスクエアによって与えられます-それはいくつかの欠点がないわけではありませんが。 たとえば、強力な近似で見栄えの良いマップを作成することで、全体を表示すると、いくつかの大きな大陸や海の代わりに、多くの小さな島（または開始時のノイズ）が表示されます。 自己相似性は出てきません。 これは、異なるスケールのフラクタルランドスケープのさまざまな組み合わせによって修正できます。 それらの値は、乗算、加算、さまざまな係数での使用、または、たとえば、ボロノイ図を使用して取得したデータを取り込むことができます。一般に、実験の範囲は十分に広いです。 ところで、1つのダイアモンドスクエアのみを使用しても、取得した値（以前は正規化された、つまり0.0から1.0の範囲）を二乗すると便利です。これにより、平野がより穏やかになり、山の傾斜が急になります（浸食について覚えていますか？）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 大きな地図用の菱形アルゴリズムの修正 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後に、ダイアモンドスクエアアルゴリズムの実装について少し説明します。 ランドスケープを生成するときに尋ねる主な質問は、そのサイズを大幅に増加させる方法です。 説明したアルゴリズムの標準実装により、詳細（「深さ」に移動）を簡単に増やすことができますが、次元（「幅」）にはできません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私はこの問題を次のように解決しました。 わからない-おそらく、この決定は誰かによく知られているか、非常に明白であることが判明するかもしれませんが、その前に私はそれに気付かず、すぐに思い付きませんでしたそして失敗しました-その下の詳細）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そのため、アプローチは次のようになります。私たちのランドスケープは、もともと巨大なサイズ（たとえば、16777216x16777216ピクセルですが、これは限界からはほど遠い）で構想されています。 重要なことは、 <b>各ポイント</b>の高さを調べるのではなく、かなり小さな「ウィンドウ」（たとえば、128x128ピクセル）を取得し、高さマップ上を移動する必要があることです。 元のアルゴリズムは簡単に変更できるため、ウィンドウのサイズに比例する操作の数である「ウィンドウ」を計算する必要がありますが、ランドスケープのサイズにはほとんど依存しません。 そのため、最初はランドスケープをほぼ任意に大きく設定できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"> <a href="http://denull.ru/terrain.htm"><img src="https://habrastorage.org/storage/c62fb5e5/0f86ebbc/e70087ac/1619e605.jpg" alt="ダイアモンドスクエアアルゴリズムの実装" title="ダイアモンクデスクアールゴリズムの実装"></a> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>レイジーダイナミクス</b>と呼ばれる手法が役立ちます。 私が話していることを知っている人にとっては、私が説明する問題を知らない人にとっては、すでに明らかになっていると思います。 プロセス全体を裏返します-大きな正方形から始めて各ピクセルに行く代わりに、「ポイント（x、y）で高さを見つける」という形式のリクエストを受け入れ、上に移動します。他の4つのポイントとランダムシフトを平均することで得られました。 最も難しいのは、これらの4つのポイントが何であったかを理解することです。 これを理解した後、「高さを調べる」というリクエストを繰り返すだけで十分ですが、これらのポイントのそれぞれについてです。 これらのリクエストは、順番に1レベル高くなり、最上部に到達してマップのコーナーポイントに達するまで続きます（私にとっては、マップの外側のポイントと同様に、0.0に等しい）。 ソースでは、すべて次のようになります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">val</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, v)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof(v) != <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y] = Math.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, Math.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, v)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= size || y &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || y &gt;= size) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y] == null) { //       . base = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (((x &amp; base) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ((y &amp; base) == <span class="hljs-number"><span class="hljs-number">0</span></span>)) base &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((x &amp; base) != <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ((y &amp; base) != <span class="hljs-number"><span class="hljs-number">0</span></span>)) squareStep(x, y, base); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> diamondStep(x, y, base); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v, blockSize, x, y)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (v + (randFromPair(x, y, seed) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * blockSize * <span class="hljs-number"><span class="hljs-number">2</span></span> / size * roughness); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">squareStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, blockSize)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y] == null) { val(x, y, displace((val(x - blockSize, y - blockSize) + val(x + blockSize, y - blockSize) + val(x - blockSize, y + blockSize) + val(x + blockSize, y + blockSize)) / <span class="hljs-number"><span class="hljs-number">4</span></span>, blockSize, x, y)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">diamondStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, blockSize)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data[x + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + y] == null) { val(x, y, displace((val(x - blockSize, y) + val(x + blockSize, y) + val(x, y - blockSize) + val(x, y + blockSize)) / <span class="hljs-number"><span class="hljs-number">4</span></span>, blockSize, x, y)); } }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     主なことは、すでに計算したすべての高度値を記憶（およびキャッシュに追加）することです。 これにより、同じことを何度も行うことができなくなります。 実際、「ウィンドウ」の最初のポイントを計算したとしても、この「ウィンドウ」に属する他の多くのポイントを同時に認識します。 実際、「ウィンドウ」のすべてのポイントを実行したので、不必要な操作はあまり行いません。ただし、その正確な数は、「ウィンドウ」（左上隅とサイズ）が2のべき乗で整列しているかどうかに大きく依存します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     既に述べたように、アルゴリズムにはいくつかの魔法の行があります-ここにあります： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs">base = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (((x &amp; base) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ((y &amp; base) == <span class="hljs-number"><span class="hljs-number">0</span></span>)) base &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((x &amp; base) != <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ((y &amp; base) != <span class="hljs-number"><span class="hljs-number">0</span></span>)) squareStep(x, y, base); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> diamondStep(x, y, base);</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ここでは、現在の点が正方形または菱形の中心であるかどうか、およびこの図形のサイズは何かを決定します。 正直に言うと、このコードは直感によって書かれたものであり、正確な数学的正当性を示すことはできません。 少なくともいずれかの座標でゼロ以外の最下位ビットを見つけるだけです-望ましいサイズになります。 そして、図が正方形かどうかを判断するために、このビットが両方の座標に設定されていることを確認します。 ここでは、両方の座標にnullインデックスが付けられています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして最後に、予想外の落とし穴：擬似乱数ジェネレーター。 私のコードでは、異常な要件が課されていました。各ポイント<i>（x、y）に対して、</i>常に同じ乱数を取得したいので、すぐにそれを行います。 乱数ジェネレーターの多くのプログラミング言語には、いわゆる 生成された数値の次のシーケンス全体が依存する「シード」（JavaScriptではこれは異なりますが、彼には広範囲にわたる<a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2585%25D1%2580%25D1%258C_%25D0%259C%25D0%25B5%25D1%2580%25D1%2581%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0">Mersenne vortexの</a>実装があります）。 問題は、シーケンスが私たちに合わないということです-ウィンドウをシフト（およびキャッシュをクリア）すると、完全に異なる側の1つのポイントに近づき、ランダムシフトが異なります。 どんな状況でも、それを考慮して、静的な景観が必要です。 両方の座標に応じて「粒子」で毎回メルセンヌ渦を初期化する試みは失敗しました：初期化に時間がかかりすぎます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     少し考えてから、2つの座標をそれらにほとんど相関しない数に変換する簡単な方法は、原則として不可能であるという結論に達しました。 その結果、単純なモジュールによる複数の数字の取得により、許容可能な結果が得られるような関数に決めました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randFromPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">80</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xm7 = x % <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xm13 = x % <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xm1301081 = x % <span class="hljs-number"><span class="hljs-number">1301081</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ym8461 = y % <span class="hljs-number"><span class="hljs-number">8461</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ym105467 = y % <span class="hljs-number"><span class="hljs-number">105467</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ym105943 = y % <span class="hljs-number"><span class="hljs-number">105943</span></span>; y = x + seed; x += (xm7 + xm13 + xm1301081 + ym8461 + ym105467 + ym105943); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (xm7 + xm13 + xm1301081 + ym8461 + ym105467 + ym105943) / <span class="hljs-number"><span class="hljs-number">1520972.0</span></span>; }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さらに、この関数に「グローバルグレイン」を簡単に導入することができました。これは、ランドスケープ全体を決定し、残基の取得により、その戻り値は[0、1）の範囲にかなり均等に分布することが判明しました。 しかし、私はあなたがより速くエレガントなソリューションを思いつくことができると確信しています-この記事でこの「宿題」を考慮することができます:) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     おそらく誰もが推測したように、JavaScriptで実装を作成したため、値とソースコードの両方を簡単に試すことができます。 ページ自体は<a href="http://denull.ru/terrain.htm">http://denull.ru/terrain.htm</a>で入手でき、すべてのコードはファイル<a href="">http://denull.ru/terrain.js</a>にあります。 表示するには、html5をサポートするブラウザーが必要です（正直なところ、Google Chromeでのみテストしました）。これは、レンダリングがキャンバスに送られるためです（また、レンダリング自体にも時間がかかります）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2> 関連資料 </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="http://oddlabs.com/download/terrain_generation.pdf">リアルタイム手続き型地形生成</a> （PDF、1.52 Mb）。 地形の作成に関する非常に詳細で興味深い資料-ボロノイ図とダイアモンドスクエアアルゴリズムの両方を使用し、侵食方法の説明と多くの図と式を使用します。 </li><li>  <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">Polygonal Map Generation</a> 、ボロノイ図に基づいたランドスケープの構築に関する素晴らしい記事。 よく説明されているように、デモswfファイル、他の資料への多くのリンクがあります。 </li><li>  <a href="http://www-evasion.imag.fr/Publications/2007/MDH07/">GPUでの高速油圧侵食シミュレーションと可視化</a> 。  PDFおよび画像だけでなく、それが何であるかを理解するのに役立ついくつかのビデオが存在する場合の水の浸食のシミュレーションの最適化に関する記事。  GPUの負荷をシフトしてプロセスを最適化するというアイデアがどうであれ、このドキュメントには侵食メカニズムに関する十分な情報があります。 </li><li> フラクタルアルゴリズムに関する短い記事： <a href="http://www.gameprogrammer.com/fractal.html">ランダムフラクタルテレインの生成</a> 、 <a href="http://en.wikipedia.org/wiki/Fractal_landscape">フラクタルランドスケープ</a> 、 <a href="http://ibiblio.org/e-notes/VRML/Terra/Terra.htm">フラクタルテレイン</a> 、 <a href="http://en.wikipedia.org/wiki/Diamond-square_algorithm">ダイアモンドスクエアアルゴリズム</a> 。 </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J111531/index.html">隠された意味を持つ35のロゴ</a></li>
<li><a href="../J111534/index.html">ロンドンテックシティは、シリコンバレーの深刻な競争相手になる可能性がありますか？</a></li>
<li><a href="../J111535/index.html">Dropboxを使用するいくつかの非標準的な方法</a></li>
<li><a href="../J111536/index.html">第三世代のKindleの高度な機能のいくつかに関する簡単なメモ</a></li>
<li><a href="../J111537/index.html">Kohana 3.0の紹介-パート3</a></li>
<li><a href="../J111541/index.html">Drupalから添付ファイル付きのメールを送信する</a></li>
<li><a href="../J111545/index.html">検索での評価による並べ替え機能の追加</a></li>
<li><a href="../J111548/index.html">SCEA認証-話し合いますか？</a></li>
<li><a href="../J111552/index.html">有効な企業メールをホスティング事業者からGoogleに転送します</a></li>
<li><a href="../J111554/index.html">Delphiが「死にかけている」または「プログラマは読者ではなく、プログラマは作家である」理由</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>