<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏻 👨🏻‍💼 🌏 x86の実際のレジスタを使用する機能 🧖🏻 🔤 💔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、ハードウェアレベルでの実数による作業の実装の特殊性に直面した著者の経験を検討します。 多くの現代のITプロフェッショナルは、高レベルのデータ抽象化を使用しています。 この記事は、いくつかの興味深いことに目を向けているようです。 
  
  
  
 昔、PYAVU（高級言語でのプログラ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>x86の実際のレジスタを使用する機能</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/353182/"> この記事では、ハードウェアレベルでの実数による作業の実装の特殊性に直面した著者の経験を検討します。 多くの現代のITプロフェッショナルは、高レベルのデータ抽象化を使用しています。 この記事は、いくつかの興味深いことに目を向けているようです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     昔、PYAVU（高級言語でのプログラミング）の講義で、実数について話されました。 最初の情報は表面的なものでした。 大学での研究を終えた後、私は彼らをよりよく知るようになり、この知り合いは私に多くを考えさせました。 そして、この知り合いは、計算でdoubleデータ型に適合しなかった後に発生しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Borland Turbo C ++コンパイラを使用して、C ++で記述されたプログラムを入手しました。 計算には、doubleデータ型が使用されました。 材料タイプの倍精度。 特定の時点で、この二重プログラムがオーバーフローし、正常にクラッシュしました。 階乗はプログラムで計算され、二重に収まる最大階乗は170です！  ≈7.3 <sup>306</sup> 階乗171！≈1,2 <sup>309</sup>の計算により、doubleデータ型のオーバーフローが発生しました。 実数による計算の現在の状況の研究につながったのは、オーバーフローの問題でした。 これについては、記事の後半で詳しく説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     倍精度の実数のオーバーフローは、プログラミング言語によるサポート、コンパイラーによるサポート、プログラムが実行されるプロセッサーのアーキテクチャーの3つのコンポーネントで構成されるグローバルな問題です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プログラミング言語を使用すると、すべてがシンプルで標準化されます。 最愛のC ++言語には、float、double、long doubleの3つの実データ型があり、それぞれ単精度、倍精度、倍精度以上です。 さらに、言語標準では「long double型は少なくともdoubleと同等の精度を提供する」と書かれています。 つまり、long doubleはdouble以上でなければなりません。  Borland Turbo C ++コンパイラの開発者が利用したのは、標準のこの抜け穴で、ロングダブルからダブルに相当します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      x86アーキテクチャもスムーズに進んでいません。 最も単純な数学演算（加算、減算、乗算、除算、シフト、数学関数sin、cosなどの計算）のために、プロセッサの開発者は対応するレジスタを提供します。 レジスタは条件付きで整数で動作するものと実数で動作するものに分けることができます。 実数を処理するためのレジスタがないプロセッサアーキテクチャがあります。 たとえば、ARMv7。 このような場合、整数レジスターと加算、減算、シフトの演算を使用してこれらの演算をプログラムでエミュレートする必要があるため、実数の演算時間は数桁増加します。 たとえば、三角関数をプログラムで計算すると、数学関数を使用して近似的に計算されるため、計算が数桁遅くなる可能性があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     叙情的な余談。  <i>これはまさにプロジェクトの1つで遭遇した問題です。</i>  <i>カメラの下を通る人の数を数える必要がありました。</i>  <i>リアルタイムビデオ処理のためにARMv7の組み込みソリューションを使用しました。</i>  <i>認識され、過去の人々を考慮した。</i>  <i>また、画像処理は実数を使用した作業であり、使用されているアーキテクチャには存在していませんでした。</i>  <i>より高度なハードウェアソリューションに切り替える必要がありましたが、それは別の話です。</i>  <i>戻りましょう。</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      80486プロセッサのリリース以前に広く使用されていたx86アーキテクチャにも、実際のレジスタはありませんでした。 昔の人はおそらく、従来のプロセッサの隣にインストールされ、対応する指定（8087、80287、または80387）があり、アクティブな冷却なしで、ラジエーターなしでも動作した数学コプロセッサーのようなものを覚えています。  IEEE 754-1985規格の出現のきっかけとなったのは、8087コプロセッサの登場でした。これについては後で検討します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/l3/wx/08/l3wx08st-88e9lrgslkjm-gk4xk.jpeg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらのコプロセッサは、3つの抽象実データ型、8つの80ビットレジスタ、およびそれらを操作するためのアセンブラ命令の束を追加しました。 これで、条件付きで、1サイクルで、実数の加算、減算、乗算、除算、抽出、ルートの抽出、三角関数の計算などが可能になりました。 特定のタスクで計算の加速が500％に達しました。 しかし、ワードプロセッシングのタスクは加速されなかったため、このコプロセッサーはオプションで150ドルでインストールされました。 そのときコンピューターで音楽を聴いた人はほとんどいませんでしたが、一般的にはビデオは一般ユーザー向けではありませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      80486シリーズプロセッサから、コプロセッサはプロセッサ自体に統合され始めました。  Intel486SXに加えて、このプロセッサは後で登場し、無効になったコプロセッサがありました。 物理的には、彼は他のプロセッサとそれほど違いはありませんでした。 どうやら、Intelはコプロセッサーの分野でエラーのある欠陥のあるコピーを実装することを決めたようです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     数学コプロセッサーの実際のレジスターについてさらに詳しく考えてみましょう。 実際には、これは同じタイプのレジスタです。 大きい、80ビット、スタックに8個のピース​​がある場合。 しかし、プログラマーは実数の抽象化に3種類あります。短い（単精度）形式（単精度）、長い（倍精度）、および数値を表現するための拡張形式（拡張精度）です。 ここで、用語のロシア語の翻訳は本[1]から与えられています。 実数の特性を表に示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/wf/cd/fw/wfcdfwfl5siaviibcvjaqrsmd80.jpeg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プログラマーがショートフォーマット（32ビット）などを使用することを選択した場合、コプロセッサーは80ビットのレジスターに数値を挿入し、操作を実行してから、作業中にショートフォーマットの制限が発生した場合、数値を縮小サイズで返しました、NaNが返されました（数字ではなく、数字ではありません）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      x86アーキテクチャのさらなる開発により、多数の拡張機能（MMX、SSE、SSE2、SSE3、SSSE3、SSE4、SSE5、AVX、AVX2、AVX-512など）が追加され、拡張機能とともに新しいレジスタ128、256、512ビット長が追加されました[2] 、およびそれらを操作するための多数の新しいアセンブラコマンド。 これらの拡張機能は、単精度と倍精度の実数でのみ動作する機能を提供します。たとえば、各512ビットレジスタは、8つの64ビットの倍精度数または16の32ビットの単精度数のいずれかで動作できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     アーキテクチャについて考えることから、コンパイラに移りましょう。  C ++プログラミング言語では、floatデータ型はx86アーキテクチャの32ビット実数に対応し、2倍から64ビットになりますが、long doubleではすべてがより興味深いものになります。 前述のように、多くのコンパイラ開発者は標準の仮定を使用して、long double型をdoubleに等しくします。 しかし、ハードウェアx86thでは、拡張80ビット形式で動作できます。 そして、それらを使用できるコンパイラがあります。 コンパイラについて詳しく見てみましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     奇妙なことに、80ビット拡張データプレゼンテーション形式を無視しているものの中には、よく知られ広く使用されているコンパイラが多数あります。ここに、Microsoft Visual C ++、C ++ Builder、Watcom C ++、Comeau C / C ++の部分的なリストを示します。 しかし、拡張形式をサポートするコンパイラのリストは非常に興味深いものです：Intel C ++、GCC、Clang、Oracle Solaris Studio。 コンパイラについて詳しく見てみましょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Intelのコンパイラは、拡張フォーマットを持つことに失敗することはありませんでした-メーカーはどのようにして適切なツールなしでハードウェアを残すのですか コンパイラの使用は無料ではありません。 コンパイラは、科学計算や高性能マルチプロセッサシステムで広く使用されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     無料のGCCコンパイラは、Linuxオペレーティングシステムで拡張フォーマットを簡単にサポートします。  Windowsでは、すべてがより興味深いものになります。  Windows用のコンパイラには、MinGWとCygwinの2つの適応があります。 どちらも拡張形式を操作できますが、MinGWはMicrosoftのランタイムを使用します。つまり、64ビットの倍精度を超える実数はどこでも表示/表示できません。  Cygwinを使用すると、移植がより複雑になるため、すべてが少し改善されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      GCCと同様に、Clangは拡張形式をサポートしています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まあ、以前はSun StudioだったOracle Solaris Studioについて少し。 その存在の終わりに向かって、サンは多くの技術を利用可能にしました。 コンパイラを含めます。 もともとは、SPARCアーキテクチャプロセッサを搭載したSolaris OS用に開発されました。 後に、オペレーティングシステムはコンパイラとともにx86番目のアーキテクチャに移植されました。  IDEとコンパイラは、Linuxオペレーティングシステムで使用できます。 残念ながら、このコンパイラは「スローアップ」されており、最新のC ++トレンドをサポートしていません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     記事の冒頭で述べたダブルオーバーフローの問題を解決するために、考え、苦しみ、探した後、コードを完全に書き直し、GCC Cygwinコンパイラの機能を使用することにしました。 データを格納するためにlong doubleデータ型が使用されました。  64ビットと80ビットの実数を使用する同様のシステムのパフォーマンスは異なります。  64ビット実数を使用する場合、コンパイラはすべてを最適化し、x86アーキテクチャの最速の「最新の」拡張機能を使用しようとします。  80ビットの数値に切り替える場合、アーキテクチャの「古代の」「コプロセッサ」の部分が関係します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     もちろん、大きな実数を処理するためのソフトウェア手法を使用してオーバーフロー問題を解決することは可能でしたが、プログラムは三角関数を含む数学的モデルを計算し、根を抽出し、階乗を計算するため、パフォーマンスの低下は著しくなります。 拡張フォーマットを使用してモデルを計算する作業は、入力パラメーターに応じて、約8〜12時間のプロセッサー時間を要しました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     記事の終わりに、IEEE 754標準[3,4,5]について少し考察します。 前述のように、標準の最初のバージョンは8087数学コプロセッサーのおかげで登場しましたが、この標準の後続バージョンは1997年と2008年にリリースされました。  2008年の標準は最も興味深いものです。 実数の4倍精度（4極、4倍精度浮動小数点形式）[6]について説明します。 上記のタスクに最適なのは、このデータストレージ形式です。 しかし、一般的なコンピュータの手頃な価格のプロセッサアーキテクチャには実装されていません。 一方、x86アーキテクチャには長い間必要なサイズのレジスタ（128、256、512ビット）がありましたが、いくつかの単精度および倍精度の数値をすばやく処理するのに役立ちます。 インテルが将来のプロセッサーで4倍精度のサポートを導入するというインターネット情報で会いましたが、どうやらこれは紙でしか残っていなかったようです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      4倍の精度をサポートする最新のアーキテクチャのうち、SPARC V8とV9のアーキテクチャは区別できます。 それぞれ1990年と1993年に登場しましたが、4倍精度の物理的な実現は2004年にのみ登場しました。  2015年、IBMは4倍の実数をサポートするPOWER9 CPU仕様（ISA 3.0）をリリースしました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      4倍の実数の精度は、幅広いユーザーにとって不要です。 主に科学計算で使用されます。 たとえば、天体物理計算で。 これは、70-80年代に製造されたIBM360コンピューターが128ビットの実数をサポートしていた理由を説明できますが、もちろん最新のIEEE 754に対応していませんでした。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     また、MCSTプロセッサのロシアの開発者についても少し話してみましょう。 この会社は、SPARCアーキテクチャプロセッサを設計および製造しています。 しかし、興味深いことに、最初は4つの実数をサポートせずに「古い」SPARC V8アーキテクチャ（2001年のMTsST-R150および2004年のMTsST R500）のプロセッサを開発およびリリースしました。 そして2011年になって、彼らは4倍精度の実数をサポートするSPARC V9アーキテクチャを備えたMCST R1000プロセッサをリリースしました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      IEEE 754標準に関するもう少しの言葉インターネットに関する興味深い記事[3]には、非常に感情的に、既存の標準の問題と欠点が説明されています。 記事[4]では、標準とその問題についても説明しています。 さらに、実数を表現するための新しいアプローチの必要性についても説明しています。 上記の2つの記事では、数字の表現の欠点の多くについて説明していますが、私はこれを追加します。 プログラミングでは、「松葉杖」が何か間違っているという用語がありますが、最適な方法ではなく、特定の時間に現在の問題を解決するのに役立ちます。 したがって、IEEE754標準に対応する実数は松葉杖です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして、なぜこの結論がここに現れました。 負のゼロがないため、10進形式への変換とその逆はあいまいです。実数を扱う場合、プログラマーは、可能な値の範囲の許容限界に近づくときの実数の危険な動作を常に覚えておく必要があり、実数を比較するときは、許容範囲の精度で範囲を比較する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> 魅力的な素材とソース： </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li> ユロフV.I. アセンブラー。 高校向けの教科書。 第2版  -SPb。：Peter 2005 </li><li>  <a href="https://en.wikipedia.org/wiki/X86">x86</a> </li><li> ユロビツキーV.M.  <a href="http://www.yur.ru/science/computer/IEEE754.htm">IEEE754-tikaは人類を脅かす</a> </li><li>  Yashkardin V. <a href="http://www.softelectro.ru/ieee754.html">IEEE</a> 754- <a href="http://www.softelectro.ru/ieee754.html">バイナリ浮動小数点演算標準</a> </li><li>  IEEE 754ウィキペディアの記事：1、2、3 </li><li> 実数の4倍精度に関する<a href="https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format">ウィキペディアの記事</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J353166/index.html">そして、本当の宇宙飛行士がいます！ Imagine Cup 2018で</a></li>
<li><a href="../J353168/index.html">クラウドにデータを保存する</a></li>
<li><a href="../J353172/index.html">3つのマイクロサービスストーリー、またはエンタープライズ向けMSA</a></li>
<li><a href="../J353176/index.html">フィンテックのダイジェスト：ロックフェラーとソロスは暗号通貨に投資し、中央銀行はソーシャルネットワークに不満を探しています、ビットコインは安くなっています</a></li>
<li><a href="../J35318/index.html">テキストに絵文字をどのように入れますか？</a></li>
<li><a href="../J35319/index.html">私の世界対オドノクラスニキ。 何を使いますか？</a></li>
<li><a href="../J353190/index.html">HSEレクチャーホールでのゲーム開発ゲームのスピーチビデオ</a></li>
<li><a href="../J353194/index.html">プログラマーの継続的インテグレーションと開始点</a></li>
<li><a href="../J353198/index.html">SelectelTechDay：いかがでしたか</a></li>
<li><a href="../J353200/index.html">エピソード0。ハック対Mac。 Xcodeのビルド時間</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>