<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏻 👩🏾‍🏭 👨‍🎓 プロセスメモリ編成 🔟 👌🏾 😄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="メモリ管理は、オペレーティングシステムの中心的な側面です。 これは、プログラミングとシステム管理に基本的な影響を及ぼします。 次のいくつかの投稿では、記憶の仕事に関連する問題に触れます。 実用面に重点が置かれますが、内部デバイスの詳細は無視しません。 検討中の概念は非常に一般的ですが、主にx86-3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>プロセスメモリ編成</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body"><img src="https://habrastorage.org/storage2/b27/d87/ea3/b27d87ea315ccc5f2ee945df3c9f34c3.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     メモリ管理は、オペレーティングシステムの中心的な側面です。 これは、プログラミングとシステム管理に基本的な影響を及ぼします。 次のいくつかの投稿では、記憶の仕事に関連する問題に触れます。 実用面に重点が置かれますが、内部デバイスの詳細は無視しません。 検討中の概念は非常に一般的ですが、主にx86-32コンピューターで実行されているLinuxおよびWindowsの例で説明されています。 最初の投稿では、ユーザープロセスのメモリ構成について説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     マルチタスクOSの各プロセスは、独自のサンドボックスで実行されます。 このサンドボックスは、32ビット保護モードでは<b>常に4ギガバイトのサイズを持つ</b> <b>仮想アドレス空間</b>です。 仮想空間と物理メモリの対応は、 <b>ページテーブル</b>を使用して記述され<b>ます</b> 。 カーネルはテーブルを作成してデータを設定し、必要に応じてプロセッサがアドレスに変換するためにテーブルにアクセスします。 各プロセスは、独自のテーブルセットで動作します。 重要な点が1つあります。仮想アドレス指定の概念は<i>、カーネル自体を含む</i> <i>実行中のすべてのソフトウェアに</i>拡張さ<i>れ</i> <i>ます</i> 。 このため、仮想アドレス空間の一部（いわゆるカーネル空間）は予約されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     もちろん、これは、カーネルがこのすべてのスペースを占有<b>する</b>ことを<b>意味するもの</b>で<b>はなく</b> 、このアドレスの範囲だけを使用して、カーネルが選択した物理アドレススペースの任意の部分をマッピングできます。 カーネルスペースに対応するメモリページは、ページテーブルで<a href="http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection">特権コード</a> （リング2以上の特権）専用に使用可能としてマークされます。 ユーザーモードコードからこれらのページにアクセスしようとすると、ページフォールトが生成されます。  Linuxの場合、カーネルスペースは常にプロセスメモリに存在し、異なるプロセスはカーネルスペースを物理メモリの同じ領域にマップします。 したがって、割り込みまたはシステムコールを処理する必要がある場合、カーネルコードとデータは常に利用可能です。 対照的に、ユーザーモード空間にマップされたランダムアクセスメモリは、コンテキストが切り替わるたびに変化します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/ce2/f75/212/ce2f75212cc1f7ca73d92b07546cff39.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     図の青色は、物理メモリセクションに対応する仮想アドレス空間の領域を示しています。 白-まだ使用されていない領域。 ご覧のとおり、Firefoxはほとんどの仮想アドレス空間を使用しました。 私たちは皆、RAMの観点からこのプログラムの伝説的な大食いについて知っています。 図の青いバーは、ヒープ、スタックなどのプログラム<b>メモリセグメント</b>です。 この場合、セグメントごとに、単に連続したアドレス範囲を意味することに注意してください。 これらは<a href="http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation">、Intelプロセッサのセグメンテーションを</a>説明するときに説明<b>するセグメント</b>ではあり<b>ません</b> 。 何らかの方法で、ここにLinuxの標準プロセスメモリ構成スキームを示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/468/646/0f9/4686460f9c5995b4300ae5f8d6275f91.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     むかしむかし、コンピューター技術がまだ初期段階にあったとき、セグメントの初期仮想アドレスは、マシンによって実行されるほとんどすべてのプロセスで<b>まったく同じ</b>でした。 このため、リモートからの脆弱性の悪用は大幅に簡素化されます。 エクスプロイトは、スタック上のアドレスやライブラリ関数のアドレスなど、絶対アドレスでメモリにアクセスする必要があります。 リモート攻撃を実行しようとするハッカーは、異なるマシンのメモリ内のプログラムセグメントの配置が同一になることを期待して、ブラインドコンタクトのアドレスを選択する必要があります。 そして、それが本当に同一である場合、人々がハッキングすることが起こります。 このため、プロセスのアドレス空間内のセグメントの位置をランダム化するメカニズムが人気を集めています。  Linuxは、 <a href="">スタック</a> 、 <a href="">メモリマッピングのセグメント</a> 、および<a href="">ヒープ</a>の位置をランダム化します。開始アドレスは、オフセットを追加することで計算されます。 残念ながら、32ビットのスペースはそれほど大きくなく、ランダム化の効率<a href="http://www.stanford.edu/~blp/papers/asrandom.pdf">はある程度平準化されてい</a>ます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ユーザーモードスペースの一番上は、スタックセグメントです。 ほとんどのプログラミング言語は、関数に渡されるローカル変数と引数を保存するためにそれを使用します。 関数またはメソッドを呼び出すと、いわゆるスタックが発生します  <b>スタックフレーム</b> 。 関数が戻ると、スタックフレームは破棄されます。 スタックは非常に単純です。データは<a href="http://en.wikipedia.org/wiki/Lifo">「最後に来た人」（LIFO）</a>の原則に従って処理されます。 このため、スタックの内容を監視するには複雑な制御構造は必要ありません。スタックの最上部へのポインタで十分です。 スタックへのデータの追加と削除は、素早く明確に定義された操作です。 さらに、スタックセグメントの同じ領域を繰り返し使用すると、それらが通常<a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches">プロセッサキャッシュに</a>配置されるという事実につながり、アクセスがさらに高速化されます。 プロセス内の各スレッドは、独自のスタックで動作します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタックセグメントに割り当てられたスペースが、追加されるデータを収容できない可能性があります。 その結果、ページフォールトが生成されます。これは、Linuxでは<a href="">expand_stack（）</a>関数によって処理されます。 次に、別の関数<a href="">acct_stack_growth（）</a>を呼び出します。この関数は、スタックセグメントを増やす機能をチェックします。 スタックセグメントのサイズがRLIMIT_STACK定数（通常は8 MB）の値より小さい場合、サイズは大きくなり、プログラムは何も起こらなかったように実行を続けます。 これは、スタックセグメントのサイズが必要に応じて増加する標準のメカニズムです。 ただし、スタックセグメントの最大許容サイズに達すると<b>、スタックオーバーフロー</b>が発生し、Segmentation Faultシグナルがプログラムに送信されます。 スタックセグメントは、必要に応じて拡大できますが、含まれるスタック構造が小さくなっても縮小することはありません。 連邦予算と同様に、スタックセグメントは成長のみ可能です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      「マップされていない」メモリ領域にアクセスすることを有効な操作とみなすことができるのは、動的なスタックの成長<a href="">のみ</a>です。 その他のアクセスでは、ページフォールトの後にセグメンテーションフォールトが発生します。 使用される一部の領域は読み取り専用としてマークされており、それらにアクセスするとセグメンテーションフォールトが発生します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     スタックの下には、メモリマッピング用のセグメントがあります。 カーネルはこのセグメントを使用して、ファイルの内容をマップ（メモリにマップ）します。 すべてのアプリケーションは、 <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mmap.2.html">mmap（）</a>システムコール（ <a href="">mmapコール実装の説明へのリンク</a> ）またはWindowsの<a href="http://msdn.microsoft.com/en-us/library/aa366537(VS.85).aspx">CreateFileMapping（）</a> / <a href="http://msdn.microsoft.com/en-us/library/aa366761(VS.85).aspx">MapViewOfFile（）</a>を介してこの機能を使用できます。 ファイルのメモリへのマッピングは便利で高性能なファイルI / O方式であり、たとえば動的ライブラリをロードするために使用されます。  <b>匿名メモリマッピングの</b>可能性があります。その結果、ファイルがマッピングされない領域が得られ、代わりにプログラムが動作するあらゆる種類のデータを配置するために使用されます。  Linuxで<a href="http://www.kernel.org/doc/man-pages/online/pages/man3/malloc.3.html">malloc（）</a>を使用してメモリの大きなブロックの割り当てを要求すると、標準Cライブラリはヒープにメモリを割り当てる代わりに、匿名マッピングメカニズムを使用します。 この場合、「大」という語は、定数MMAP_THRESHOLDの値よりも大きいバイト単位の値を意味します。 デフォルトでは、この値は128 kBであり、 <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/undocumented.3.html">mallopt（）を</a>呼び出して制御できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ヒープといえば。 次に、プロセスのアドレス空間の説明で説明します。 スタックと同様に、ヒープはプログラムの実行中にメモリを割り当てるために使用されます。 スタックとは異なり、ヒープに割り当てられたメモリは、このメモリの割り当てを引き起こした関数が終了した後に保存されます。 ほとんどの言語は、ヒープメモリコントロールを提供します。 したがって、カーネルと言語のランタイムが一緒になって追加メモリを動的に割り当てます。  Cでは、ヒープを操作するためのインターフェイスは<a href="http://www.kernel.org/doc/man-pages/online/pages/man3/malloc.3.html">関数のmalloc（）</a>ファミリですが、C＃のようなガベージコレクションをサポートする言語では、メインインターフェイスはnew演算子です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     現在のヒープサイズで要求された量のメモリを割り当てることができる場合、カーネルを使用せずにランタイムのみを使用して割り当てることができます。 それ以外の場合、malloc（）関数は<a href="http://www.kernel.org/doc/man-pages/online/pages/man2/brk.2.html">brk（）</a>システムコールを使用して、必要に応じてヒープを増やします（ <a href="">brkコール実装の説明へのリンク</a> ）。 ヒープ上のメモリの管理は、複雑なアルゴリズムを使用して解決するのは<a href="http://g.oswego.edu/dl/html/malloc.html">簡単な作業</a>ではあり<a href="http://g.oswego.edu/dl/html/malloc.html">ませ</a>ん。 これらのアルゴリズムは、プログラム内の予測不可能で混chaとしたメモリ割り当てパターンの条件で高速かつ効率的に達成するよう努めています。 各要求がヒープにメモリを割り当てるのにかかる時間は、劇的に異なる場合があります。 この問題を解決するために、リアルタイムシステムは<a href="http://www.gii.upv.es/tlsf/">特殊なメモリアロケーターを</a>使用し<a href="http://www.gii.upv.es/tlsf/">ます</a> 。 ヒープは<i>断片化の</i>影響も受けます。これは、たとえば次の図に示されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/a27/329/ae2/a27329ae21ae0d2ecb6efd0ced4a6f54.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最後に、プロセスアドレス空間の下部にあるセグメント、BSS、データセグメント（データセグメント）、およびコードセグメント（テキストセグメント）に到達しました。  BSSとデータセグメントは、Cのソースコードの静的変数に対応するデータを格納します。違いは、BSSが、ソースコードで値が明示的に指定されて<i>いない初期化さ</i>れて<i>いない</i>変数に対応するデータを格納することです（ <i>実際、オブジェクトは、変数宣言が明示的にゼロ値を示しているか、値が最初に指定されておらず、リンクされたファイルにゼロ以外の値を持つ同じ共通文字が含まれていない</i> 。  BSSセグメントには匿名メモリマッピングが使用されます。 このセグメントにマップされるファイルはありません。  Cソースファイルで<i>int cntActiveUsersが</i>使用されている場合、対応するオブジェクトのスペースがBSSに割り当てられます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      BSSとは異なり、データセグメントには、ソースコードでゼロ以外の値で初期化された静的変数の宣言に対応するオブジェクトが格納されます。 このメモリセグメントは<b>匿名で</b>はあり<b>ません</b> 。プログラムイメージの一部がそこにマッピングされます。 したがって、 <i>静的int cntWorkerBees = 10</i>を使用すると、対応するオブジェクトのスペースがデータセグメントに割り当てられ、値10が格納されます。ファイルはデータセグメントに表示されますが、これはいわゆるです。  <b>「プライベートマッピング」（プライベートメモリマッピング）</b> 。 これは、このセグメントでのデータ変更が対応するファイルの内容に影響しないことを意味します。 そうする必要があります。そうしないと、グローバル変数に値を割り当てると、ディスクに保存されているファイルの内容が変更されてしまいます。 この場合、これはまったく必要ありません！ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ポインターを使用すると、状況はもう少し複雑になります。 図の例では、 <i>gonzo</i>変数に対応する<i>オブジェクト</i>の<i>内容（</i>これは4バイトのアドレスです）はデータセグメントにあります。 ただし、ポインターによって参照される行は、データセグメントに分類されません。 文字列は読み取り専用の<b>コードセグメントにあり、</b>すべてのコードと、たとえば文字列リテラルなどの些細なことを格納します（ <i>実際には、文字列は.rodataセクションに格納され、実行可能コードを含む他のセクションとともに、コードを実行/データを読み取る権限を持つメモリにロードされるセグメント-およその翻訳</i> 。 実行可能ファイルの一部もコードセグメントにマップされます。 プログラムがテキストセグメントに書き込もうとすると、セグメンテーションフォールトが機能します。 これにより、「bazhennyh」ポインターを扱うことができますが、それらに対処する最善の方法は、Cをまったく使用しないことです。以下は、例からのセグメントと変数を示す図です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/aa9/400/b14/aa9400b1449331d2694fc2e45ee6a639.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>/ proc / pid_of_process / maps</i>ファイルの内容を読み取ることで、プロセスメモリ領域がどのように使用されるかを確認できます。 セグメント自体の内容は異なる領域で構成されている場合があることに注意してください。 たとえば、メモリマッピングセグメントにマップされた各ダイナミックライブラリには独自の領域があり、BSSおよびライブラリ内のデータセグメントの領域を選択できます。 次の投稿では、「地域」という言葉の意味を正確に説明します。 時々、データ+ BSS +ヒープを意味する「データセグメント」と言う人がいることに注意してください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://manpages.ubuntu.com/manpages/intrepid/en/man1/nm.1.html">nm</a>および<a href="http://manpages.ubuntu.com/manpages/intrepid/en/man1/objdump.1.html">objdump</a>ユーティリティを使用して、バイナリ実行可能イメージの内容（文字、アドレス、セグメントなど）を表示できます。 最後に、この投稿で説明するのは、プロセスメモリのいわゆる「柔軟な」構成（柔軟なメモリレイアウト）です。これは、Linuxで数年前からデフォルトで使用されています。 このスキームは、定数RLIMIT_STACKの値を定義していることを前提としています。 そうでない場合、Linuxはいわゆる 図に示されている古典的な組織： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/2da/3b9/241/2da3b92412203e699b9a05d4651e6c05.jpg" alt="画像">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     まあ、それだけです。 これで、プロセスメモリの整理についての話は終わりです。 次の投稿では、カーネルが記述されたメモリ領域のサイズをどのように追跡するかを検討します。 また、マッピングの問題、ファイルの読み取りと書き込みがこれに関係すること、メモリの使用を説明する数字が意味することについても触れます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>スマートソフト社員が作成した資料</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://smart-soft.ru/">smart-soft.ru</a> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J185214/index.html">バーチャルリアリティを向上させます。 仮想ホログラム/ NettleBox</a></li>
<li><a href="../J185216/index.html">AntiSpamサービスはメールマーケティングでどのように機能しますか？</a></li>
<li><a href="../J185218/index.html">最新のモバイルWindowsプラットフォーム向けのクロスプラットフォームプログラミング</a></li>
<li><a href="../J185220/index.html">高負荷のアプリケーションアーキテクチャ。 分散システムのスケーリング。 パート1</a></li>
<li><a href="../J185224/index.html">コンピューターゲームで投獄されたテキサスの学校の子供</a></li>
<li><a href="../J185228/index.html">TechEd Europe 2013：今日が未来です</a></li>
<li><a href="../J18523/index.html">CSS検証は本当に必要ですか？</a></li>
<li><a href="../J185230/index.html">Mikrotik-長所と短所</a></li>
<li><a href="../J185232/index.html">UnrealEngineの紹介。 パート1</a></li>
<li><a href="../J185234/index.html">Android開発の自動化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>