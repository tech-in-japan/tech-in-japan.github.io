<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧 🚟 📖 This Little Miracle-Knuth-Morris-Pratt（CLC）アルゴリズム 🥥 💐 ❗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Knuth-Morris-Prattアルゴリズムは 、ストリング内のサブストリング（パターン）を検索するために使用されます。 それはもっと簡単かもしれないようです。線に沿って移動し、文字をパターンと順次比較します。 一致しませんでした。比較の開始点を1ステップ移動して、再度比較します。 パターンを見...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>This Little Miracle-Knuth-Morris-Pratt（CLC）アルゴリズム</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/307220/">  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D0%25BD%25D1%2583%25D1%2582%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D0%25BE%25D1%2580%25D1%2580%25D0%25B8%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D1%2580%25D0%25B0%25D1%2582%25D1%2582%25D0%25B0">Knuth-Morris-Prattアルゴリズムは</a> 、ストリング内のサブストリング（パターン）を検索するために使用されます。 それはもっと簡単かもしれないようです。線に沿って移動し、文字をパターンと順次比較します。 一致しませんでした。比較の開始点を1ステップ移動して、再度比較します。 パターンを見つけるか、行の終わりに達するまで、というように。 <a name="habracut"></a> 関数は次のようなものです。 <pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      //        -1,    int find(char *, char *) { // i-     // j-     for (int i=0;[i];++i) { for (int j=0;;++j) { if (![j]) return i; //   if([i+j]!=[j]) break; } //   ,    } //   return -1; }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 簡単な検索ケース 'needle'-サンプル 'stackistogiststigstigigstogstog <b>needle</b> stack stack <b>needle</b> stack'-検索文字列 良いのは、内側のサイクルがすぐに中断されるときです（単純な場合のように、たとえば、ステップ1〜3で）。 ただし、サンプルと文字列に頻繁にネストされた部分が繰り返し含まれている場合（上記の難しいケースのように）、内部ループはサンプルの終わり近くで中断し、検索時間はO（&lt;サンプル長&gt; * &lt;ストリング長&gt;）として評価されます。 ストリングの長さが10万で、サンプルの長さが100の場合、O（1000万）が得られます。 もちろん、100の長さのサンプルを見つけることは非常にまれですが、オリンピアードタスクでは「検索する」ことは一般的なことです。したがって、単純な検索は多くの場合適切ではありません。 、そしてその場で、あなたが単語を入力するとき（ブラウザがこれをどれほど速くするかに気づいていますか）？  KMPアルゴリズムは、文字列とその速度O（&lt;サンプル長&gt; + &lt;文字列長&gt;）内のすべてのサンプルを検出するため、大きなテキスト/サンプルまたは弱いプロセッサ（低予算の携帯電話など）では競合しません。 なぜ「小さい」のですか？  ILCのハイライトはプレフィックス関数であり、非常に小さいためです。 なぜ「奇跡」なのですか？ 完全に異なる問題を解決するように思われるため、この解決策は、素晴らしいトリックの後、文字列内のサンプルのすべての出現を見つける問題の解決策になります。プレフィックス関数が何をどのように行うかを理解するために、複雑な文字列を見てみましょう <div class="scrollable-table"><table><tbody><tr><td>  a </td><td>  <font color="brown"><b>a</b></font> </td><td>  <b>b</b> </td><td>  a </td><td>  <font color="green"><b>a</b></font> </td><td>  <font color="red"><b>b</b></font> </td><td>  a </td><td>  <font color="blue"><b>a</b></font> </td><td>  <font color="magenta"><b>a</b></font> </td><td>  a </td><td>  b </td><td>  a </td><td>  a </td><td>  b </td><td> でも </td><td>  a </td><td>  a </td><td>  b </td></tr><tr><td>  1 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  6 </td><td>  7 </td><td>  8 </td><td>  9 </td><td>  10 </td><td>  11 </td><td>  12 </td><td>  13 </td><td>  14 </td><td>  15 </td><td>  16 </td><td>  17 </td><td>  18 </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  2 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  6 </td><td>  7 </td><td>  8 </td><td>  9 </td><td>  3 </td></tr></tbody></table></div> その下の行は、行内のシンボルの番号（位置）（アルゴリズムの説明の都合上、1で番号を検討してください）であり、一番下の行はプレフィックス長の配列M、プレフィックス機能を理解するためのキーです。 Kは1〜6で、プレフィックス文字列（文字列の最初のインデックスで始まる部分文字列）とサフィックス（文字列の位置7（これは「私たちの」文字a）の長さKの最後の文字を持つ部分文字列） <div class="scrollable-table"><table><tbody><tr><td>  K </td><td> プレフィックス </td><td> 接尾辞 </td></tr><tr><td>  1 </td><td> でも </td><td>  a </td><td> ここではすべてが簡単です。プレフィックスは文字列の最初の文字で、サフィックスは私たちの文字です </td></tr><tr><td>  2 </td><td> ああ </td><td>  ba </td><td></td></tr><tr><td>  3 </td><td>  aab </td><td> あば </td><td></td></tr><tr><td>  <b>4</b> </td><td>  <b>アーバ</b> </td><td>  <b>アーバ</b> </td><td> 最長一致、接尾辞と接頭辞がここと下に重なり始めます（検索文字列の断片のように） </td></tr><tr><td>  5 </td><td> アーバー </td><td> バアバ </td><td></td></tr><tr><td>  6 </td><td> アーバアブ </td><td> アバアバ </td><td></td></tr></tbody></table></div> 注：長さ4の場合、接尾辞（文字のシーケンスとして）は接頭辞と一致し、これは接尾辞が接頭辞と一致するKの最大値です。 プレフィックス長の配列の対応する位置（7）に入力されるのはそれです。  K = 7の場合、接頭辞も接尾辞と一致することに気付くでしょう。これは同じ行であるためです。 しかし、この些細なケースは私たちには適していない、なぜなら アルゴリズムを機能させるには、サブストリングが必要ですS-ソースストリングを示しますS（n）-長さnのストリングSの先頭（プレフィックス）、S [n]-ストリングSの位置nのシンボルS. M [n]配列内の値S（M [n]）-位置nの最大長の接頭辞および接尾辞と同じ行（簡潔にするため、P（n）で示します）。 文字列P（n）は一種の「仮想」であり、形成されず、どこにも書き込まれません。 これは、長さM [n]の元の文字列Sの開始フラグメント1です。 そして、この最初のfragment1は、長さM [n]のfragment2と一致し（文字のシーケンスとして）、その最後の文字は位置nにあります。  M [n] = 0の場合、一致はありません：配列の位置7は値M [7] = 4で埋められ、最長行はP（7）=長さ4の ' <b>aaba</b> '（自然）で、位置8に移動して埋めますM [8]。  1から7までのすべてのプレフィックスとサフィックスの長さを愚かに数え、それらを比較し、最大長を位置8に書き込むことができます。しかし、他の方法（ILCの後）に進みます。 長さkの最大の長い行P（8）を見つけましょう。これは、位置8の接頭辞と接尾辞です。最初のk-1文字からの行p7は、位置k-1の接頭辞と接尾辞です。  7番目のポジションで最も長いという事実ではありません。 ただし、p7 = P7であることが判明した場合、P8はP7の1文字の拡張です。  P7を1ポジション拡張できるかどうかを確認するには、サフィックスに追加された文字（これは文字S [8] = <font color="blue"><b>a</b></font> ）が次のプレフィックス文字と一致するかどうかを確認する必要があります。 接頭辞<font color="green"><b>a</b></font>の次の文字は、位置M [7] + 1 = 5にあります（これがなぜかを考えてください）。 一致した場合（そして、この場合は一致した場合）、タスクは完了します-M [8] = M [7] +1、および8番目の位置にあるP（8）= P（7）+文字S [8] = <font color="blue"><b>a</b></font> 。  P（8）= ' <b>aabaa</b> 'を<b>取得し</b>ます。 拡張が成功すると、配列の次の値を計算するために必要な比較は1つだけです。 ちなみに、配列に沿って移動する場合、値は最大1増加する可能<i>性が</i>あります。 <i>便宜上、複雑な行を繰り返して、上下に移動する必要がないようにします。</i> <div class="scrollable-table"><table><tbody><tr><td>  a </td><td>  <font color="brown"><b>a</b></font> </td><td>  <b>b</b> </td><td>  a </td><td>  <font color="green"><b>a</b></font> </td><td>  <font color="red"><b>b</b></font> </td><td>  a </td><td>  <font color="blue"><b>a</b></font> </td><td>  <font color="magenta"><b>a</b></font> </td><td>  a </td><td>  b </td><td>  a </td><td>  a </td><td>  b </td><td> でも </td><td>  a </td><td>  a </td><td>  b </td></tr><tr><td>  1 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  6 </td><td>  7 </td><td>  8 </td><td>  9 </td><td>  10 </td><td>  11 </td><td>  12 </td><td>  13 </td><td>  14 </td><td>  15 </td><td>  16 </td><td>  17 </td><td>  18 </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  2 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  6 </td><td>  7 </td><td>  8 </td><td>  9 </td><td>  3 </td></tr></tbody></table></div> 別のケース-P8を展開できませんでした。 文字S [9] = <font color="magenta">a</font>は、位置M [8] + 1 = 6 <font color="red">b</font>の文字列Sの文字と一致しませんでした。 サフィックスは簡単に展開されます（新しい文字が単に末尾に追加されるため）が、問題のあるプレフィックスが付いているため、 接尾辞に追加される文字は、次の接頭辞文字と一致しない場合があります。 接頭辞P（k）が収まらない場合、同じ接尾辞を持つ別の短い接頭辞を見つける必要があり、それを展開してみてください。 ただし、接頭辞は短く、同じ接尾辞ではS [M [M [k]]）です。 配列Mを埋めるとき、各要素には同じ接尾辞を持つ最長の接頭辞の長さが含まれます。 したがって、S（M [k]）を展開できなかった場合は、S（M [M [k]]）なども一致するまで、または長さがゼロになるまで（次の文字Sを単純に比較する必要があります） 1mの文字列S）。 必要なすべての情報がすでに配列Mにあるため、適切なプレフィックスの検索サイクルは非常に速く終了します。この行では、P（8）はP（7）の1文字だけの拡張であり、1回の比較が必要です。 ただし、S [9] = <font color="magenta"><b>a</b></font>およびS [M [8] + 1 = 6] = <font color="red"><b>b</b></font>であるため、P（8）をP（9）に展開できませんでした。 長さM [8] = 5のプレフィックスP8が適合しなかったため、長さM [5] = 2のプレフィックスを試します。 また、S [2 + 1] = <b>bに</b>適合しません。 長さM [2] = 1のプレフィックスを試してみます。  S [1 + 1] = <font color="brown"><b>a</b></font> 。 したがって、M [9] = 2、拡張可能なプレフィックスの長さより1つ多くなります。  M [10]を埋めるには、2つの比較が必要です（確認できます）。 ただし、11〜17の要素を入力するには、1つの比較が必要です。 その結果、配列値の計算にはO（文字列の長さ）のオーダーの時間がかかるため、塗りつぶしアルゴリズムを使用すると、多かれ少なかれ明確になります。 <h2> 私たちはトリックに目を向けます。 </h2> 文字列<font color="brown">aabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaの</font>サンプル<font color="blue">abaaa</font>を見つけるには <div class="scrollable-table"><table><tbody><tr><td>  a </td><td>  a </td><td>  b </td><td>  a </td><td>  a </td><td>  @ </td><td>  a </td><td>  a </td><td>  b </td><td>  a </td><td>  <font color="magenta"><b>a</b></font> </td><td>  b </td><td>  a </td><td>  <font color="magenta"><b>a</b></font> </td><td>  a </td><td>  a </td><td>  b </td><td>  a </td><td>  <font color="magenta"><b>a</b></font> </td><td>  b </td><td> でも </td><td>  <font color="magenta"><b>a</b></font> </td><td>  a </td><td>  b </td></tr><tr><td>  1 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  6 </td><td>  7 </td><td>  8 </td><td>  9 </td><td>  10 </td><td>  11 </td><td>  12 </td><td>  13 </td><td>  14 </td><td>  15 </td><td>  16 </td><td>  17 </td><td>  18 </td><td>  19 </td><td>  20 </td><td>  21 </td><td>  22 </td><td>  23 </td><td>  24 </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  2 </td><td>  0 </td><td>  1 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  2 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  2 </td><td>  3 </td></tr></tbody></table></div> 記号<b>「@</b> 」はセパレーターの役割を果たしますが、サンプルや検索行には見当たりません（このような記号だけを選択する必要があります）。 配列の11、14、19、22の位置を見てみましょう。 配列の値は5です。これは、長さ5のサフィックス（検索文字列のフラグメント）が5つのプレフィックス文字に一致することを意味します。 プレフィックスの5文字-これが検索のパターンです！ 検索アルゴリズムは次のとおりです-セパレータを使用してサンプルと検索文字列を接着し、接頭辞関数の「接着」を渡し、サンプルの長さに等しい要素を配列で調べます。 <i>値がセパレータ文字と値のためにサンプルの長さを超えないことがわかりますサンプルの長さと等しい値は、元の検索文字列に対応する位置にのみ表示できます。</i> 接着された文字列の長さは&lt;サンプル長&gt; + &lt;文字列長&gt;であるため、記事の冒頭で述べたように、計算時間はO（&lt;サンプル長&gt; + &lt;文字列長&gt;）と推定されます。 必要なバッファプレフィックス関数のボリュームは&lt;サンプル長&gt; + &lt;ライン長&gt;ですが、バッファ&lt;サンプル長&gt;が十分になるようにプレフィックス関数を変更できます（付録の変更例） <h2> プレフィックス機能 </h2> そして今、プレフィックス関数の例。 上記の説明との違いは、C言語の慣例に従って、インデックスは0からカウントされることです。 <h4>  C ++の例 </h4> この関数は、文字列プレフィックスの長さのベクトルを返し、文字列は文字列として渡されます（長さを計算する必要はありません） <pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; prefix_function (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = s.length(); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; pi(n); <span class="hljs-comment"><span class="hljs-comment">//  i-  (  i-1)           i. // p[0]=0 , p[1]=1,      for (size_t i=1; i&lt;n; ++i) { // ,  -   size_t j = pi[i-1]; //   -,   while ((j &gt; 0) &amp;&amp; (s[i] != s[j])) //   , j = pi[j-1]; //    - if (s[i] == s[j]) ++j; //   ( ) - pi[i] = j; } return pi; }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre><h4>  Cの例 </h4> 関数は何も返しません。 最初のパラメーターは文字列へのポインターであり、2番目はプレフィックス長の入力された配列へのポインターです。3番目のpは文字列と配列の長さです。 <pre> <code class="plaintext hljs">//     size_t,   int void prefix_function (char *s, int *pi, size_t n) { pi[0]=0; //  i-  (  i-1)           i. // p[0]=0 , p[1]=1,      for (size_t i=1; i&lt;n; ++i) { int j = pi[i-1]; while ((j &gt; 0) &amp;&amp; (s[i] != s[j])) //   j = pi[j-1]; //     (   ) if (s[i] == s[j]) //  ++j; pi[i] = j; } }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> このコードは、議論の結果として追加されました。 パターンと検索文字列は、異なるパラメーターで渡されます。 それらを「一緒に接着する」必要はありません。 プレフィックス長の配列は、パターンに対してのみ入力されます。 <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,       int f(size_t i) { printf("%d\n",i); return 1; } // str  . // obr ,  . // pi      (    ). // int f(size_t i)   ,   , //       str . //   0,      1,   . void prefix_find (char *str, char *obr, size_t *pi, int (*f)(size_t)) { pi[0]=0; //  i-  (  i-1)   //          i. // p[0]=0 , p[1]=1,      size_t l; //    //       for (l=1; obr[l]; ++l) { size_t j = pi[l-1]; while ((j &gt; 0) &amp;&amp; (obr[l] != obr[j])) //   j = pi[j-1]; //     (   ) if (obr[l] == obr[j]) //  ++j; pi[l] = j; } size_t j=0; //   ,     //   .        i for (size_t i=0; str[i]; ++i) {</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>  <font><font color="brown">この場所は、ILCの有効性の鍵です。</font></font>  <font><font color="brown">文字列の次の文字とパターンが一致しなかった場合、パターンを1文字移動せず、最初から文字列と比較しません（記事の冒頭のプリミティブ検索のように）。</font></font>  <font><font color="brown">パターンを数文字シフトして、str [i]とobr [j]を1回比較します。</font></font>  <font><font color="brown">一致しない場合、文字が一致するか、パターンの先頭に到達するまで、パターンを再度シフトします。</font></font>  <font><font color="brown">T.O.</font></font>  <font><font color="brown">検索バーに沿って後方に移動するのではなく、前方に移動します（ただし停止します）。</font></font> <pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((j &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (str[i] != obr[j])) <span class="hljs-comment"><span class="hljs-comment">//         .  , //   ,   j       //    j+1   (  j)  i+1  . j = pi[j-1]; //  j=0,         if (str[i] == obr[j]) //     ++j; //      1 if (j==l) if (!f(i-l+1)) //  ,    return; //    ,    0. } }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 小さな奇跡についての私の話-ILCアルゴリズムは終わりました。 もちろん、ILCに関するこの記事は最初のものではなく、最後のものではありません。  habrahabrに関する2つの記事を次に示します<a href="https://habrahabr.ru/post/191454/">。部分文字列を検索します。</a>  <a href="https://habrahabr.ru/post/191454/">Knuth – Morris –プラットアルゴリズムと部分文字列</a> <a href="https://habrahabr.ru/post/113266/">検索と関連事項</a> 。しかし、誰かがこの記事を自分に役立つものと考え、誰か（結局これが起こる可能性がある）がILCを適用することを願っています。 たとえ彼が作品の内部メカニズムをよく理解していなかったとしても（理解するのに遅すぎることはありません）。  KMPアルゴリズムは唯一の高速検索アルゴリズムではありませんが、（olympiadなどの問題に対して） <b>十分に</b>高速であると同時にシンプルです。  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25BE%25D0%25B9%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D1%2583%25D1%2580%25D0%25B0">Boyer-Moore</a>アルゴリズムは複雑さがILCに近く、特定の範囲のタスク（サンプルに反復フラグメントが含まれていない場合）の方が高速です。 しかし、その後、さまざまなタスクの範囲（記事の例のように、サンプルと検索文字列に反復シーケンスが含まれる場合）では、ILCに比べて著しく劣ります。 最後に、どちらかを選択することが好みの問題であるタスクがあります（これは議論されていません）。 場合によっては（または地域でさえ）、 <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2590%25D1%2585%25D0%25BE_%25E2%2580%2594_%25D0%259A%25D0%25BE%25D1%2580%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BA">Aho-Korasikアルゴリズム</a>がILCとBoyer-Mooreの両方よりも効率的であることが判明する場合があります。 しかし、本当にこのアルゴリズムを必要とする人は、一般的な博覧会、 <b>IMHOを</b>必要としません。 <h4> ディスカッション補遺 </h4>  O（行の長さ+サンプルの長さ）ではなくO（サンプルの長さ）を使用するように、プレフィックス関数を変更できます。 この場合、サンプルのプレフィックスの長さを保存するためだけにメモリを割り当てる必要があり、検索文字列のプレフィックスの長さは配列に保存されません。 現在の位置の長さは変数に保存され、サンプルの長さと比較されるとすぐに（つまり、サンプルが見つかると）、プレフィックス関数は見つかったフラグメントの処理関数を呼び出します。 変更されたprefix_find関数が記事に追加<b>さ</b>れました。 実際、配列にメモリを割り当てることで節約する必要はありませんでしたが、誰かがそれを必要とする可能性があることを除外しません<b>。Mayorovp</b>はメモリを節約する機会に注意を喚起し、 <a href="https://habrahabr.ru/post/307220/">メッセージ</a>の中でプレフィックス関数のバリアントの実装へのリンクを与えましたcoutで見つかったフラグメントの位置。 コメントによれば、staticlabは変数のタイプをsize_tに変更しました（これは実際により正確です）。記事を最後まで読んだ人のために、接頭辞と接尾辞のブロックがかなり複雑な場合にどのように編成されるかを示す図を示します： <div class="spoiler">  <b class="spoiler_title">アートワーク</b> <div class="spoiler_text"> ゼロと1の文字列は同じです。最初の2つの図ではインデックスは0から、次では-1からです。実際、これは重要ではありません。部分文字列の<b>長さが</b>配列に書き込まれ、文字列の文字に番号を付ける方法は重要ではありません。最後の図- 「バーズアイ」は、文字列hahrhabhabrhabrhabrhabhabrhabhabrhabhabrhabrhabrhabhabrhabraのプレフィックスとサフィックスを、インデックスと長さの配列なしで調べます。 <img src="https://habrastorage.org/files/dfa/2db/a16/dfa2dba164b34a328a91038099138cef.png"></div>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J30721/index.html">検索に関するGoogleの洞察</a></li>
<li><a href="../J307210/index.html">一般的な初心者HTMLレイアウトエラー</a></li>
<li><a href="../J307212/index.html">ペルセウス団結していない、または日曜大工の衛星フレアをシミュレートしている</a></li>
<li><a href="../J307214/index.html">分散システムまたはスマートシェーパーでのMikrotik QOS</a></li>
<li><a href="../J307218/index.html">アレクサンドル・ネフスキーの橋が引かれているかどうかを知るために必要なニューロンの数は？</a></li>
<li><a href="../J307222/index.html">インディーズゲームの価格について</a></li>
<li><a href="../J307224/index.html">妖精、邪悪な法人、アヒル。 ゲームの実際の作り方。 パート2.プログラマー</a></li>
<li><a href="../J307226/index.html">新しいx：UWPのバインド機能</a></li>
<li><a href="../J30723/index.html">もう一度戻るボタンについて</a></li>
<li><a href="../J307236/index.html">マンデルブロ集合を使用したPi番号の近似</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>