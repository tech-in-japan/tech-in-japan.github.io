<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙁 👨‍👨‍👧‍👦 💖 PIDの再考1.パート3 👨🏻‍🎨 🤕 👩🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="目次 

- PIDの再考1.パート1 
- PIDの再考1.パート2 
- PIDの再考1.パート3 
- PIDの再考1.パート4 
- パート5  
  
  
  
 
  
  ファイルシステムジョブの並列化  
  
 現在のディストリビューションのロードスケジュールを見ると、単なるデー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>PIDの再考1.パート3</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body" data-io-article-url="https://habr.com/ru/post/335780/"><img src="https://habrastorage.org/web/d93/180/250/d93180250c0d43869a9632dc847179bd.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">目次</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/334828/">PIDの再考1.パート1</a> </li><li>  <a href="https://habrahabr.ru/post/335488/">PIDの再考1.パート2</a> </li><li>  <a href="https://habrahabr.ru/post/335780/">PIDの再考1.パート3</a> </li><li>  <a href="https://habrahabr.ru/post/336834/">PIDの再考1.パート4</a> </li><li> パート5 </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> ファイルシステムジョブの並列化 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     現在のディストリビューションのロード<a href="">スケジュール</a>を見ると、単なるデーモンの起動よりも多くの同期ポイントが表示されます。FSに関連付けられているタスクは、マウント、FSのエラーのチェック（fsck）、引用に最も時間がかかります。 現在、ブート中に、 <i>/ etc / fstabで</i>指定されたすべてのディスクがデバイスツリーに表示されるまで待機してから、エラーのチェック、マウント、およびクォータの適用が行われます（もちろんオンになっていない限り）。 このすべての後、さらに先へ進む<b>こと</b>ができ<b>、実際</b>にサービスのダウンロードが開始されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このプロセスを改善できますか？ できることがわかりました。  Harold Hoyerは、由緒ある<i>autofs</i>を使用してプロセスを改善するというアイデアを思いつきました。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>connect（）の</i>呼び出しが別のサービスに関心があることを「宣言」するのと同様に、 <i>open（）</i> （または別の同様の呼び出し）の呼び出しも、ファイルまたはファイルシステムに関心があることを宣言します。 そのため、並列化を改善するには、探しているファイルシステムがまだマウントされていない場合にのみ、これらのアプリケーションを待機させる必要があります。 これを行うには、マウントポイント<i>autofs</i> （偽のマウントポイント）を接続し、通常のOSブート中に実際のFSが<i>fsck</i>ユーティリティによる整合性チェックに合格すると、実際の監視ポイントに置き換えます。 実際のFSがまだマウントされていない間、FSへのアクセス試行はカーネルによってキューに入れられ、アクセス試行はブロックされますが、アドレス指定された唯一のデーモンに対してのみです。 したがって、すべてのFSが使用可能になるずっと前にデーモンを実行でき、同時にファイルアクセスを失うことなく、OSのロードプロセスを最大限に並列化できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      FSタスクの並列化は、すべてのサービス（デーモン）とすべてのバイナリが配置されているマウントポイント-/（FSルート）には意味がありません。 それにもかかわらず、通常はより大きく、暗号化することもでき、リモートマシンからマウントされることもあり、OSブート中にデーモンがアクセスすることはほとんどないマウントポイント<i>/ home</i>により、OSのブート速度を大幅に上げることができます。  <i>procfs</i>や<i>sysfs</i>などの仮想FSが<i>autofs</i>を介してマウントされるべきではないことを思い出す必要はおそらくないでしょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     一部の読者が、 <i>autofs</i>を<i>init</i>プロセスに統合するという決定を少し「脆弱」または奇妙にさえ感じ、それがより「ハッカー」的な側面と呼ばれる場合でも、私にとって驚くことではありません。 それにもかかわらず、彼と多くのことをしたので、私は現在の場所の<i>autofs</i>がとても気分が良いと言うことができます。  autofsを使用すると、実際のFSをすぐに提供せずに監視ポイントを作成できます。 実際、アクセスは延期されています。 アプリケーションが<i>autofs</i> FSにアクセスしようとして、実際のFSに置き換えるのに時間がかかる場合、アプリケーションは中断されたスリープでフリーズします。つまり、 <b>Ctrl + C</b>などを使用して簡単にキャンセルできます<b>。</b> また、アプリケーションの実行中の任意の時点で、実際のFSが（ <i>fsck</i>の失敗により）正しくマウントできない場合、 <i>autofs</i>に実際のエラーコード（ <i>ENOENTなど</i> ）を返すように要求できることに注意してください。 だから...私は、初期化システムへの<i>autofs</i>の統合が最初は愚かに見えるかもしれませんが、私たちの実験的なコードは、当然のことながら、実際にアイデアが驚くほどうまく動作しないことを示したと思います正しい理由のため。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     また、autofsモニター<i>ポイント</i>は、いわゆる<i>ダイレクトマッピング</i> （翻訳者の注意： <a href="https://www.ibm.com/support/knowledgecenter/ru/ssw_aix_71/com.ibm.aix.networkcomm/nfs_automounting.htm">ここ</a>での表示タイプに関する情報）である必要があることに注意してください。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> 最初のユーザーPIDを小さく保つ </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      MacOSのブートロジックから学べるもう1つの良い点は、シェルスクリプト（翻訳者のメモ：シェル、シェル）は悪であるということです。 シェルは「高速」であり、シェルは低速です。 シェルスクリプトでは、何が何であるかをすばやく把握できますが、実行速度には多くのことが望まれます。 従来の<i>sysvinit</i>ブートシステムは、シェルスクリプトを中心にモデル化されています。  <i>/ bin / bash</i>または他のシェル（シェルスクリプトの実行を高速化するために書かれた可能性が高い）であっても、最終的には遅くなる運命にあります。 私のマシンでは、/ <i>etc / init.dの</i>スクリプトが<i>grepを</i> 77回呼び出します。  <i>awk</i>は92回、 <i>cut</i> -23および<i>sed</i> -74で呼び出されます。これらのコマンド（またはその他）が呼び出されるたびに、新しいプロセスが生成され、関連するライブラリが検索され、 <i>i18n</i>などが構成されます。 些細な文字列操作よりも少し複雑な操作がまれにしか実行されない場合でも、読み込みプロセスは中断されます。 もちろん、これはすべて非常にゆっくり実行されます。 しかし、シェル以外の言語ではそのようなことはできません。 さらに、上で述べたように、シェルスクリプトは非常に「壊れやすい」ものです。環境変数や、追跡や制御が困難なその他の類似のものから動作を変更します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ブートプロセス中のシェルスクリプトの負荷を取り除きましょう。 これを行う前に、最初にそれらが実際に何に使用されているかを把握する必要があります。 ほとんどのスクリプトは、サービスの起動と停止にさほど時間をかけず、Cで書き直すか、個別の実行可能ファイルとして書き直すか、サービス自体（デーモン）内で転送するか、ブートシステム自体に実装する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     近い将来、シェルスクリプトの負担を完全に取り除くことができるようには見えません。 それらをCに書き換えるには時間がかかります。場合によっては、このアクティビティにまったく意味がなく、シェルスクリプトが非常に便利な場合があります。 しかし、一般的には、以前よりも必要性と遍在性を低くすることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      OSブートプロセスでのシェルスクリプトの侵襲性を測定するための適切なメトリックは、OSが完全にブートした後に開始できる最初のプロセスのPID番号です。 起動してログインし、ターミナルを開いて<i>echo $$</i>と入力します。  Linuxマシンでこれを試して、結果をMacOSと比較してください！  （ヒント、結果は次のようになります：Linux PID-1823; MacOS PID-154。テストマシンで測定しました。） 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> プロセス追跡 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     サービスを起動および管理するシステムの主要コンポーネントは「看護師」プロセスである必要があります。彼はサービスを監視する必要があります。 停止したらサービスを再起動します。 サービスが「落ちた」場合、管理者が将来それらを見ることができるように、クラッシュに関するすべての必要な情報を収集し、それらを近くのどこかに保管するとともに、そのようなクラッシュダンプ収集システムに存在する情報とのクロスリンクを構築する必要があります<i>abrt</i>と同様に、 <i>syslog</i>などのログサービスや監査システムでも同様<i>です</i> 。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     オブザーバプロセス（「看護師」）は、サービスを完全に停止することもできなければなりません（約：翻訳者：サービスプロセスとそのすべての子プロセスを意味します）。 これは些細な作業のように思えるかもしれませんが、実際には見かけよりもさらに複雑です。 伝統的に、Unixでは、自身を2回分岐するプロセスは、親プロセスによる自身の観察を取り除くことができ、最初の親は、子孫が実際に作成した新しいプロセスとの接続を認識しません。 たとえば、現在の状況では、Apacheサービスが停止しても、自分自身を2回分岐させた「いたずらな」（不正な）CGIスクリプトは停止しません。 さらに、名前と目的がわかるまで、CGIスクリプト「naughty」とApacheの間に接続を確立する機会さえありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     では、プロセスを追跡して「看護師」を取り除くことができず、数百万回分岐した場合に1つのエンティティとして制御できるようにするにはどうすればよいでしょうか。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さまざまな人々がこの問題に対するさまざまなソリューションを提供しています。 この記事のフレームワーク内で詳しく説明するつもりはありませんが、少なくともソリューションは<i>ptrace</i>または<i>netlink</i>コネクター（システム内のプロセスが<i>fork（）</i>または<i>exitを</i>呼び出すたびに<i>netlink</i>メッセージを受信できるカーネルインターフェイス）に基づいていると言えます一部の人々はこれを専用に実装しましたが、多くの人がbyくてスケーラブルでないソリューションとして批判されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     では、これで何ができるでしょうか？ さて、最近、 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/cgroup-v1/cgroups.txt%3Fid%3DHEAD">Control Groups</a> （別名「cgroups」）がカーネルに登場しました。 一般に、これらを使用してプロセスグループの階層を作成できます。 階層は仮想ファイルシステムに直接投影されるため、簡単にアクセスできます。 グループ名は、仮想FS内のディレクトリの名前です。 プロセスがいずれかのグループに属している場合、 <i>fork（）</i>呼び出しで作成されたすべての子孫（子プロセス）も同じグループに属します。 プロセスに特権（ルートなど）はないが、cgroup FSへのアクセス権がある場合、そのグループから離脱できません。 当初、コンテナ目的で<i>cgroup</i>がカーネルに追加されました。特定のカーネルサブシステムは、CPUまたはメモリ使用量の制限など、リソースまたは特定のグループに制限を加える場合があります。 従来、制限の制限（ <i>setrlimit（）で</i>実装されている）は、各プロセスに対して（主に）設定されていました。 一方、 <i>cgroupsを</i>使用すると、プロセスのグループ全体に制限を設定できます。  <i>cgroupsは</i> 、コンテナの直接的な責任の範囲外で制限を設定するためにも使用されます。 たとえば、 <i>cgroups</i>を使用して、Apacheとそのすべての子プロセスが使用するメモリまたはCPUの最大量を設定できます。 そうなると、CGIスクリプトの動作が<i>おかしく</i>なり、そのグループを<i>setrlimit（）</i>で公開したままにできなくなり、単に<i>fork（）を</i>再度呼び出すだけで済みます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     コンテナとリソースの制限の設定に加えて、cgroupはプロセス（サービス）を追跡するツールとしても非常に便利です。cgroupのメンバーシップは、エスケープできないすべての子プロセスに安全に継承されます。 通知システムも存在し、実行中のcgroupが空の場合、親プロセスに通知されます。 ファイル<i>/ proc / $ PID / cgroupを</i>読み取る<i>と、</i>プロセスの<i>cgroupを確認でき</i>ます。 したがって、 <i>cgroupsは</i>プロセスの背後にある「看護師」の役割に非常に適しています。 直接追跡。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> プロセスランタイムの制御 </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     優れた看護師は、サービスがいつ、どのように開始または停止するか、または突然落ちたときを監視および制御するだけでなく、サービスを実行するための最小限の優れた安全な環境も提供する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     心を保護するということは、リソース制限<i>-setrlimit</i> 、ユーザー/グループ識別子、または環境変数のブロックなどの明白なプロセスパラメーターを設定することを意味しますが、それだけではありません。  Linuxカーネルは、ユーザーと管理者にプロセスの適切なレベルの制御を提供します。 プロセスごとに、CPUとIOのスケジューラーパラメーター、CPUへのアトラクション、そしてもちろんcgroup環境に追加の制限などを設定できます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     例として、 <i>IOPRIO_CLASS_IDLEを指定してioprio_set（）</i>を<i>呼び出す</i>と、システムの対話性に対する<i>updatedb</i> <i>Locate</i>ユーティリティの影響を最小限に抑える<i>ことができ</i>ます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     さらに、読み取り専用の監視ポイントに基づいて追加の読み取り専用ファイルレイヤーをマウントする（バインドマウント）など、特定の高レベルの監視ツールが役立ちます。 したがって、特定のデーモン（サービス）を起動して、FSのすべて（または一部）が読み取り専用モードで表示されるようにすることができます。したがって、書き込み試行ごとに<i>EROFS</i>エラーが返されます。 このようにして、貧弱なSELinuxと同じ方法で、デーモンをできることで隔離できます（ただし、この方法はSELinuxに代わるものではありません。SELiなどの悪いアイデアは使用しないでください...）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そして最後に。 ロギングは、サービス実行の重要な部分です。理想的には、サービスによって生成されたすべての出力をログに記録する必要があります。 したがって、ブートシステムは、ダウンロードの最初から開始するデーモンにロギングサービスを提供し、標準出力とエラー出力を<i>syslogに</i>添付するか、場合によっては<i>/ dev / kmsg</i>に添付する必要があります。これは多くの場合、 <i>syslog</i> （組み込みシステムに関係する人は、リッスン！）、特にカーネルログバッファが非常に大きく設定されている場合。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     継続するには... </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J335762/index.html">Windows用のTCPソケットブロックモードの定義</a></li>
<li><a href="../J335770/index.html">Webcam、Node.js、OpenCV：顔認識システムの作成</a></li>
<li><a href="../J335772/index.html">DebianでのMongoDBのインストールと設定、およびReplicaSetと他のいくつかの小さなこと</a></li>
<li><a href="../J335776/index.html">UIテスト-それらは常に必要ですか？</a></li>
<li><a href="../J335778/index.html">ハッカソンチームNavalnyに関するレポート</a></li>
<li><a href="../J335782/index.html">サポートマネージャーの物議を醸す3つのアイデア</a></li>
<li><a href="../J335784/index.html">最後のフロンティア：2番目のテクニカルサポートラインが小売でどのように機能するか</a></li>
<li><a href="../J335786/index.html">Kaggle：衛星画像からのAmazon Terrain分析</a></li>
<li><a href="../J335788/index.html">XBRL：複合体について-第6章XBRLへのダイビング-パート2.結果の改善</a></li>
<li><a href="../J335790/index.html">10の無料でクールなフォント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>