<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FEDBM7F51Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FEDBM7F51Q');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😫 ⬅️ 🎚️ 中央処理装置の開発の見通し ✅ 🍑 📶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="70年前の1941年に、最初のプログラム可能なコンピューターが作成されました。 それ以来、大量の水が流れ、今ではコンピューターがあらゆる場所を取り囲んでいます。 コンピュータの設計の多くの側面は大きく進化しましたが、多くは本質的にまったく変化していません。 特に、中央処理装置の動作原理-アルゴリズム...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="sitemap" type="application/xml" href="/sitemap.xml"/>

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script>document.write('<script src="https://pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://tech-in-japan.github.io/index.html"></a>
    <div class="page-header-text">Clever Geek Handbook</div>
  </header>
  <section class="page js-page"><h1>中央処理装置の開発の見通し</h1><div class="post__text post__text-html js-mediator-article" id="post-content-body">  70年前の1941年に、最初のプログラム可能なコンピューターが作成されました。 それ以来、大量の水が流れ、今ではコンピューターがあらゆる場所を取り囲んでいます。 コンピュータの設計の多くの側面は大きく進化しましたが、多くは本質的にまったく変化していません。 特に、中央<nobr>処理装置</nobr>の動作原理<nobr>-</nobr>アルゴリズムモデル<nobr>-</nobr>は変更されておらず、おそらく変更されません。 このモデルの物理的な制限は十分に理解されており、したがって、速度という意味での中央処理装置の開発の限界がはっきりと見えます。 技術的には、この上限はまだかなり遠いです：数十年の開発と数桁の速度。 しかし、これにより、高速開発の限界に迫るプロセッサの種類を真剣に考えることを妨げてはなりません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     可能な開発経路は、光の速度の有限性、熱力学の法則、 <nobr>要素</nobr>の最小サイズの制限などの基本的な物理的制約によって厳密に決定されているという事実です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> パート1.現在および将来のコンピューティングデバイスの原則 </h3> その存在の初期の数十年では、コンピューターはコンピューティングのみに使用されていました。  「コンピューター」という言葉の元の意味は、ロシア語では「自動コンピューター」（AVM）と訳されています。 少し後に、コンピューターは他のデバイスの制御要素としても使用されるようになり、「コンピューター」という言葉は「 <acronym>汎用プログラム実行プログラム」</acronym>という現代的な意味を獲得しました。 今日、AVMは高度に専門化された（コンピューターセンターで使用される）デバイスであり、制御要素としてのコンピューターは、マイクロ波からロボット生産ライン、携帯電話から宇宙船まで、ほぼすべての自動<nobr>デバイスで</nobr>使用されています。 特に、ラップトップ、デスクトップワークステーション、ゲームコンソール（家庭用コンピューターと呼ばれるデバイス）で制御的な役割を果たします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     いくつかの大きく異なる計算モデルがあるため、将来のAVMはおそらく完全に予想外の方法で配置されるでしょう。 ただし、制御デバイスとしてのコンピューターには、いずれの場合でも実行ユニット（中央処理装置）が含まれている必要があり、このユニットのデバイスはその機能によって厳密に固定されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -他のデバイスに一貫した指示を発行し、 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -現在の状況に応じて、さらなる行動プログラムを選択します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     これらの2つの要件は、英語の「緩和された順次実行」またはロシア語の伝統の「アルゴリズムモデル」と呼ばれるデバイスモデルを自動的に想定しています。 量子コンピューティングは基本的に可逆であり、選択を行うことは基本的に不可逆であるため、このモデルは他の多くのモデルとは異なり、量子に対応するものがありません。 このモデルについては、記事の次の2つの部分で説明します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     ストーリーを完全にするために、現時点で知られている計算のすべてのスケーラブルなハードウェアモデルのリストを示します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -アルゴリズムモデル、つまり、（条件付きで）命令の段階的な実行（「条件付き」は、独立した命令の並列実行が許可されることを意味します）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -ストリームベクトルコンピューティングとその自然な<nobr>一般化-</nobr>量子コンベア。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -セルラー/ネットワークオートマトンとその自然な<nobr>一般化-</nobr>量子オートマトン。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     現在、実際には、シーケンシャル実行モデルを除き、ストリーミングベクトル計算のみが使用されています.3次元グラフィックス（GPU）用の専用コプロセッサーの家庭用コンピューター、および数値シミュレーションと大規模なデータ配列の処理のためのコンピューターステーションの高出力アナログ（GPGPU）で使用されています。 中央処理装置は特定のタスクをストリーム処理装置に委任しますが、制御機能を実行するのは自分自身だけです。 量子コンピューティングの開発により、この状況は変わることはほとんどありません。量子パイプラインとマシンは、中央プロセッサへの追加のみであり、その代替ではありません。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> パート2.現在および将来のプロセッサの要素ベース </h3>基本レベルでは、プロセッサは2種類の要素で構成されています。スイッチとそれらを接続するトラックです。 トラックのタスクは信号を運ぶことであり、スイッチのタスクはこの信号を変換することです。 スイッチとトラックにはさまざまな実装があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私たちの周りのデジタルエレクトロニクスでは、トランジスタはスイッチとして使用され、トラックは導体で作られています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>§2.1。</b>  <b>信号伝送</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/geektimes/post_images/50b/74f/c2a/50b74fc2ae539d7d1b224dbb4fbc43d5.jpg" align="right"> バイナリデジタルエレクトロニクスでは、電圧を使用して信号をエンコードします。 トラックは、電位<nobr>（U <sub>0</sub> ±ε）が</nobr>適用されると「ゼロ」信号を搬送し、電位<nobr>（U <sub>1</sub> ±ε）が</nobr>適用されると「1」信号を搬送します。  U <sub>0</sub>およびU <sub>1</sub>の基本レベルは、（U <sub>0</sub> +ε）&lt;（U <sub>1</sub> -ε）となるように選択されます。ここで、 <nobr>εは</nobr>技術的な理由で不可避です。 ある状態<nobr>から別の</nobr>状態<nobr>へ</nobr>の遷移は、導体内の膨大な数の電子の停止または逆の加速です。 これらのプロセスは両方とも非常に時間がかかり、必然的に大きなエネルギー損失に関連付けられます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     この欠点のないデジタルエレクトロニクスに代わるものがあります：トラックに沿って電子（いわゆるスピントロニクス）または光子（いわゆるフォトンロジック）の一定のストリームを送信し、このストリームの偏光を使用して信号をエンコードできます。  1次元の導波路に沿って移動する電子と光子の両方は、正確に2つの直交偏光状態に存在でき、その1つはゼロと宣言され、もう1つは宣言されます。 どちらが良いですか-光子ロジックまたはスピントロニクス、それは明確ではありませんが： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -どちらの場合も、粒子流は避けられない熱損失で流れますが、これらの損失は任意に小さくできます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -どちらの場合も、流速は光の速度よりも低くなりますが、任意の速度に近づけることができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -どちらの場合も、干渉、熱雑音、バックグラウンド放射（ランダムな粒子が飛んでくる）が信号を歪まないように、複雑な技術が必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     つまり、両方の技術の既知の物理的制限は同じです。 最も可能性が高いのは、複合技術が最良の結果をもたらすことです。光子輸送は長距離で勝ち、短距離で損失します。 同時に、光子の偏光と電子束の間のアダプター（両方向）の実用プロトタイプがすでに開発されています。 グラフェンは、スピントロントラックに最適な材料です。非常に低い熱損失で優れた速度を提供します。 さらに、次の要素の作業プロトタイプが既に存在します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -短距離および中距離で現在の分極を確実に維持するトラック。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -分極を保存し、保存された分極のストリームを形成できるメモリセル。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     グラフェントラック情報： 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2010-06： <a href="http://www.physorg.com/news195395438.html">グラフェンナノワイヤの大量</a>生産<a href="http://www.physorg.com/news195395438.html">。</a> ジョージア工科大学。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2011-01： <a href="http://www.physorg.com/news/2011-01-graphene-spintronics-combo.html">研究者はグラフェンでスピン流を生成することに成功しました。</a> 香港市立大学。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2011-02： <a href="http://www.physorg.com/news/2011-02-pure-current-graphene.html">グラフェンの純粋なスピン流の作成。</a> 香港市立大学。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2011-02： <a href="http://www.physorg.com/news/2011-02-narrow-free-defects-soluble-graphene.html">可溶性の欠陥のないグラフェンナノリボンの大量生産に対応したボトムアップ合成。</a> マインツのマックスプランク高分子研究所。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>§2.2。</b>  <b>スイッチ</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/geektimes/post_images/4b1/440/2cb/4b14402cbd0bfd6e130c8ab7e0bd24ff.jpg" align="right"> デジタルエレクトロニクスで使用されるトランジスタは、次のように動作する3ピンデバイスです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -中間の接点に高電位が印加されると、極端な接点が接続され、スイッチは「導体」位置になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -低い電位が中央の電位に印加された場合、極端な接点が開き、スイッチは「絶縁体」の位置になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     現時点では、1つの分子で構成されるトランジスタの作成とテストに成功しています。 それらの速度とコンパクトさは理論上の限界にほぼ達しますが、これまでのところ、大量生産と使用を可能にする技術はありません。 最新のデジタルエレクトロニクスはすべて、金属酸化物電界効果トランジスタ（MOSFET）に基づいて作られています。 数十年間、チップメーカーはこのようなトランジスタの線形寸法と消費電力を削減してきましたが、いくつかのタイプのマルチターミナルおよびトランジショントランジスタ（BDT、JNT）の工業試験はすでに行われています。 このようなトランジスタは、 <nobr>4〜6</nobr>倍のパフォーマンスを提供できます。 この移行では、プロセスの大幅な変更は不要であり、今後<nobr>5〜10</nobr>年以内に予定されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     基本的な熱力学的な理由から、トランジスタ型のスイッチは効率的に機能できません。効果的なスイッチは、論理要素として保守的で可逆的でなければなりません。 フレドキンバルブとも呼ばれる対称スイッチは、これらの条件を満たします。 <img src="https://habrastorage.org/getpro/geektimes/post_images/fd1/edd/d27/fd1eddd274c509176abd79a38dfb9403.png" align="right"> このデバイスには、2つの入力In <sub>1</sub> 、In <sub>2、2</sub>つの出力Out <sub>1</sub> 、Out <sub>2</sub> 、および<nobr>連続</nobr>トラック<nobr>C（コントロール）があり</nobr>ます。  Cが「0」の位置にある場合、入力と出力は直接接続されます。In1はOut <sub>1</sub> 、In <sub>2</sub>はOut <sub>2</sub>です。  Cが「1」の位置にある場合、入力と出力は交差して接続されます。In1とOut <sub>2</sub> 、In <sub>2</sub>とOut <sub>1</sub>です。 最も可能性が高いのは、最大のコンパクトさ、速度、効率を組み合わせた単一分子バージョンでスピン対称スイッチを実装できることです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     トランジスタと対称スイッチの両方を使用して複雑なロジック回路を作成できますが、対称スイッチの方がはるかに経済的です。 たとえば、信号と論理演算のクローンを作成するために、「not」、「and」、「or」、「and not」、「should」の場合、必要な対称スイッチは1つだけで、「exclude」、「not or」、「not and」は2つ必要ですスイッチ。 これらの操作をトランジスタに実装するには、4〜6個のトランジスタが必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/geektimes/post_images/0bd/ef9/31a/0bdef931a084447c16bf9dc30869310a.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/geektimes/post_images/0e5/30a/397/0e530a3974f9724299d35d78d49e7ae9.png" align="right"> 高速シングルビット加算器（半加算器）は、4個の対称スイッチ（12個のトランジスタの代わりに）を使用し、理想的にはトランジスタアナログよりも大幅に高速な動作速度を提供します：動作時間はわずか2τです（τは1つのスイッチと1つのトラックの信号通過時間です）。 より複雑な回路では、対称スイッチのコンパクトさと速度向上がさらに顕著になります。 マルチビット加算器（全加算器）のリンクは多数のトランジスタで構成されていますが、対称スイッチの実装には4（最もコンパクトなバージョン）から7（最速オプション）のスイッチが必要です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/geektimes/post_images/53e/77b/9f5/53e77b9f52e562fa8e36e5ce77c8842d.png"><img src="https://habrastorage.org/getpro/geektimes/post_images/955/a54/d32/955a54d3244948187be575a01dc17686.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     対称スイッチのユニークな機能は、プロセッサの非常に一般的な構成要素であるマルチプレクサとデマルチプレクサの最大のコンパクトさと速度を実現するのに役立つことです。 残念ながら、対称スイッチは、スピントロニクスまたはフォトンロジックを使用する場合にのみ魅力的になります。 電子機器は、従来のトランジスタを使用する運命にあります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      *この段落では、 <em>ブルース、ソーントンらによる</em>記事の資料と画像を使用してい<em>ます。</em>  、 <a href="http://citeseerx.ist.psu.edu/viewdoc/summary%3Fdoi%3D10.1.1.20.6518">「保守的な可逆論理に基づく効率的な加算回路」</a> （ミシシッピ州立大学、Proc。IEEE Symposium on VLSI、2002）;  <em>Rentergem、de Vos</em> 、 <a href="http://research.cs.queensu.ca/home/akl/cisc879/papers/PAPERS_FROM_UNCONVENTIONAL_COMPUTING/VOLUME_1_Issue_4/RENTERGEM.pdf">「リバーシブル全加算器の最適設計」</a> （Universiteit Gent、International Journal of Unconventional Computing、2005）、およびプライベート通信。 単分子トランジスタの画像は、エール大学のウェブサイトの対応するプレスリリースから取得されています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>§2.3。</b>  <b>おわりに</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     そのため、将来の中央処理装置は、おそらく、スレッドが分極した電子流を伝導するグラフェンテープで作られた巨大なウェブであり、ノードにはミニチュア対称スイッチがあります。 長距離にわたって、信号は光にトランスコードされ、光子によって配信され、宛先にトランスコードされます。 多くの特別なタスク（特に検索とソート）が、量子コンベヤーと自動機によって実行されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> パート3.現在および将来の中央処理装置のアーキテクチャ </h3> 今日のすべての一般的な中央処理装置は、フォンノイマンアーキテクチャのレジスタマシンです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -プロセッサには、特定の数（たとえば16）の番号付きメモリセル（たとえば、それぞれ64ビット）が含まれています。これらは操作レジスタと呼ばれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -プロセッサは、プログラムに従ってレジスタの内容を処理します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -プログラムは一連の命令で、たとえば次のとおりです。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -レジスター2と5から値を取得し、レジスター8にその量を記録します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -レジスタNo. 4に、レジスタNo. 6のアドレスを持つ外部メモリセルの値を読み込みます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -レジスタ番号12から外部NNNデバイスに番号を送信します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -データとプログラム自体はRAMに保存され、プログラムの命令は数字でエンコードされ、シーケンシャルメモリセルに書き込まれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -命令が現在実行されているセルの番号は、命令ポインタと呼ばれる特別なレジスタに格納されます。このレジスタは、実行の終了時に次のメモリセルに移動します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     このアーキテクチャの出現から半世紀以上にわたって、シーケンシャル実行を編成するための数十の代替アーキメティックシステムが提案されてきましたが、それらはすべてパフォーマンスの上限が劣っています。 パフォーマンスの上限は、構造の重要な部分の線形寸法によって決定されます（光の速度の有限性のため）。これは、現在提案されているすべての順次実行アーキテクチャから計算の最大局所性を提供する古典的なレジスタアーキテクチャです。 したがって、少なくともこのあと数十年間は、おそらくこのアーキテクチャが、おそらく<nobr>将来的に</nobr>保存されるでしょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>§3.1。</b>  <b>機能論理ユニット</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/geektimes/post_images/3db/fb7/48e/3dbfb748e803fad4f5e3fcf5539c751b.gif" align="right"> 最初の部分で説明したスイッチとトラックは、加算器、乗算器、マルチプレクサー、デマルチプレクサーなどの機能ロジックユニットを製造するための「原材料」です。 マルチプレクサーとデマルチプレクサーは、鉄道のマーシャリングヤードに似たデバイスです（右の図を参照）。 マルチプレクサーの入力は、 <i>n個の</i>数字（ <i>a</i> <sub>1</sub> .. <i>a <sub>n</sub></i> ）と制御数<i>m</i>を受け取ります。 出力は数値<i>a <sub>m</sub></i> 、つまり<i>n個の</i> <nobr>入力</nobr>数値の<nobr><i>m</i>番目</nobr>です。 デマルチプレクサは、マルチプレクサのミラーアナログです。入力信号を<i>n</i> <nobr><i>番目</i></nobr>の出力の<nobr><i>m番目</i></nobr>に転送します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/27f/0dc/7b4/27f0dc7b4e014912e04bc545c5508014.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     加算器のタスクは、供給された数値を追加することです。  <nobr><i>n</i>ビット</nobr>加算器の入力は、 <nobr><i>n</i>ビットの</nobr> 2つの数値<i>a</i>および<i>b</i>と、1ビットの数値<i>c</i> （0または1）を受け取ります。 加算器は入力数値を加算し、結果<nobr>（ <i>a</i> + <i>b</i> + <i>c</i> ）を生成し</nobr>ます。 これは<nobr>（ <i>n</i> + 1）ビット</nobr>数です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/geektimes/post_images/bbe/0b8/b68/bbe0b8b68e88d7e6c2a25bcd921d3e1d.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     機能論理ユニットは、引数の変化にすぐに応答しません。信号は、回路の最初から最後まで、スイッチを通過することによる遅延と回路内の可能なサイクルを考慮して、最後まで進む必要があります。 設計中の各機能論理ユニットについて、動作時間が計算されます。 最小限のランタイムで機能論理ユニットを設計する広範な理論が開発されました。 そのため、画像での加算と紙上の列での加算の類似性を実行する最も単純な複数桁の加算器は、ビット深度とともに直線的に成長するために作業する時間が必要です。  60年代には、成長を対数的なものに減らす加速移動スキームが開発されました。 対称スイッチでこれらを使用する加算器は、理論的な速度制限である⌈3+ log <sub>2</sub> （ビット容量）⌉・τの結果を計算することが保証されています。  64ビット加算器の場合、単純な実装と比較して15倍の加速が達成されます。 そして、三角関数の乗算、除算、および計算の巧妙な最適化により、何百回も加速することができます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>§3.2。</b>  <b>操作ブロック</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     操作<nobr>ユニットは</nobr> 、1つの<nobr>タイプの</nobr>命令（たとえば、加算と減算）を実行できるデバイスです。 操作<nobr>ユニット</nobr>の基本要素は、実行される命令が書き込まれるメモリセル（いわゆる命令レジスタ）です。 命令の実行時に、ブロックはこのセルをクリアします。 操作ブロックの残りの部分は、互いに接続され、命令レジスタに接続された機能論理ユニットのセットで構成されています。 たとえば、「レジスタ<nobr>No. 2</nobr>および<nobr>No. 5</nobr>から値を加算し、レジスタ<nobr>No. 8に</nobr>金額を書き込む」という形式の命令に従うことができるオペレーティングユニットを考えます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     私たちは、必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -加算演算のコードとオペランドレジスタの番号を格納する命令レジスタ（上記のコマンドの2、5、8）。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -加算器; 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -一方のレジスタブロックと他方の加算器の入力に接続された2つのマルチプレクサ：レジスタ命令（ <nobr>番号2</nobr>および<nobr>5</nobr> ）に番号が格納されている2つのレジスタから選択し、内容を加算器の入力に送ります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -1つのデマルチプレクサ。加算器の出力をレジスタ入力に送り、そこに格納する必要があります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最新のプロセッサでは、オペレーティングユニットは複数のアクションを実行できます。 たとえば、ブロックには、加算器に加えて乗数が含まれる場合があります。 技術的な実装では、命令レジスタに保存されているオペレーションコードに応じて、加算器または乗算器を介して信号を送ることを選択するデマルチプレクサーとマルチプレクサーによってフレーム化された乗算器を加算器と並列に配置するだけで十分です。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>§3.2.1。</b>  <b>運用サイクルの構成：同期、スーパースカラー、パイプライン</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プロセッサは、次のサイクルの繰り返しであり、その間、情報は「 <nobr>レジスター→</nobr>作動<nobr>ユニット→</nobr>レジスター」という円で渡されます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -実行する命令をオペレーティングユニットにロードします。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -結果を待ちます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -結果をレジスタに保存します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     プロセッササイクルを編成するには、同期と非同期の2つのアプローチがあります。 同期プロセッサには信号導体があります。 変更されると（「導体が杖を振る」）、操作ユニットによって生成された値がレジスタに保存され、次の命令が操作ユニットに送信されます。 非同期プロセッサーには共通のコンダクター信号はありませんが、操作ユニット自体が結果の準備状況を報告します。 タスクとオペランドの準備が整った瞬間から、ブロックは結果の準備状況の監視を開始します。 計算の最後に、ブロックは結果を保存して次のタスクを要求するためのゴーサインを与えます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     同期プロセッサのクロック<nobr>速度</nobr>は固定です-1秒あたりの「指揮者のバトンの揺れ」の数。  「スイング」間の時間は、最も悲観的なシナリオに基づいて選択する必要があります。 ただし、実際には、ほとんどの場合、操作に必要な時間は数倍短くなります。  3つの要因が実行速度に影響します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -動作ブロックの初期状態：命令または引数の一部が事前にロードされている場合、ブロックの一部は事前に目的の状態になります。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -オペランドの値：したがって、短い数値の乗算は、長い数値の乗算よりもはるかに短い時間で済みます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      -バックグラウンドノイズレベル： <nobr>20°Cの</nobr>プロセッサ温度では<nobr>、</nobr>すべての操作が<nobr>90°Cの</nobr>温度よりもはるかに速く進行します<nobr>。</nobr> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     同期化されたアプローチでは、これらすべての要因を考慮することはできません。 さらに、温度に対するノイズレベルの依存性は、結晶<nobr>欠陥</nobr>の濃度によって決まります。この値は、インスタンスごとに異なり、プロセッサが古くなるにつれて増加します。 プロセッサのクロック周波数を計算するときは、最悪から、つまり<nobr>85〜90°Cの</nobr>温度で動作する使い古した平凡なインスタンスから処理を進める必要があります<nobr>。</nobr> この事実は、プロセッサのいわゆる「オーバークロック」を実行する人々によって使用されます。十分な冷却を備えた成功したインスタンスは、メーカーが設定したクロック速度を大幅に超えても安定して動作し続けます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     非同期プロセッサは、前のプロセッサの結果が準備でき次第、次の操作を開始します。 クロック周波数のようなものはありません。これらの条件では常に最大速度になります。非同期プロセッサにホットコーヒーを入れると速度が低下し、液体<nobr>窒素</nobr>を注ぐと加速します。 ただし、非同期回路は、その複雑さにより、現在、少数の実験的な非同期プロセッサでのみ使用されています（1951年に<nobr>ILLIAC I</nobr>から2010年にGA144で終了）。 将来、最適化の他の領域が残っていないため、おそらくより多く適用されるでしょう。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      10年以上にわたり、プロセッサは各タイプの複数のオペレーティングユニットをインストールしています。 このようなプロセッサはスーパースカラーと呼ばれます。 独立した<nobr>アクション</nobr>を同時に実行できます。たとえば、命令<nobr>「c = a + b」</nobr>と<nobr>「d = a・b」</nobr>を並行して実行します。 広く使用されている別の最適化手法は、いわゆる「パイプライン化」です。オペランドが準備される前にタスク命令が演算ブロックに書き込まれ、マルチプレクサーとデマルチプレクサーが事前に目的の状態に到達し、演算時間が大幅に短縮されます。 ただし、同期プロセッサは各命令に所定数の「バトンの揺れ」を与えて実行するため、パイプラインを使用することの最大の利点は非同期プロセッサでのみ得られ、命令をブロックにプリロードすることによる利得は比較的小さいためです。 さらに、非同期プロセッサで各オペランドの準備状況を個別に監視する場合、命令をプリロードするだけでなく、オペランドの1つが以前に準備できているため、時間を短縮できます。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペランドの</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備が整う前でも命令が機能する</font><font style="vertical-align: inherit;">場合があります。たとえば、オペランドの1つがゼロの場合、2番目のオペランドの準備が完了するまで乗算はゼロになります。</font><nobr><font style="vertical-align: inherit;">オペランドの</font></nobr></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用性を個別に制御する唯一の効果的な方法</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レジスタの1回限りの使用。この用語は、各サブプログラムの動作中に、各レジスタへの書き込みが1回だけ実行されることを意味します（値が上書きされることはありません）。手順の最後に、使用されたすべてのレジスタが空の状態にリセットされます。これにより、オペランドの可用性を簡単に確認できます。オペランドを含むレジスタが空にならない限り、オペランドの準備が整います。個別のレディネス制御を簡単に実装するには膨大な数のレジスタが必要ですが、実際にはこれは必要ありません。実際には、少数のハードウェアレジスタを使用せずに多数の論理レジスタをエミュレートできます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">§3.3。制御ブロックと割り込みブロック</font></font></b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制御ユニットは、メインメモリに記録されたプログラムに従って、オペレーティングユニット間でタスクを分配します。 RAMからプログラム命令をロードし、それらをデコードし、デコードされた形式で空き動作ブロックの命令レジスタに送信します。さらに、分岐および分岐命令を実行します。つまり、操作レジスタの値に応じてプログラム分岐の1つを選択します。プロセッサには複数のコントロールユニットがあり、複数のプログラムを並行して実行できます。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中央処理装置はプログラムを実行するだけでなく、ハードウェアの要求にも応答します。ハードウェアの</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエスト-</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、外部デバイスによって特別に割り当てられたプロセッサ入力に供給される信号です。たとえば、マウスボタンをクリックすると、プロセッサはこのイベントを処理するように要求されます。ハードウェア要求の処理は、割り込みブロックによって処理されます。要求を受信すると、割り込みブロックは空き制御ブロックを検索し、ハンドラープログラムを実行する命令を送信します。空きブロックがない場合、ブロックの1つを選択し、そのブロックで実行中のプログラムを一時的に中断し、ブロックをリダイレクトしてハードウェア要求を処理します。処理の終わりに、中断されたプログラムが再開します。割り込みブロックの名前の由来は、その作業のほとんどが正確にプログラムの実行の中断と再開にあるという事実にあります。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">§3.3.1。制御命令：ジャンプ、呼び出し、分岐、ループ</font></font></b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムは、連続したメモリ位置にある命令エンコードされた数字のセットです。何らかの理由で、連続したセルに連続した命令を配置できない場合、通常はジャンプ命令が使用されます。このような命令を読み取ると、制御ユニットは命令で指定されたアドレスを命令ポインタに書き込みます。従来のアーキテクチャでは、残りのレジスタの状態は移行中に変化しません。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">歴史的に、ジャンプ命令の主な用途はサブルーチンを呼び出すことですが、現在は別個の呼び出し命令とリターン命令がこれに使用されています。呼び出し命令は、呼び出されたサブルーチンが「ゼロから」動作するように、引数が配置されているレジスタの範囲を除き、すべてのレジスタをマスクまたはクリアします（特別に割り当てられたストレージに値をリセットします）。 （マスキングは、値をストレージに移動するよりも高速に動作しますが、動的レジスタの名前変更を使用するプロセッサでのみ実装できます。）サブルーチンの実行結果。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別なケースは、いわゆる末尾呼び出しです。つまり、特定のサブルーチン</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">て実行結果をより高いレベルに戻す</font><font style="vertical-align: inherit;">」などの命令のペアで終了</font><font style="vertical-align: inherit;">する状況</font><font style="vertical-align: inherit;">です。この場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出すときに</font><font style="vertical-align: inherit;">、現在のレジスタと</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻り</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点を保存またはマスクする必要はありません</font><nobr><font style="vertical-align: inherit;">-</font></nobr><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">、結果を</font><i><font style="vertical-align: inherit;">f</font></i><font style="vertical-align: inherit;">に戻してはならない</font><font style="vertical-align: inherit;">という呼び出されたルーチン</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">渡すことができます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すぐにより高いレベルに。テールコールは、移行中に保存するレジスタと破棄するレジスタを明示的に示すという点でのみ、このセクションの冒頭で説明した遷移と異なります。将来的には、「テールコール」遷移は、従来の遷移（動作レジスタの値を変更しない）を置き換えます。これは、従来の遷移が非同期実行とレジスタの1回限りの使用を妨げるが、「テールコール」遷移はそうではないためです。 （実際、returnステートメントは遷移の特別なケースである「テールコール」ですが、この美しい概念の議論はこのテキストの範囲を超えています。）</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しと遷移に加えて、制御ユニットは分岐命令を実行します。つまり、操作レジスタの1つの値に応じてプログラム分岐を選択します。分岐は従来、条件付き分岐命令を使用して行われますが、非同期プロセッサでは、従来の分岐操作ではなく、条件付き呼び出しまたは条件付きテール呼び出し命令を使用する方がはるかに優れています。この種の命令は、動作中のレジスタの値に応じて呼び出すサブルーチンが記述されているテーブルを示します。条件付き（末尾）呼び出し命令を使用すると、</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if-then-else</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><nobr><font style="vertical-align: inherit;">match-caseの</font></nobr><font style="vertical-align: inherit;">形式の構成を効果的に実装でき</font><nobr><font style="vertical-align: inherit;">ます</font></nobr></font><nobr><font style="vertical-align: inherit;"></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、条件付き再帰、それに応じて、可能なすべてのタイプのサイクル。追加の実行制御操作は必要ありません。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの場合、無料のコンピューティングリソースの分岐点に近づくと、呼び出されたルーチンの引数の大部分が準備できますが、どのルーチンを最終的に呼び出すかを決定する値は準備ができていません。この場合、最も可能性の高い1つ以上の手順の実行を投機的に開始し、「外部世界」に影響する操作のみを回避できます。パブリックRAMへの値の保存、外部デバイスへのアクセス、手順からの戻り。多くの状況でのこの最適化手法により、生産性が2倍以上向上します。</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分岐の例：</font></font>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (a &lt;&gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: { print <span class="hljs-string"><span class="hljs-string">"a and b are equal"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: { print <span class="hljs-string"><span class="hljs-string">"a is greater than b"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: { print <span class="hljs-string"><span class="hljs-string">"b is greater than a"</span></span> } }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>  <nobr>分岐</nobr>の最も一般的な特定のケース<nobr>は</nobr> <nobr>、if-then-else</nobr>バイナリ分岐です。 <pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { do_this } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { do_that }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>  ≡ <pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (condition) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span>: { do_this } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span>: { do that } }</code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre> 再帰の例： <pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcd</span></span></span></span>(a, b) = { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gcd(b, a % b) <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
     </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>§3.4。</b>  <b>おわりに</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     どうやら、中央処理装置のアーキテクチャはフォン・ノイマンのままです。 パフォーマンスの向上は、命令の並列化と非同期回路への移行により改善されます。 可能な限り最高の並列性を確保するには、より高度な<nobr>命令</nobr>セットに切り替える必要があります。特に、レジスタの1回限りの使用に適しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     最新のプロセッサは、1〜16個のコントロールユニットと4〜64個のオペレーティングユニットを使用します。 非同期回路への移行では、数十個の制御ユニットと数百個の操作ユニットを使用することが正当化されます。 このような移行と、それに対応するブロック数の増加により、ピークパフォーマンスが2桁以上、平均生産性が1桁以上向上します。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3> パート4。ↁⅠⅩが欲しい！ </h3>  1962年に、ドナルドクヌースは有名な本シリーズThe Art of Programmingの執筆を開始しました。これは、効果的なアルゴリズムを説明し、その速度を分析します。 低レベルのアルゴリズムを記述し、その実行時間を正確に評価する機能を維持するために、彼は高レベルのプログラミング言語を使用せず、アセンブラーで記述することにしました。 しかし、実際のプロセッサのアーキテクチャとアセンブラは、 <nobr>本質</nobr>から逸脱する奇妙な技術的特徴で満たされています<nobr>-</nobr>当時、それらは必要なエンジニアリングの妥協と技術的なトリックの結果でしたが、今日の主なソースは古いモデルとの後方互換性の要件です。 読者に不必要で急速に老化する詳細で過負荷にならず、プレゼンテーションの汎用性を保持しないために、Knutはトレーニング専用に設計された独自のコンピューターアーキテクチャを開発することにしました。 このアーキテクチャはMIXと呼ばれます。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     次の30年間で、コンピューターテクノロジーの分野で大きな変化が起こり、MIXはほとんど時代遅れになっています。  「プログラミングの芸術」を引き続き関連するソースとして維持するために、著者は<nobr>MMIX</nobr>プロセッサの主要な産業開発者とともに、1990年代後半に理想化され改善されたコンピューターの類似物で<nobr>ある</nobr>新しい架空のコンピューターを開発することを決定しました。  MMIXは、すぐにハードウェアを実装するのに適した十分に考え抜かれたアーキテクチャであり、現在広く使用されているすべてのプロセッサアーキテクチャよりも著しく発展しています。 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1990年代後半のツールを使用して「ハードウェア」で効果的に実装できるマシンを作りたいという願望は、 <nobr>将来の</nobr>ための十分な準備を妨げました<nobr>-</nobr>残念ながら、MMIX命令セットは非同期スーパースカラープロセッサの可能性を実現するのに実際には不適切です。 実際、MMIXでの呼び出しの編成は、従来の遷移の使用に基づいており、レジスタの書き換えが必要です。 有望なプログラミング手法の実用的な研究のために、上記の中央<nobr>処理装置</nobr>の開発における避けられない傾向に従ってこの命令セットを修正する必要があります。幸いなことに、これはそれほど難しい作業ではありません。 </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../J114572/index.html">InnoDBでの全文検索</a></li>
<li><a href="../J114573/index.html">PHPでの木を見る</a></li>
<li><a href="../J114574/index.html">Yandex.Money：カードからの直接支払い</a></li>
<li><a href="../J114576/index.html">Pythonオブジェクトシステムに関する注意事項パート1</a></li>
<li><a href="../J114578/index.html">2.5歳のアメリカ人は、存在しないインターネットガールフレンドの請求書を支払った</a></li>
<li><a href="../J114580/index.html">ボタンの簡単なクリック</a></li>
<li><a href="../J114583/index.html">Microsoftは、従業員がWindows Phone 7のアプリケーションで稼ぐことを許可しました</a></li>
<li><a href="../J114585/index.html">Pythonパート2オブジェクトシステムに関する注意</a></li>
<li><a href="../J114587/index.html">Pythonオブジェクトシステムに関するパート3</a></li>
<li><a href="../J114588/index.html">C言語の歴史</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter70218013 = new Ya.Metrika({
                  id:70218013,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/70218013" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'G-FEDBM7F51Q', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Clever Geek | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <div class="company-info js-company-info" itemscope="" itemtype="http://schema.org/Organization">
      <span itemprop="name">Western Town Media (WTM)</span>
      <div itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress">
        <span itemprop="streetAddress">1968 Stoney Lonesome Road</span>
        <br>
        <span itemprop="postalCode">PA 18640</span>
        <span itemprop="addressLocality">Pittston, USA</span>
      </div>
      <span itemprop="telephone">570-362-1316</span>
    </div>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Organization",
        "address": {
          "@type": "PostalAddress",
          "addressLocality": "Pittston, USA",
          "postalCode": "PA 18640",
          "streetAddress": "1968 Stoney Lonesome Road"
        },
        "name": "Western Town Media (WTM)",
        "telephone": "570-362-1316"
      }
    </script>
  </div>
</footer>
  
</body>

</html>